---
categories: interview
---
<P>发信人: Mobem (Waiting...), 信区: CPlusPlus<BR>标&nbsp; 题: 问一个auto_ptr的问题<BR>发信站: 水木社区 (Tue Nov&nbsp; 6 11:45:18 2007), 站内</P>
<P>class A<BR>{<BR>&nbsp;&nbsp;&nbsp; protected:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a;<BR>&nbsp;&nbsp;&nbsp; public:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(int n){a = n;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f(){std::cout&lt;&lt;"f is invoked!"&lt;&lt;'\n';}<BR>};</P>
<P>int main(int argc, char *argv[])<BR>{&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; A* pp = new A(4);<BR>&nbsp;&nbsp;&nbsp; std::auto_ptr&lt;A&gt; p(pp);<BR>&nbsp;&nbsp;&nbsp; p-&gt;f();<BR>&nbsp;&nbsp;&nbsp; p.operator-&gt;()-&gt;f();<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}<BR>程序执行时p-&gt;f()和p.operator-&gt;()-&gt;f()的结果一样，看了auto_ptr模板类的实现，发现其中对-&gt;操作符的定义如下：<BR>&nbsp; _Tp* operator-&gt;() const __STL_NOTHROW {<BR>&nbsp;&nbsp;&nbsp; return _M_ptr;<BR>&nbsp; }<BR>不理解的是p-&gt;f()这个调用是如何做到的？难道在调用时做了p到p.opertaor-&gt;()的隐式转换？但在auto_ptr模板类的定义中没有看到opertor _TP*()的定义啊。<BR>--<BR>x-&gt;m <BR>x.operator-&gt;()-&gt;m<BR>x.operator-&gt;().operator-&gt;()-&gt;m<BR>..<BR>you are right<BR>【 在 devilphoenix (初號機·神·小白) 的大作中提到: 】<BR>: An expression x-&gt;m is interpreted as (x.operator-&gt;())-&gt;m for a class object x of type T if T::operator-&gt;() exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).<BR>: 没看懂你是啥意思<BR><A href="http://www.newsmth.net/bbstcon.php?board=CPlusPlus&amp;gid=204956">http://www.newsmth.net/bbstcon.php?board=CPlusPlus&amp;gid=204956</A></P>