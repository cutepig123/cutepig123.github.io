<DIV class=wr>&nbsp;</DIV>
<DIV class="mb12 bai">
<DIV class=rr>
<DIV class=bc0 style="PADDING-RIGHT: 0pt; PADDING-LEFT: 0pt; PADDING-BOTTOM: 5px; PADDING-TOP: 5px">
<DIV class=wr>
<DIV class="f14 p90 pl10"><CA>COM服务器为进程内服务器，DLL名为simpCOM.dll,该组件只有一个接口IFoo,该接口只有一个方法HRESULT SayHello(void) <BR><BR><BR>在SDK中调用 <BR>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ <BR>一、最简单最常用的一种，用#import导入类型库，利用VC提供的智能指针包装类 <BR>演示代码: <BR><BR>#import "D:\Temp\vc\simpCOM\Debug\simpCOM.dll" no_namespace <BR>CoInitialize(NULL); <BR><BR>IFooPtr spFoo = NULL; <BR>spFoo.CreateInstance(__uuidof(Foo)); <BR>spFoo-&gt;SayHello(); <BR>spFoo.Release();/*晕死了，本来智能指针就是为了让用户不用关心这个的，可是我发现如果不手工调用一下的话，程序退出后会发生内存访问错误，我是在console中做试验的，哪位大侠知道怎么回事请一定指教*/ <BR>CoUninitialize(); <BR><BR><BR><BR>二、引入midl.exe产生的*.h,*_i.c文件，利用CoCreateInstance函数来调用 <BR><BR>演示代码: <BR>/*在工程中加入*_i.c文件，例如本例的simpCOM_i.c,该文件定义了类和接口的guid值，如果不引入的话，会发生连接错误。*/ <BR><BR>#include "D:\Temp\vc\simpCOM\simpCOM.h" <BR>CoInitialize(NULL); <BR><BR>IFoo* pFoo = NULL; <BR>HRESULT hr = CoCreateInstance(CLSID_Foo, NULL, CLSCTX_ALL, IID_IFoo, (void**)&amp;pFoo); <BR>if (SUCCEEDED(hr) &amp;&amp; (pFoo != NULL)) <BR>{ <BR>pFoo-&gt;SayHello(); <BR>pFoo-&gt;Release(); <BR>} <BR><BR>CoUninitialize(); <BR><BR>三、不用CoCreateInstance，直接用CoGetClassObejct得到类厂对象接口，然后用该接口的方法CreateInstance来生成实例。 <BR>演示代码: <BR>/*前期准备如二方法所述*/ <BR>IClassFactory* pcf = NULL; <BR>HRESULT hr = CoGetClassObject(CLSID_Foo, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&amp;pcf); <BR>if (SUCCEEDED(hr) &amp;&amp; (pcf != NULL)) <BR>{ <BR>IFoo* pFoo = NULL; <BR>hr = pcf-&gt;CreateInstance(NULL, IID_IFoo, (void**)&amp;pFoo); <BR>if (SUCCEEDED(hr) &amp;&amp; (pFoo != NULL)) <BR>{ <BR>pFoo-&gt;SayHello(); <BR>pFoo-&gt;Release(); <BR>} <BR>pcf-&gt;Release(); <BR>} <BR><BR><BR><BR>四、不用CoCreateInstance or CoGetClassObject,直接从dll中得到DllGetClassObject，接着生成类对象及类实例（本方法适合于你想用某个组件，却不想在注册表中注册该组件） <BR><BR>演示代码: <BR>/*前期准备工作如二方法所述，事实上只要得到CLSID和IID的定义及接口的定义就行*/ <BR><BR>typedef HRESULT (__stdcall * pfnGCO) (REFCLSID, REFIID, void**); <BR>pfnGCO fnGCO = NULL; <BR>HINSTANCE hdllInst = LoadLibrary("D:\\Temp\\vc\\simpCOM\\Debug\\simpCOM.dll"); <BR>fnGCO = (pfnGCO)GetProcAddress(hdllInst, "DllGetClassObject"); <BR>if (fnGCO != 0) <BR>{ <BR>IClassFactory* pcf = NULL; <BR>HRESULT hr=(fnGCO)(CLSID_Foo, IID_IClassFactory, (void**)&amp;pcf); <BR>if (SUCCEEDED(hr) &amp;&amp; (pcf != NULL)) <BR>{ <BR>IFoo* pFoo = NULL; <BR>hr = pcf-&gt;CreateInstance(NULL, IID_IFoo, (void**)&amp;pFoo); <BR>if (SUCCEEDED(hr) &amp;&amp; (pFoo != NULL)) <BR>{ <BR>pFoo-&gt;SayHello(); <BR>pFoo-&gt;Release(); <BR>} <BR>pcf-&gt;Release(); <BR>} <BR>} <BR>FreeLibrary(hdllInst); <BR><BR><BR>在MFC中调用 <BR>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ <BR>在MFC中除了上面的几种方法外，还有一种更方便的方法，就是通过ClassWizard利用类型库生成包装类，不过有个前提就是com组件的接口必须是派生自IDispatch <BR><BR>具体方法： <BR>1、按Ctrl+W调出类向导，按Add Class按钮弹出新菜单，选From a type libarary，然后定位到simpCOM.dll，接下来会出来该simpCOM中的所有接口，选择你想生成的接口包装类后，向导会自动生成相应的.cpp和.h文件. <BR>这样你就可以在你的MFC工程中像使用普通类那样使用COM组件了. <BR><BR>演示代码: <BR><BR>CoInitialize(NULL); <BR><BR>IFoo foo; <BR>if (foo.CreateDispatch("simpCOM.Foo") != 0) <BR>{ <BR>foo.SayHello(); <BR>foo.ReleaseDispatch(); <BR>} <BR><BR>CoUninitialize();</DIV></DIV></DIV></DIV></DIV>