<h1>ATL揭秘之&#8220;对象创建&#8221;篇</h1><div class="from_info">总结:<br />客户调用coCreateInstance(),<br />&nbsp;&nbsp; 该函数内部首先<font size="2"><span lang="EN-US"><font face="Courier">CoGetClassObject</font></span><span style="font-family: 宋体;">通过注册表机制，找到相应的服务器，并且调用服务器的</span><span lang="EN-US"><font face="Courier">DllGetClassObject</font></span><span style="font-family: 宋体;">函数来获得类厂</span></font><br />&nbsp; 然后调用类厂的 <font size="2"><span style="font-family: 宋体;"></span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法来创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象了</span></font><br />对于ATL COM来说<br />&nbsp; <font size="2"><span style="font-family: 宋体;"></span><span lang="EN-US"><font face="Courier">DllGetClassObject</font></span><span style="font-family: 宋体;"></span></font>会调用 <font size="2"><span style="font-family: 宋体;"></span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">的成员函数</span><span lang="EN-US"><font face="Courier">GetClassObject</font></span><span style="font-family: 宋体;">。</span><span lang="EN-US"><font face="Courier">GetClassObject</font></span><span style="font-family: 宋体;">遍历结构数组，找到相应的</span><span lang="EN-US"><font face="Courier">CLSID</font></span><span style="font-family: 宋体;">对应的</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构。</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">会先检查结构中的</span><span lang="EN-US"><font face="Courier">pCF</font></span><span style="font-family: 宋体;">，这是</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">缓存的类厂对象指针，如果不为空，则可以直接利用该指针来创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象，如果为空，则调用结构中的</span><span lang="EN-US"><font face="Courier">pfnGetClassObject</font></span><span style="font-family: 宋体;">函数指针，创建相应的类厂对象并且把类厂对象的指针缓存到</span><span lang="EN-US"><font face="Courier">pCF</font></span><span style="font-family: 宋体;">成员数据中。</span></font>最后实际调用的GetClassObject为static函数<span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><strong><span style="background: yellow none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">class::_ClassFactoryCreatorClass::CreateInstance</span></strong></font></span>, 找到类厂后,接着调用类厂的createinstance, 似乎也是在这个表里找<span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><strong><span style="background: yellow none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">class::_CreatorClass::CreateInstance</span></strong></font></span>,<br />&nbsp;&nbsp; <strong><span style="color: blue;" lang="EN-US"><font face="Courier"><font size="2">CComCreator::CreateInstance</font></font></span></strong>这样写的...<br /><br />http://www.diybl.com/　2007-10-9 　网络　点击:<span style="color: #ff0000; font-weight: bold;"><script lanuage="javascript" src="http://www.diybl.com/count/p_count.asp?id=77292"></script>       </span>　<a href="http://www.diybl.com/course/3_program/c/c_js/2007109/77292.html#comment">[ 评论 ]</a></div>                  <div id="ad_f2" class="ad_f2"><script src="http://www.diybl.com/ad/ad_f2.js"></script><script type="text/javascript">  cpro_client='diybl_cpr'; cpro_at='text_image';  cpro_161=2;  cpro_flush=4;  cpro_w=300;  cpro_h=120;  cpro_template='text_default_300_120';  cpro_cbd='#F5FAFE';  cpro_cbg='#F5FAFE';  cpro_ctitle='#940F04';  cpro_cdesc='#333333';  cpro_curl='#333333';  cpro_cflush='#e10900';  cpro_uap=1; cpro_cad=1; cpro_channel=8898; </script> <script language="JavaScript" type="text/javascript" src="http://cpro.baidu.com/cpro/ui/cp.js"></script><div style="display: none;">-</div> </div><div id="ad_f3" class="ad_f3"><script src="http://www.diybl.com/ad/ad_f3.js"></script><script type="text/javascript">  cpro_client='diybl_cpr'; cpro_at='text_image';  cpro_161=3;  cpro_flush=4;  cpro_w=300;  cpro_h=280;  cpro_template='text_default_300_280';  cpro_cbd='#F5FAFE';  cpro_cbg='#F5FAFE';  cpro_ctitle='#11593C';  cpro_cdesc='#333333';  cpro_curl='#333333';  cpro_cflush='#e10900';  cpro_uap=1; cpro_cad=1; cpro_channel=8899; </script> <script language="JavaScript" type="text/javascript" src="http://cpro.baidu.com/cpro/ui/cp.js"></script><div style="display: none;">-</div> </div>文章搜索：         <input name="wd2" size="30" maxlength="255" type="text" />         &nbsp;&nbsp; <input value="千寻搜索" onclick="tosearch(document.all.wd2);" type="button"><a href="javascript:self.location='/user/chm/rar.asp?c_id=48375'" class="redlink">【点击打包该文章】</a> <script src="http://www.diybl.com/js/art_top.js"></script><a href="http://video.diybl.com/" target="_blank"><img src="http://img.diybl.com/ad/video.gif" alt="" border="0" /></a> <br /><a href="http://bbs.diybl.com/viewthread.php?tid=20852&amp;extra=page%3D1" target="_blank" class="redlink">【本站开通在线QQ讨论群】</a> <p>       		</p><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>1<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;">问题</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">当我们用</span><span lang="EN-US"><font face="Courier">VC++ ATL</font></span><span style="font-family: 宋体;">工程创建了一个</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">工程，实现了一个自己的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象，又在另一个程序中</span><span lang="EN-US"><font face="Courier">CoCreateInstance</font></span><span style="font-family: 宋体;">这个</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象时，不知你是否想过这样的问题：</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象是用</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">类对象实现的，但是，我们从来没有在自己的代码中创建这些</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">类对象&#8212;&#8212;比如，&#8220;</span><span lang="EN-US"><font face="Courier">new</font></span><span style="font-family: 宋体;">&#8221;这些对象。那么，实现</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象是由谁，何时，以及如何创建的呢？</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">当然，简单而且正确的回答是：</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">在幕后帮助我们完成了这些工作。如果你不想了解</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">的工作细节，这样的回答应该是足够了。然而，</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">本身的思想就是&#8220;白盒&#8221;操作，想要用好</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">，就应该尽量多地了解</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">的工作细节。所以，搞清楚这个问题还是很有必要的。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">想到这个问题后，出于懒惰的天性，我首先上网，试图找到别人对于这个问题的讲述，然而，大家要么讨论</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象，要么讨论</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">其他的机制，似乎没有人特别关注</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象的创建过程，更比较少有人留心</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">如何将</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象创建过程转换到</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象创建过程上。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">在研究这个问题的过程中，我逐渐发现这个问题很有意思，对这个问题的完整回答涉及了</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">相当多的基础结构。弄清楚了这个问题，对</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">的了解也会加深不少。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">下面，我们就一起开始</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">对象创建揭秘之旅。</span></font></p><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>2<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US"><span>&nbsp;</span></span><span style="font-family: 宋体;">&#8220;对象&#8221;探讨</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">既然谈&#8220;对象创建&#8221;，则有必要对&#8220;对象&#8221;这个概念作一点讨论。在实际工作中，我感觉不少人对&#8220;对象&#8221;这个概念有不少误解；对&#8220;</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象&#8221;也没有清晰的认识。</span></font></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>2.1</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"><em>对象性质</em></span></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2">这似乎是老生常谈了。对象性质，不就是&#8220;封装、继承、多态&#8221;这三个陈词滥调吗？然而，孔老夫子教导我们说：&#8220;温故而知新&#8221;。真理往往就蕴含在陈词滥调中。经过这些年的软件生涯，我对这句&#8220;陈词滥调&#8221;似乎有了更多地理解：</font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">首先，&#8220;对象性质&#8221;是个独立的概念，也就是说，凡是具备了这个性质的东西就可以被称作对象。因此，一来&#8220;对象&#8221;不一定要用面向对象的语言编写，二来&#8220;对象&#8221;也可以具备各种环境下的语义&#8212;&#8212;面向对象语言生成的对象是&#8220;编程语言&#8221;语义下的对象，如&#8220;</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象&#8221;；</span><font face="Courier"> </font><span style="font-family: 宋体;">面向组件的开发生成的对象是&#8220;组件环境&#8221;语义下的对象，如&#8220;</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象&#8221;。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2">其次，对象性质中的&#8220;继承&#8221;、&#8220;多态&#8221;需要好好斟酌。</font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">什么是&#8220;继承&#8221;？是不是一定要用&#8220;</span><span lang="EN-US"><font face="Courier">CMyObject::CBaseObject</font></span><span style="font-family: 宋体;">&#8221;这样的语法才叫继承？当然不是，&#8220;继承&#8221;应该是对&#8220;对象层次结构&#8221;的有效处理。只要能够有效地处理对象层次结构，使低层对象能够自动具备高层对象的特性、行为，就应该可以被叫做&#8220;继承&#8221;。&#8220;</span><span lang="EN-US"><font face="Courier">CMyObject::CBaseObject</font></span><span style="font-family: 宋体;">&#8221;干的是什么事？不就是把</span><span lang="EN-US"><font face="Courier">CBaseObject</font></span><span style="font-family: 宋体;">的成员变量复制给了</span><span lang="EN-US"><font face="Courier">CMyObject</font></span><span style="font-family: 宋体;">，并且使</span><span lang="EN-US"><font face="Courier">CMyObject</font></span><span style="font-family: 宋体;">的对象能够调用</span><span lang="EN-US"><font face="Courier">CBaseObject</font></span><span style="font-family: 宋体;">的公有和保护方法吗？</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">再说&#8220;多态&#8221;。</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">语言说&#8220;多态&#8221;就是支持虚函数调用，这样讲对，但是局限在</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">语言本身上。&#8220;虚函数调用&#8221;是某些语言的特性，难道没有虚函数的语言就无法支持多态了？其实&#8220;多态&#8221;这个词本身译得很好，直抒其意&#8212;&#8212;&#8220;多姿多态&#8221;。&#8220;多态&#8221;本质上是&#8220;运行时决定行为&#8221;。只要能够在运行时才决定如何行动，而不是在编译时决定，就是&#8220;多态&#8221;。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2">综合看来，&#8220;继承&#8221;和&#8220;多态&#8221;都不是面向对象语言的专利，其他的语言，只要能够通过某种机制实现这些特性，就可以实现&#8220;对象&#8221;。</font></span></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>2.2</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><em><span lang="EN-US">COM</span><span style="font-family: 宋体;">对象</span></em></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">规范对于</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象如何做到&#8220;封装、继承、多态&#8221;有自己的规定。该规定不依赖具体语言，不依赖具体的操作系统环境，所以，我们说</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">规范是语言中立和平台中立的（当然，提供平台的人并不中立，这和规范的中立是两码事）。</span></font></p><ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">&#8220;封装&#8221;：</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象只处理行为封装，其工具是&#8220;接口&#8221;；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">&#8220;继承&#8221;：</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">的继承不是源代码级别，是二进制代码级别。</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象提供了两种方式来继承对象的二进制代码&#8212;&#8212;&#8220;包容&#8221;和&#8220;聚合&#8221;；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">&#8220;多态&#8221;：</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">的&#8220;运行时决定行为&#8221;能力来自不同对象实现同一接口。使用</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">的统一方式&#8212;&#8212;</span><span lang="EN-US"><font face="Courier">QueryInterface</font></span><span style="font-family: 宋体;">，我们可以找到不同</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象对同一接口的实现，从而实现&#8220;运行时决定行为&#8221;。</span> </font></li></ul><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">当然，</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象除了这老三样之外，还要其他性质，其中最重要的就是对象的&#8220;生命周期管理&#8221;。&#8220;生命周期管理&#8221;通过</span><span lang="EN-US"><font face="Courier">AddRef</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">Release</font></span><span style="font-family: 宋体;">这两个&#8220;引用计数&#8221;函数实现。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;</font></o:p></span></p><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>3<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US">ATL COM</span><span style="font-family: 宋体;">对象</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">实现</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的基本思路是：针对不同的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象性质，分层处理。不同的</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">类层次处理特定的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象特性。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象的层次结构如下图所示：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/hellothere/Class_diagram_Object.gif" border="0" width="180" height="443" /></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%; text-align: center;" align="center"><span lang="EN-US"><font size="2"><v:shapetype id="_x0000_t75" stroked="f" filled="f" path="m@4@5l@4@11@9@11@9@5xe" o:preferrelative="t" o:spt="75" coordsize="21600,21600"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:connecttype="rect" gradientshapeok="t" o:extrusionok="f"></v:path><o:lock aspectratio="t" v:ext="edit"></o:lock></v:shapetype><v:shape id="_x0000_i1025" style="width: 117pt; height: 4in;" fillcolor="window" type="#_x0000_t75"><v:imagedata o:title="Class_diagram_Object" src="file:///C:%5CDOCUME%7E1%5Choward%5CLOCALS%7E1%5CTemp%5Cmsohtml1%5C01%5Cclip_image001.png"></v:imagedata></v:shape></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2">从上图可以看到：</font></span></p><ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">最基础的类是</span><span lang="EN-US"><font face="Courier">CComObjectRootBase</font></span><span style="font-family: 宋体;">。该类除了提供</span><span lang="EN-US"><font face="Courier">InternalQueryInterface</font></span><span style="font-family: 宋体;">方法外，还实现了若干帮助方法可供最终派生类</span><span lang="EN-US"><font face="Courier">CComObject</font></span><span style="font-family: 宋体;">调用；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">CComObjectRootEx</font></span><span style="font-family: 宋体;">是个模板类。该类根据不同的线程模型生成足够线程安全的</span><span lang="EN-US"><font face="Courier">InternalAddRef</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">InternalRelease</font></span><span style="font-family: 宋体;">函数。为什么只提供一个</span><span lang="EN-US"><font face="Courier">CComObjectRootEx</font></span><span style="font-family: 宋体;">类呢？我觉得主要的原因是：</span><span lang="EN-US"><font face="Courier">CComObjectRootBase</font></span><span style="font-family: 宋体;">实现的</span><span lang="EN-US"><font face="Courier">InternalQueryInterface</font></span><span style="font-family: 宋体;">不涉及对类成员数据的线程保护，不涉及线程安全因素；</span><span lang="EN-US"><font face="Courier">CComObjectRootEx</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">InternalAddRef</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">InternalRelease</font></span><span style="font-family: 宋体;">方法则和线程安全密切相关，故</span><span lang="EN-US"><font face="Courier">CComObjectRootEx</font></span><span style="font-family: 宋体;">有必要作为模板类实现。将这两个类揉到一起实现反而显得不清晰；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">我们自己定义的类直接从</span><span lang="EN-US"><font face="Courier">CComObjectRootEx</font></span><span style="font-family: 宋体;">继承，根据需要选择不同的线程模型；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">最后实际创建的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象是</span><span lang="EN-US"><font face="Courier">CComObject</font></span><span style="font-family: 宋体;">、</span><span lang="EN-US"><font face="Courier">CComAggObject</font></span><span style="font-family: 宋体;">等类的实例。这些类负责真正实现</span><span lang="EN-US"><font face="Courier">QueryInterface</font></span><span style="font-family: 宋体;">、</span><span lang="EN-US"><font face="Courier">AddRef</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">Release</font></span><span style="font-family: 宋体;">方法，具体选择哪个类根据宏定义来决定。具体在哪里定义什么宏在</span><span lang="EN-US"><font face="Courier">4.3</font></span><span style="font-family: 宋体;">节会讲到。</span> </font></li></ul><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>4<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US">ATL COM</span><span style="font-family: 宋体;">对象创建&#8212;&#8212;内部机制</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">所谓内部机制，指的是类厂创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的过程。由于类厂也在</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的实现类中实现，所以，类厂对象创建相应</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的过程可以看作是</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的内部过程。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">正是在这个内部机制中，&#8220;</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象创建&#8221;这个动作被转换到&#8220;</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象创建&#8221;这个动作上。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><font size="2">下图是对内部机制的简单勾勒：</font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"><a href="http://writeblog.csdn.net/images/hellothere/Image/hellothere/Class_diagram_Object_Creation.gif" target="_self"><font size="2"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/hellothere/Class_diagram_Object_Creation.gif" border="0" width="396" height="273" /></font></a></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%; text-align: center;" align="center"><span lang="EN-US"><v:shape id="_x0000_i1026" style="width: 277.5pt; height: 190.5pt;" fillcolor="window" type="#_x0000_t75"><v:imagedata o:title="Class_diagram_Object_Creation" src="file:///C:%5CDOCUME%7E1%5Choward%5CLOCALS%7E1%5CTemp%5Cmsohtml1%5C01%5Cclip_image003.png"></v:imagedata></v:shape></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">从这幅图中可以看到，内部创建主要涉及三个类的交互作用，它们是：</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">，</span><span lang="EN-US"><font face="Courier">CComClassFactory</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">。下面就对这三个类分别讲述。</span></font></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>4.1</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><em><span lang="EN-US">CComCreator</span><span style="font-family: 宋体;">&#8212;&#8212;</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">对象创建器</span></em></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">规范要求用类厂来创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象，其目的是使</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象能够控制自己的创建过程（&#8220;类厂&#8221;设计模式的典型应用）。由于类厂对象本身也是一个</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象，所以，</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">为了统一</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的创建过程，封装了一个</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">类。</span><span lang="EN-US"><font face="Courier">ATL CComCreator</font></span><span style="font-family: 宋体;">这个类的作用很单纯，正如其名字所表示的&#8212;&#8212;创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象。该类包装了一个</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">静态方法（之所以是静态方法，因为该方法要放到</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">中，后面会讲到），正是在</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法中，</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建被转换到具体的</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象创建上。由于这个类如此重要，因此有必要列出这个类的实现：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">template &lt;class T1&gt;<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">class CComCreator<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">{<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">public:<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span>static HRESULT WINAPI CreateInstance(void* pv, REFIID riid,<br /><span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LPVOID* ppv)<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ATLASSERT(*ppv == NULL);<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>HRESULT hRes = E_OUTOFMEMORY;<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>T1* p = NULL;<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><strong><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="background: yellow none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">ATLTRY(p = new T1(pv))</span><o:p></o:p></font></span></strong></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (p != NULL)<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p-&gt;SetVoid(pv);<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p-&gt;InternalFinalConstructAddRef();<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>hRes = p-&gt;FinalConstruct();<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p-&gt;InternalFinalConstructRelease();<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (hRes == S_OK)<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>hRes = p-&gt;QueryInterface(riid, ppv);<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (hRes != S_OK)<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>delete p;<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return hRes;<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">};</font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">其中，底色是黄色的那句代码就是实际创建</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象的代码。看到熟悉的&#8220;</span><span lang="EN-US"><font face="Courier">new</font></span><span style="font-family: 宋体;">&#8221;了。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">从这个类是模板类也可以看出，</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">中所有的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象创建，最终其实都是由</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">类负责。比如，创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象可以用</span><span lang="EN-US"><font face="Courier">CComCreator&lt;CComObject&gt;</font></span><span style="font-family: 宋体;">的形式；创建类厂类可以用</span><span lang="EN-US"><font face="Courier">CComCreator&lt;CComClassFactory&gt;</font></span><span style="font-family: 宋体;">的形式。后面那个</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">CComClassFactory</font></span><span style="font-family: 宋体;">就是我们说的类厂类。</span></font></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>4.2</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US"><em>CComClassFactory</em></span></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">每个</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象类都有一个自己的类厂类，专门负责创建该类的类对象。在</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">中，缺省的类厂类是</span><span lang="EN-US"><font face="Courier">CComClassFactory</font></span><span style="font-family: 宋体;">。类厂类也有一个</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法，该方法调用类厂类保存的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象类的</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">的静态</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">函数指针，创建相应的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象。</span></font></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>4.3</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US"><em>CComCoClass</em></span></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">是一个非常重要的</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">实现类。基本上我们自己的类都要从</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">继承。为什么？因为</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">定义了两个宏：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span>DECLARE_CLASSFACTORY()<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier"><span>&nbsp;&nbsp;&nbsp; </span>DECLARE_AGGREGATABLE(T)<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">前一个宏定义了</span><span lang="EN-US"><font face="Courier">_ClassFactoryCreatorClass</font></span><span style="font-family: 宋体;">&#8212;&#8212;类厂类的创建者，该创建者可以使用不同的类厂类作为模板参数，为</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的创建过程提供了灵活性；后一个宏定义了</span><span lang="EN-US"><font face="Courier">_CreatorClass</font></span><span style="font-family: 宋体;">&#8212;&#8212;</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象类的创建者，该创建者使用</span><span lang="EN-US"><font face="Courier">CComObject</font></span><span style="font-family: 宋体;">类族的不同类作为模板参数，为</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象</span><span lang="EN-US"><font face="Courier">QueryInterface</font></span><span style="font-family: 宋体;">、</span><span lang="EN-US"><font face="Courier">AddRef</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">Release</font></span><span style="font-family: 宋体;">函数的实现方式提供了不同选择。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">通过继承</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">，我们自己的类就继承了</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">对类厂和最后生成类的实现。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">也有一个</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法。该方法纯粹是对</span><span lang="EN-US"><font face="Courier">_CreatorClass::CreateInstance</font></span><span style="font-family: 宋体;">方法的包装。因为我们的类继承自</span><span lang="EN-US"><font face="Courier">CComCoClass</font></span><span style="font-family: 宋体;">，经过这个包装后，就可以直接以</span><span lang="EN-US"><font face="Courier">CUserClass::CreateInstance</font></span><span style="font-family: 宋体;">的方式来调用</span><span lang="EN-US"><font face="Courier">CComCreator::CreateInstance</font></span><span style="font-family: 宋体;">了。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">上图看到的三个</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法，各有各的意义，这里总结一下：</span></font></p><table class="MsoNormalTable" style="border: medium none ; border-collapse: collapse;" border="1" cellpadding="0" cellspacing="0">    <tr>            <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><strong><span style="color: blue;" lang="EN-US"><font face="Courier"><font size="2">CComCreator::CreateInstance<o:p></o:p></font></font></span></strong></p>            </td>            <td style="border-color: windowtext windowtext windowtext #e0dfe3; border-top: 1pt solid windowtext; border-right: 1pt solid windowtext; border-bottom: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">真正创建</span><span lang="EN-US"><font face="Courier">C++</font></span><span style="font-family: 宋体;">对象的所在</span></font></p>            </td>        </tr>        <tr>            <td style="border-color: #e0dfe3 windowtext windowtext; border-left: 1pt solid windowtext; border-right: 1pt solid windowtext; border-bottom: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><strong><span style="color: blue;" lang="EN-US"><font face="Courier"><font size="2">CComClassFactory::CreateInstance<o:p></o:p></font></font></span></strong></p>            </td>            <td style="border-color: #e0dfe3 windowtext windowtext #e0dfe3; border-right: 1pt solid windowtext; border-bottom: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">调用</span><span lang="EN-US"><font face="Courier">_CreatorClass::CreateInstance</font></span></font></p>            </td>        </tr>        <tr>            <td style="border-color: #e0dfe3 windowtext windowtext; border-left: 1pt solid windowtext; border-right: 1pt solid windowtext; border-bottom: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><strong><span style="color: blue;" lang="EN-US"><font face="Courier"><font size="2">CComCoClass::CreateInstance<o:p></o:p></font></font></span></strong></p>            </td>            <td style="border-color: #e0dfe3 windowtext windowtext #e0dfe3; border-right: 1pt solid windowtext; border-bottom: 1pt solid windowtext; padding: 0cm 5.4pt; width: 221.4pt; background-color: transparent;" valign="bottom" width="295">            <p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">调用</span><span lang="EN-US"><font face="Courier">_CreatorClass::CreateInstance</font></span></font></p>            </td>        </tr>    </table><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">至此，估计大家一定有一个疑问：</span><span lang="EN-US"><font face="Courier">_CreatorClass::CreateInstance</font></span><span style="font-family: 宋体;">由类厂对象的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">调用；</span><span lang="EN-US"><font face="Courier">_ClassFactoryCreatorClass::CreateInstance</font></span><span style="font-family: 宋体;">又由谁来调用呢？这就是我们要进入的下一个论题：</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建的外部机制。</span></font></p><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>5<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US">ATL COM</span><span style="font-family: 宋体;">对象创建&#8212;&#8212;外部机制</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">所谓&#8220;外部机制&#8221;，指的是应用程序创建</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象类厂的过程。应用程序并不关心</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象是</span><span lang="EN-US"><font face="Courier">MFC</font></span><span style="font-family: 宋体;">实现方式的还是</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">实现方式的，它永远使用</span><span lang="EN-US"><font face="Courier">CoCreateInstance</font></span><span style="font-family: 宋体;">这类</span><span lang="EN-US"><font face="Courier">API</font></span><span style="font-family: 宋体;">函数，通过类厂创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象。在</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">下，应用程序对</span><span lang="EN-US"><font face="Courier">CoCreateInstance</font></span><span style="font-family: 宋体;">的调用，是如何转换到对</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象类厂</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法的调用的呢？</span></font></p><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>5.1</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><em><span lang="EN-US">COM</span><span style="font-family: 宋体;">服务器</span></em></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象不能凭空存在，它必须存在于操作系统的某种可执行文件中。由于只有</span><span lang="EN-US"><font face="Courier">Windows</font></span><span style="font-family: 宋体;">操作系统支持</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">规范，很自然地，</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象存在于</span><span lang="EN-US"><font face="Courier">Windows</font></span><span style="font-family: 宋体;">操作系统的可执行文件中。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">Windows</font></span><span style="font-family: 宋体;">操作系统的可执行文件，其格式主要有两种：</span><span lang="EN-US"><font face="Courier">EXE</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">。这里就不必要说这两种文件格式的区别了吧。如果不知道，这篇文章你估计也看不懂了。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">能够生成</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的可执行程序叫</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器。</span><span lang="EN-US"><font face="Courier">EXE</font></span><span style="font-family: 宋体;">是进程外服务器，</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">是进程内服务器。这里只讨论</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">的情况。由于</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">本身只能通过对外输出的函数与外界交互，所以，</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">作为</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器也是通过四个输出函数来体现其服务器的作用。这就是著名的四个函数：</span></font></p><ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllRegisterServer</font></span><span style="font-family: 宋体;">；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllUnregisterSever</font></span><span style="font-family: 宋体;">；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllGetClassObject</font></span><span style="font-family: 宋体;">；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllCanUnloadNow</font></span><span style="font-family: 宋体;">；</span> </font></li></ul><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><o:wrapblock><v:shape id="_x0000_s1026" style="margin-top: 28.5pt; z-index: 1; margin-left: -36pt; width: 7in; position: absolute; height: 284.65pt;" type="#_x0000_t75" o:allowincell="f"><font size="2"><v:imagedata o:title="COM Server" src="file:///C:%5CDOCUME%7E1%5Choward%5CLOCALS%7E1%5CTemp%5Cmsohtml1%5C01%5Cclip_image005.png"></v:imagedata><w:wrap type="topAndBottom"></w:wrap></font></v:shape></o:wrapblock><br clear="all" /><font size="2"><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器的工作机制可以用下图来表示：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font face="Courier"><font size="2">&nbsp;</font><a href="http://writeblog.csdn.net/images/hellothere/Image/hellothere/COM%20Server.gif"><font size="2"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/hellothere/COM%20Server.gif" border="0" width="772" height="436" /></font></a></font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器的重要功能可以归纳为三个：</span></font></p><ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">管理服务器的生命周期；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">管理服务器和对象的注册；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">获得</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的类厂；</span> </font></li></ul><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">我们可以看到，作为</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器的</span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">，用四个函数来完成这三个方面的功能。四个输出函数的调用时机分别如下：</span></font></p><ul style="margin-top: 0cm;" type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllRegisterServer</font></span><span style="font-family: 宋体;">、</span><span lang="EN-US"><font face="Courier">DllUnregisterServer</font></span><span style="font-family: 宋体;">：使用</span><span lang="EN-US"><font face="Courier">regsvr32</font></span><span style="font-family: 宋体;">程序注册和反注册服务器时；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllCanUnloadNow</font></span><span style="font-family: 宋体;">：当调用</span><span lang="EN-US"><font face="Courier">CoFreeUnusedLibraries</font></span><span style="font-family: 宋体;">系统函数时；</span> </font></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">DllGetClassObject</font></span><span style="font-family: 宋体;">：从函数的字面意思来理解，应该是创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象时该函数被调用。而我们知道创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的</span><span lang="EN-US"><font face="Courier">API</font></span><span style="font-family: 宋体;">函数是</span><span lang="EN-US"><font face="Courier">CoCreateInstance</font></span><span style="font-family: 宋体;">。</span><span lang="EN-US"><font face="Courier">CoCreateInstance</font></span><span style="font-family: 宋体;">是个封装函数，它包装了对</span><span lang="EN-US"><font face="Courier">CoGetClassObject</font></span><span style="font-family: 宋体;">，以及相应类厂的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">函数的调用。</span><span lang="EN-US"><font face="Courier">CoGetClassObject</font></span><span style="font-family: 宋体;">通过注册表机制，找到相应的服务器，并且调用服务器的</span><span lang="EN-US"><font face="Courier">DllGetClassObject</font></span><span style="font-family: 宋体;">函数来获得类厂。一旦获得类厂对象，就可以调用类厂对象的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">方法来创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象了。</span> </font></li></ul><h2 style="margin: 12pt 0cm 3pt 28.8pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><em>5.2</em><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><em><span lang="EN-US">ATL COM</span><span style="font-family: 宋体;">服务器</span></em></font></h2><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">前面讲的是所有</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器都应该遵循的工作流程。不同的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">实现，实现这个流程的方式也不同。对于</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">来说，其具体的实现可以用下图简略体现：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span style="font-family: 宋体;"></span><font size="2">&nbsp;</font><a href="http://writeblog.csdn.net/images/hellothere/Image/hellothere/Class_diagram_Server.gif"><font size="2"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/hellothere/Class_diagram_Server.gif" border="0" width="619" height="129" /></font></a></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><v:shape id="_x0000_i1027" style="width: 6in; height: 90pt;" fillcolor="window" type="#_x0000_t75"><v:imagedata o:title="Class_diagram_Server" src="file:///C:%5CDOCUME%7E1%5Choward%5CLOCALS%7E1%5CTemp%5Cmsohtml1%5C01%5Cclip_image007.png"></v:imagedata></v:shape></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">服务器主要通过</span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">类和</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构来实施服务器管理。前面讲过，</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器的主要职能是三个：管理服务器生命周期、注册组件、获得</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的类厂，所以，</span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">的成员函数也围绕这三个方面。同样，</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">数据结构中的内容也紧紧围绕着这三个方面。由于本文讨论</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象创建，所以，对服务器管理的讨论也局限在&#8220;获得</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的类厂&#8221;上。</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">服务器实现&#8220;获得</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的类厂&#8221;的步骤如下：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; text-indent: -18pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><font face="Courier">1、</font><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> </span></span></span><span style="font-family: 宋体;">所有的</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">工程都会生成一个全局变量，其类型为</span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">，名字固定为</span><span lang="EN-US"><font face="Courier">_Module</font></span><span style="font-family: 宋体;">。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; text-indent: -18pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><font face="Courier">2、</font><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> </span></span></span><span lang="EN-US"><font face="Courier">DLL</font></span><span style="font-family: 宋体;">的四个输出函数内部都是调用</span><span lang="EN-US"><font face="Courier">_Module</font></span><span style="font-family: 宋体;">的成员函数来实现其功能。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; text-indent: -18pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><font face="Courier">3、</font><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> </span></span></span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">提供了一系列成员函数来管理</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">服务器，这些方法基本都工作在</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构数组上。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; text-indent: -18pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><font face="Courier">4、</font><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> </span></span></span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构内的成员基本上都是一些静态成员函数指针。最重要的函数指针是两个：</span><span lang="EN-US"><font face="Courier">pfnGetClassObject</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">pfnCreateInstance</font></span><span style="font-family: 宋体;">，它们都指向</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">的静态成员函数</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; text-indent: -18pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span><font face="Courier">5、</font><span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"> </span></span></span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构数组由三个宏配合定义：</span><span lang="EN-US"><font face="Courier">BEGIN_OBJ_MAP</font></span><span style="font-family: 宋体;">、</span><span lang="EN-US"><font face="Courier">OBJECT_ENTRY</font></span><span style="font-family: 宋体;">和</span><span lang="EN-US"><font face="Courier">END_OBJ_MAP</font></span><span style="font-family: 宋体;">。其中，</span><span lang="EN-US"><font face="Courier">OBJECT_ENTRY</font></span><span style="font-family: 宋体;">宏比较重要，有必要在下面列出其定义：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><o:p><font face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><font face="Courier">#define OBJECT_ENTRY(clsid, class) \<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><span></span><font face="Courier">{&amp;clsid, class::UpdateRegistry, \<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><span></span><font face="Courier"><strong><span style="background: yellow none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">class::_ClassFactoryCreatorClass::CreateInstance</span></strong>, \<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><span></span><font face="Courier"><strong><span style="background: yellow none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">class::_CreatorClass::CreateInstance</span></strong>, NULL, 0, \<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><span></span><font face="Courier">class::GetObjectDescription, class::GetCategoryMap, \<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><span></span><font face="Courier">class::ObjectMain },<o:p></o:p></font></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><span style="font-size: 10pt; line-height: 150%;" lang="EN-US"><o:p><font face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt 36pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">注意黄底色部分。该宏用</span><span lang="EN-US"><font face="Courier">class</font></span><span style="font-family: 宋体;">的数据成员</span><span lang="EN-US"><font face="Courier">_ClassFactoryCreatorClass</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">静态函数指针填充到</span><span lang="EN-US"><font face="Courier">pfnGetClassObject</font></span><span style="font-family: 宋体;">位置。用</span><span lang="EN-US"><font face="Courier">_CreatorClass</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">CreateInstance</font></span><span style="font-family: 宋体;">静态函数指针填充到</span><span lang="EN-US"><font face="Courier">pfnCreateInstance</font></span><span style="font-family: 宋体;">位置。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">要找到一个特定的类厂，</span><span lang="EN-US"><font face="Courier">DllGetClassObject </font></span><span style="font-family: 宋体;">将调用</span><span lang="EN-US"><font face="Courier">CComModule</font></span><span style="font-family: 宋体;">的成员函数</span><span lang="EN-US"><font face="Courier">GetClassObject</font></span><span style="font-family: 宋体;">。</span><span lang="EN-US"><font face="Courier">GetClassObject</font></span><span style="font-family: 宋体;">遍历结构数组，找到相应的</span><span lang="EN-US"><font face="Courier">CLSID</font></span><span style="font-family: 宋体;">对应的</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构。</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">会先检查结构中的</span><span lang="EN-US"><font face="Courier">pCF</font></span><span style="font-family: 宋体;">，这是</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">缓存的类厂对象指针，如果不为空，则可以直接利用该指针来创建</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象，如果为空，则调用结构中的</span><span lang="EN-US"><font face="Courier">pfnGetClassObject</font></span><span style="font-family: 宋体;">函数指针，创建相应的类厂对象并且把类厂对象的指针缓存到</span><span lang="EN-US"><font face="Courier">pCF</font></span><span style="font-family: 宋体;">成员数据中。</span></font></p><h1 style="margin: 12pt 0cm 3pt 21.6pt; line-height: 150%;"><font size="2"><span lang="EN-US"><span>6<span style="font-family: 'Times New Roman'; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span lang="EN-US">ATL COM</span><span style="font-family: 宋体;">对象创建&#8212;&#8212;内外结合</span></font></h1><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">本文中，先讲了</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象本身，接着讲了</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建的内部机制&#8212;&#8212;</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象的类厂如何创建</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象；再接着讲了</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建的外部机制&#8212;&#8212;</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">服务器如何创建</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象的类厂。有个这几方面的了解之后，我们再把相关的知识结合起来，看一看</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建的统一场景。图示如下：</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%; text-align: center;" align="center"><span lang="EN-US"><v:shape id="_x0000_i1028" style="width: 368.25pt; height: 414.75pt;" fillcolor="window" type="#_x0000_t75"><v:imagedata o:title="Class_diagram" src="file:///C:%5CDOCUME%7E1%5Choward%5CLOCALS%7E1%5CTemp%5Cmsohtml1%5C01%5Cclip_image009.png"></v:imagedata></v:shape></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;<img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/hellothere/Class_diagram.gif" border="0" width="619" height="698" /></font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">图中左上部分是</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象本身；右上部分是</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象的创建；中下部分是</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">服务器对</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象的管理。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">对每个部分的作用，本文各个部分已经有了具体描述，这里要强调的是图中标示为红色部分：</span><span lang="EN-US"><font face="Courier">_ATL_OBJMAP_ENTRY</font></span><span style="font-family: 宋体;">结构和</span><span lang="EN-US"><font face="Courier">CComCreator</font></span><span style="font-family: 宋体;">，正是通过它们，图中三个部分有机地联系到了一起，完成了</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建的任务。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><font size="2"><span style="font-family: 宋体;">通观本文，没有给什么&#8220;示范代码&#8221;，而是力求从本人理解的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">原理的角度探讨</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">的</span><span lang="EN-US"><font face="Courier">COM</font></span><span style="font-family: 宋体;">对象创建机制。有可能这样的讨论在理论真正精深者看来不值一哂，然而，本人希望那些觉得</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">不好理解的人有了这次</span><span lang="EN-US"><font face="Courier">ATL COM</font></span><span style="font-family: 宋体;">对象创建过程探索的经历，能够感觉</span><span lang="EN-US"><font face="Courier">ATL</font></span><span style="font-family: 宋体;">好把握一些了，不再是若干莫名其妙的模板类的组合了。</span></font></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><span lang="EN-US"><o:p><font size="2" face="Courier">&nbsp;</font></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;"><br /><span lang="EN-US"><o:p></o:p></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; line-height: 150%;">发信人:&nbsp;lostall&nbsp;(鸟人+衰人+猪),&nbsp;信区:&nbsp;COM_DCOM <br />标&nbsp;&nbsp;题:&nbsp;ATL接口映射宏详解--（1） <br />发信站:&nbsp;武汉白云黄鹤站&nbsp;(Fri&nbsp;Mar&nbsp;31&nbsp;05:35:56&nbsp;2000),&nbsp;站内信件 <br /> <br />以后将分别介绍ATL中各个形式为COM_INTERFACE_ENTRY_XX的接口映射宏。 <br />并将按照从易到难的顺序讲解，每一部分都将建立在前一部分的基础上。 <br />每一部分都将通过分析实际的调用函数堆栈来进行分析,堆栈的写法是从下向上。<br /> <br />文中所涉及的代码都为略写，只列出相关部分。 <br /> <br /> <br />一、COM_INTERFACE_ENTRY(x) <br />首先我们从一个最典型的应用开始： <br />定义一个最简单的ATL&nbsp;DLL： <br />class&nbsp;ATL_NO_VTABLE&nbsp;CMyObject&nbsp;: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CComObjectRootEx, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CComCoClass, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IDispatchImpl <br />{ <br />..... <br />BEGIN_COM_MAP(CMyObject) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COM_INTERFACE_ENTRY(IMyObject)&nbsp;//一个双接口 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COM_INTERFACE_ENTRY(IDispatch) <br />END_COM_MAP() <br />..... <br />}; <br /> <br />编写一段最简单的查询接口代码： <br />IUnknown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pUnk; <br />IMyObject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pMyObject; <br />CoCreateInstance(CLSID_MyObject,&nbsp;NULL,&nbsp;CLSCTX_INPROC_SERVER, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IID_IUnknown,&nbsp;(void&nbsp;**)&amp;pUnk); <br />pUnk-&gt;QueryInterface(IID_IMyObject,&nbsp;(void&nbsp;**)&amp;pMyObject); <br /> <br />执行客户代码，首先我们看看组件对象是如何被创建的。 <br />函数调用堆栈一： <br />4........... <br />3.ATL::CComCreator&nbsp;&gt;::CreateInstance(...) <br />2.ATL::CComCreator2&nbsp;&gt;, <br />&nbsp;&nbsp;&nbsp;&nbsp;ATL::CComCreator&nbsp;&gt;&nbsp;&gt;::CreateInstance(...) <br />1.ATL::CComClassFactory::CreateInstance(...) <br />4.ATL::AtlModuleGetClassObject(...) <br />9.ATL::AtlInternalQueryInterface(...) <br />8.ATL::CComObjectRootBase::InternalQueryInterface(...) <br />7.ATL::CComClassFactory::_InternalQueryInterface(...) <br />6.ATL::CComObjectCached::QueryInterface(...) <br />5.ATL::CComCreator&nbsp;&gt;:: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateInstance(...) <br />4.ATL::AtlModuleGetClassObject(...) <br />3.ATL::CComModule::GetClassObject(...) <br />2.DllGetClassObject(...) <br />1.CoCreateInstance(...)(客户端) <br /> <br /> <br />解释如下： <br />1:CoCreateInstance(CLSID_MyObject,&nbsp;NULL,&nbsp;CLSCTX_INPROC_SERVER, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IID_IUnknown,&nbsp;(void&nbsp;**)&amp;pUnk); <br />&nbsp;&nbsp;其内部将调用OLE&nbsp;API函数CoGetClassObject(),&nbsp;而CoGetClassObject则会通过<br /> <br />&nbsp;&nbsp;LoadLibrary(...)装入DLL，并调用DLL中的DllGetClassObject()函数。 <br />2:STDAPI&nbsp;DllGetClassObject(REFCLSID&nbsp;rclsid,&nbsp;REFIID&nbsp;riid,&nbsp;LPVOID*&nbsp;ppv) <br /><br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;_Module.GetClassObject(rclsid,&nbsp;riid,&nbsp;ppv); <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;其中值得注意的是_Module变量，在DLL中定义了全局变量： <br />&nbsp;&nbsp;CComModule&nbsp;_Module; <br />&nbsp;&nbsp;ATL通过一组宏： <br />&nbsp;&nbsp;BEGIN_OBJECT_MAP(ObjectMap) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OBJECT_ENTRY(CLSID_MyObject,&nbsp;CMyObject) <br />&nbsp;&nbsp;END_OBJECT_MAP() <br />&nbsp;&nbsp;#define&nbsp;BEGIN_OBJECT_MAP(x)&nbsp;static&nbsp;_ATL_OBJMAP_ENTRY&nbsp;x[]&nbsp;=&nbsp;{ <br />&nbsp;&nbsp;#define&nbsp;END_OBJECT_MAP()&nbsp;&nbsp;&nbsp;{NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL<br />,&nbsp;NULL}}; <br />&nbsp;&nbsp;#define&nbsp;OBJECT_ENTRY(clsid,&nbsp;class)&nbsp;{&amp;clsid,&nbsp;class::UpdateRegistry, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class::_ClassFactoryCreatorClass::CreateInstance,&nbsp;//关键 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class::_CreatorClass::CreateInstance, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;0,&nbsp;class::GetObjectDescription, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class::GetCategoryMap,&nbsp;class::ObjectMain&nbsp;}, <br />&nbsp;&nbsp;生成一个静态全局_ATL_OBJMAP_ENTRY型数组：ObjectMap[]; <br />&nbsp;&nbsp;然后ATL又在 <br />&nbsp;&nbsp;BOOL&nbsp;WINAPI&nbsp;DllMain(HINSTANCE&nbsp;hInstance,&nbsp;DWORD&nbsp;dwReason,&nbsp;LPVOID&nbsp;/*lp<br />Reserved*/) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..... <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_Module.Init(ObjectMap,&nbsp;hInstance,&nbsp;&amp;LIBID_TEST2Lib); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..... <br />&nbsp;&nbsp;}初始化_Module&nbsp;//注意在有的情况下是在InitInstance（）中初始化_Module<br /> <br />&nbsp;&nbsp;那么_Module初始化都做了些什么呢，其实他什么也没做，在CComModule::Ini<br />t中，它 <br />&nbsp;&nbsp;调用AtlModuleInit(_ATL_MODULE*&nbsp;pM,&nbsp;_ATL_OBJMAP_ENTRY*&nbsp;p,&nbsp;HINSTANCE&nbsp;h<br />)，在其 <br />&nbsp;&nbsp;中关键的只有一句：pM-&gt;m_pObjMap&nbsp;=&nbsp;p;可见_Module仅仅是把这个全局对象映<br />射数组 <br />&nbsp;&nbsp;ObjectMap[]给存了起来。那么为什么可以通过_Module.GetClassObject得到类<br />厂呢？ <br />&nbsp;&nbsp;其实关键在于我们的组件CMyObject继承的又一个基类CComCoClass! <br />&nbsp;&nbsp;在CComCoClass中缺省定义了一个宏DECLARE_CLASSFACTORY()而 <br />&nbsp;&nbsp;#define&nbsp;DECLARE_CLASSFACTORY()&nbsp;DECLARE_CLASSFACTORY_EX(CComClassFact<br />ory) <br />&nbsp;&nbsp;#define&nbsp;DECLARE_CLASSFACTORY_EX(cf) <br />&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;CComCreator&lt; CComObjectCached&lt; cf &gt;&nbsp;&gt;&nbsp;_ClassFactoryCreator<br />Class; <br />&nbsp;&nbsp;CComCreator,CComObjectCached我们暂且不管，但一看到CComClassFactory，<br />顾名思 <br />&nbsp;&nbsp;义，我们就知道我们要的类厂终于出现了！每个组件内部原来都有一个类厂对<br />象。 <br />&nbsp;&nbsp;绕了一大圈，我们现在已经知道了_Module中包含了我们所要的每个组件的类厂<br />对象， <br />&nbsp;&nbsp;这对目前来说已经足够了，现在继续路由下去！ <br />3:HRESULT&nbsp;CComModule::GetClassObject(REFCLSID&nbsp;rclsid,REFIID&nbsp;riid,LPVOI<br />D*&nbsp;ppv) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AtlModuleGetClassObject(this,&nbsp;rclsid,&nbsp;riid,&nbsp;ppv); <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;CComModule::GetClassObject的实现非常简单，仅仅是调用ATL的API函数。 <br />4:ATLINLINE&nbsp;ATLAPI&nbsp;AtlModuleGetClassObject(_ATL_MODULE*&nbsp;pM,&nbsp;REFCLSID&nbsp;r<br />clsid, <br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REFIID&nbsp;riid,&nbsp;LPVOID*&nbsp;ppv) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_OBJMAP_ENTRY*&nbsp;pEntry&nbsp;=&nbsp;pM-&gt;m_pObjMap;//从_Module中取出对象映<br />射数组 <br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(pEntry-&gt;pclsid&nbsp;!=&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((pEntry-&gt;pfnGetClassObject&nbsp;!=&nbsp;NULL)&nbsp;&amp;&amp;&nbsp;InlineIsEqualGUID(r<br />clsid, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pEntry-&gt;pclsid)) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pEntry-&gt;pCF&nbsp;==&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pEntry-&gt;pCF&nbsp;==&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hRes&nbsp;=&nbsp;pEntry-&gt;pfnGetClassObject(pEntry-&gt;pfnCreateInst<br />ance, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IID_IUnknown,&nbsp;(LPVOID*)&amp;pEntry-&gt;pC<br />F); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pEntry-&gt;pCF&nbsp;!=&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hRes&nbsp;=&nbsp;pEntry-&gt;pCF-&gt;QueryInterface(riid,&nbsp;ppv); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pEntry&nbsp;=&nbsp;_NextObjectMapEntry(pM,&nbsp;pEntry); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;现在好象已经有点看不懂了，看来我们得看看_ATL_OBJMAP_ENTRY的结构了 <br />&nbsp;&nbsp;struct&nbsp;_ATL_OBJMAP_ENTRY <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;CLSID*&nbsp;pclsid; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HRESULT&nbsp;(WINAPI&nbsp;*pfnUpdateRegistry)(BOOL&nbsp;bRegister); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_CREATORFUNC*&nbsp;pfnGetClassObject; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_CREATORFUNC*&nbsp;pfnCreateInstance; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IUnknown*&nbsp;pCF; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwRegister; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_DESCRIPTIONFUNC*&nbsp;pfnGetObjectDescription; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_CATMAPFUNC*&nbsp;pfnGetCategoryMap; <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;pclsid很清楚就代表着我们组件的CLSID；pfnGetClassObject我们也已经知道<br />了它就 <br />&nbsp;&nbsp;是CMyObject::_ClassFactoryCreatorClass::CreateInstance(我们组件所包含<br />的类 <br />&nbsp;&nbsp;厂对象的CreateInstance函数)；pCF我们也可以猜出它是指向这个类厂的IUnk<br />nown指 <br />&nbsp;&nbsp;针，代表这个类厂对象是否被创建过，若类厂对象已经存在，就不用再创建新<br />的类厂 <br />&nbsp;&nbsp;对象了。现在就剩下pfnCreateInstance我们还不明白怎么回事。其实答案还是<br />在 <br />&nbsp;&nbsp;CComCoClass中！ <br />&nbsp;&nbsp;在CComCoClass中缺省定义了宏DECLARE_AGGREGATABLE(x),这个宏表示这个组件<br />既可以 <br />&nbsp;&nbsp;是聚集的也可以是非聚集的，关于聚集的概念我们暂且不理，先看它的定义：<br /> <br />&nbsp;&nbsp;#define&nbsp;DECLARE_AGGREGATABLE(x)&nbsp;public:\ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;CComCreator2&lt; CComCreator&lt; CComObject&lt; x &gt;&nbsp;&gt;,&nbsp;\ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CComCreator&lt; CComAggObject&lt; x &gt;&nbsp;&gt;&nbsp;&gt;&nbsp;_CreatorClass; <br />&nbsp;&nbsp;我们看到了一个熟悉的字符串_CreatorClass,&nbsp;原来这还有一个组件包含的对象<br />。但还 <br />&nbsp;&nbsp;有一个问题我们没有搞清楚，就是为什么_ClassFactoryCreator和_CreatorCl<br />ass后面 <br />&nbsp;&nbsp;都要跟着一个CreateInstance?&nbsp;看来我们必须先来看看CComCreator是个什么东<br />西了。 <br />&nbsp;&nbsp;template&nbsp; <br />&nbsp;&nbsp;class&nbsp;CComCreator <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;public: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;HRESULT&nbsp;WINAPI&nbsp;CreateInstance(void*&nbsp;pv,&nbsp;REFIID&nbsp;riid,&nbsp;LP<br />VOID*&nbsp;ppv) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{..... <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;}; <br />&nbsp;&nbsp;原来它里面只有一个CreateInstance函数，我们现在终于大体明白_ClassFact<br />oryCre <br />&nbsp;&nbsp;atorClass::CreateInstance表示什么意思了，它就代表CComClassFactory::C<br />reateIn <br />&nbsp;&nbsp;stance(..)吧，差不多就是这样了。那我们再来看看CComCreator2有什么不同<br />： <br />&nbsp;&nbsp;template&nbsp; <br />&nbsp;&nbsp;class&nbsp;CComCreator2 <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;public: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;HRESULT&nbsp;WINAPI&nbsp;CreateInstance(void*&nbsp;pv,&nbsp;REFIID&nbsp;riid,&nbsp;LP<br />VOID*&nbsp;ppv) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(pv&nbsp;==&nbsp;NULL)&nbsp;? <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T1::CreateInstance(NULL,&nbsp;riid,&nbsp;ppv)&nbsp;: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T2::CreateInstance(pv,&nbsp;riid,&nbsp;ppv); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;}; <br />&nbsp;&nbsp;这个类与CComCreator很类似,都只有一个CreateInstance成员函数，从_Creat<br />orClass <br />&nbsp;&nbsp;中我们可以知道它实际上包含两个类CComObject,CComAggObject的CreateInst<br />ance函 <br />&nbsp;&nbsp;数(通过CComCreator),其中CComObject用于非聚集对象，CComAggObject用于聚<br />集对象 <br />&nbsp;&nbsp;根据情况它建立相应的对象。(ATL中实际生成的组件对象不是CMyObject,而是<br /> <br />&nbsp;&nbsp;CComObject,CComAggObject或CComPolyObject对象,这个概念很重要,但现在暂<br />且不谈) <br />&nbsp;&nbsp;现在我们对AtlModuleGetClassObject(...)基本已经知道是怎么回事了，它就<br />是根据 <br />&nbsp;&nbsp;存在对象映射数组中的创建类厂的函数的地址来创建类厂。pfnGetClassObjec<br />t以及 <br />&nbsp;&nbsp;pfnCreateInstance我们基本上都已经知道是怎么回事了，但还有一个问题为什<br />么要 <br />&nbsp;&nbsp;把pEntry-&gt;pfnCreateInstance作为pEntry-&gt;pfnGetClassObject(...)中的一个<br />参数 <br />&nbsp;&nbsp;传递？答案在下面呢，让我们继续路由下去！ <br />5:CComCreator::CreateInstance(void*&nbsp;pv,&nbsp;REFIID&nbsp;riid,&nbsp;LPVOID*&nbsp;ppv) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T1*&nbsp;p&nbsp;=&nbsp;NULL; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ATLTRY(p&nbsp;=&nbsp;new&nbsp;T1(pv))//创建类厂对象 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;!=&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;SetVoid(pv); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;InternalFinalConstructAddRef(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hRes&nbsp;=&nbsp;p-&gt;FinalConstruct(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;InternalFinalConstructRelease(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hRes&nbsp;==&nbsp;S_OK) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hRes&nbsp;=&nbsp;p-&gt;QueryInterface(riid,&nbsp;ppv); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hRes&nbsp;!=&nbsp;S_OK) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;p; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;注意这里的T1是CComObjectCached,这是我们给CComCreator <br />&nbsp;&nbsp;的模板参数。我们又一次看到了我们熟悉的操作符'new'!直到现在我们终于创<br />建了组 <br />&nbsp;&nbsp;件的类厂。但还没完，继续往下走，看看SetVoid(pv)里干了些什么？ <br />&nbsp;&nbsp;void&nbsp;CComClassFactory::SetVoid(void*&nbsp;pv) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_pfnCreateInstance&nbsp;=&nbsp;(_ATL_CREATORFUNC*)pv; <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;大家还记得我们曾经把CMyObject::_CreatorClass::CreateInstance作为参数<br />传给 <br />&nbsp;&nbsp;pEntry-&gt;pfnGetClassObject(...)吧，当时我们不明白是怎么回事，现在已经<br />豁然开 <br />&nbsp;&nbsp;朗！原来是类厂需要它来创建组件对象！虽然我们只是从字面意思猜出这一点<br />，但实 <br />&nbsp;&nbsp;际上也正如我们所预料的那样，在CComClassFactory::CreateInstance(...)中<br />，我们 <br />&nbsp;&nbsp;看到了m_pfnCreateInstance(pUnkOuter,&nbsp;riid,&nbsp;ppvObj);现在一切都已经明白<br />了， <br />&nbsp;&nbsp;ATL为我们创建类厂而作的层层包装我们都已经打开，剩下的创建组件的过程已<br />经是 <br />&nbsp;&nbsp;我们很熟悉的过程了！ <br />&nbsp;&nbsp;但是现在还没有完，我们还需要为类厂对象查询一个IUnknown指针，这个指针<br />就存在 <br />&nbsp;&nbsp;我们在前面所看到的pEntry-&gt;pCF中。 <br />6:STDMETHOD(QueryInterface)(REFIID&nbsp;iid,&nbsp;void&nbsp;**&nbsp;ppvObject) <br />&nbsp;&nbsp;{return&nbsp;_InternalQueryInterface(iid,&nbsp;ppvObject);} <br />&nbsp;&nbsp;现在调用的是CComObjectCached::QueryInterface,至于这个类有何特别之处,<br />我们现 <br />&nbsp;&nbsp;在好象还不需要知道，我也很累的说，呵呵。 <br />7:HRESULT&nbsp;_InternalQueryInterface(REFIID&nbsp;iid,&nbsp;void**&nbsp;ppvObject)&nbsp;\ <br />&nbsp;&nbsp;{&nbsp;return&nbsp;InternalQueryInterface(this,&nbsp;_GetEntries(),&nbsp;iid,&nbsp;ppvObject)<br />;&nbsp;} <br />&nbsp;&nbsp;所有的类的_InternalQueryInterface(...)都是在BEGIN_COM_MAP中定义的。 <br /><br />&nbsp;&nbsp;CComObjectCached没有BEGIN_COM_MAP宏，所以现在调用的是CComClassFactor<br />y的。 <br />&nbsp;&nbsp;注意把this指针和接口映射数组_GetEntries()传给了InternalQueryInterfac<br />e(), <br />&nbsp;&nbsp;这是InternalQueryInterface(...)实现查询的依据。 <br />&nbsp;&nbsp;在BEGIN_COM_MAP(x)中定义了以下一个静态的接口映射数组： <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_INTMAP_ENTRY&nbsp;_entries[]； <br />&nbsp;&nbsp;每一个接口映射宏实际上都是向这个数组中增加了一项。一个接口映射宏包括<br />三个部 <br />&nbsp;&nbsp;分：接口的IID号、偏移值（大部分时候下）、需要执行的函数，对一般接口来<br />说不用 <br />&nbsp;&nbsp;执行其他函数。_GetEntries()就是返回这个数组。还有一些细节问题以后再说<br />。 <br />8:static&nbsp;HRESULT&nbsp;WINAPI&nbsp;InternalQueryInterface(void*&nbsp;pThis, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;_ATL_INTMAP_ENTRY*&nbsp;pEntries,&nbsp;REFIID&nbsp;iid,&nbsp;void**&nbsp;ppvObjec<br />t) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;... <br />&nbsp;&nbsp;&nbsp;HRESULT&nbsp;hRes&nbsp;=&nbsp;AtlInternalQueryInterface(pThis,&nbsp;pEntries,&nbsp;iid,&nbsp;ppvO<br />bject); <br />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp; <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;现在调用的是CComObjectRootBase::InternalQueryInterface(...) <br />9:现在我们终于到了QueryInterface的鼻祖了。AtlInternalQueryInterface(..<br />.)是整 <br />&nbsp;&nbsp;个查询过程的终点，它遍历接口映射表，并根据每一项做出相应的动作。ATL中<br />的消 <br />&nbsp;&nbsp;息映射宏有很多种，相应的动作也很多，但现在我们不管那些，现在我们要做<br />的就是 <br />&nbsp;&nbsp;查到一个IUnknown接口，这很容易，我们甚至不需要遍历接口映射表。 <br />&nbsp;&nbsp;ATLINLINE&nbsp;ATLAPI&nbsp;AtlInternalQueryInterface(void*&nbsp;pThis, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;_ATL_INTMAP_ENTRY*&nbsp;pEntries,&nbsp;REFIID&nbsp;iid,&nbsp;void**&nbsp;ppvObjec<br />t) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ATLASSERT(pEntries-&gt;pFunc&nbsp;==&nbsp;_ATL_SIMPLEMAPENTRY); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ppvObject&nbsp;==&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;E_POINTER; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ppvObject&nbsp;=&nbsp;NULL; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(InlineIsEqualUnknown(iid))&nbsp;//&nbsp;use&nbsp;first&nbsp;interface <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IUnknown*&nbsp;pUnk&nbsp;=&nbsp;(IUnknown*)((int)pThis+pEntries-&gt;dw);<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pUnk-&gt;AddRef(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ppvObject&nbsp;=&nbsp;pUnk; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;S_OK; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...//还有一大堆呢，但现在用不上，就节省点空间吧 <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;这里有一个规定，接口映射表的第一个接口必须是_ATL_SIMPLEENTRY型的。至<br />于为什 <br />&nbsp;&nbsp;么有这个要求，以及pThis+pEntries-&gt;dw是什么意思，我们以后再说吧，那也<br />是一堆 <br />&nbsp;&nbsp;问题。总之，我们现在如愿以偿轻松的获得了我们所需要的类厂对象以及IUnk<br />nown指 <br />&nbsp;&nbsp;针。 <br />4:我差一点以为我们可以胜得返回到第一步了，但在ATL::AtlModuleGetClassOb<br />ject <br />&nbsp;&nbsp;处却又停了下来，看看它的源码，原来还要再通过我们刚获得的IUnknown指针<br />查询 <br />&nbsp;&nbsp;IClassFactory指针。又是一通相同的调用，从第6步到第9步一模一样，我们将<br />进行 <br />&nbsp;&nbsp;相同的调用。但注意在第9步中，我们这回查的不再是IUnknown指针了，所以我<br />们需要 <br />&nbsp;&nbsp;看看我刚才还没列出的代码，但这留到下一次函数堆栈再看吧 <br />1:终于终于我们已经完成了创建类厂对象的全部操作，现在我们要做的就是我们<br />熟悉的 <br />&nbsp;&nbsp;调用类厂对象的CreateInstance(...)函数创建组件的过程了。正如我们所见到<br />的，现 <br />&nbsp;&nbsp;在OLE开始调用CComClassFactory::CreateInstance()了，我们还没忘记，在类<br />厂对象 <br />&nbsp;&nbsp;中保留了创建组件用的CreateInstance()函数,&nbsp;这个过程已经很明朗了。 <br />2.不用再重复了吧，看第4步。 <br />3.不用再重复了吧，看第4步。 <br />4.如果继续路由下去的话，我们的堆栈还可以很长，但这只是重复的枯躁的劳动<br />。我就 <br />&nbsp;&nbsp;不继续走下去了，我也很累的说，唉。 <br /> <br />函数调用堆栈二： <br />0:............ <br />5.ATL::AtlInternalQueryInterface(...) <br />4.ATL::CComObjectRootBase::InternalQueryInterface(...) <br />3.CMyObject::_InternalQueryInterface(...) <br />2.ATL::CComObject::QueryInterface(...) <br />1.pUnk-&gt;QueryInterface(IID_IMyObject,&nbsp;(void&nbsp;**)&amp;pMyObject);（客户端） <br /><br /> <br />解释如下： <br />1.我们通过刚刚获得的组件对象的IUnknown接口指针来查询IMyObject指针，这才<br />是我们 <br />&nbsp;&nbsp;真正需要的指针。 <br />2.还记得我们说过ATL真正创建的组件并不是CMyObject,而是CComObject,CComAg<br />gObject <br />&nbsp;&nbsp;或CComPolyObject,这里我们创建的是CComObject.所以理所当然我们要调用 <br />&nbsp;&nbsp;CComObject::QueryInterface(...),而确实CComObject也实现了这个函数。 <br />&nbsp;&nbsp;STDMETHOD(QueryInterface)(REFIID&nbsp;iid,&nbsp;void&nbsp;**&nbsp;ppvObject) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{return&nbsp;_InternalQueryInterface(iid,&nbsp;ppvObject);} <br />&nbsp;&nbsp;它只是简单地调用_InternalQueryInterface(...),我们也说过，只有类里面申<br />明了 <br />&nbsp;&nbsp;BEGIN_COM_MAP宏才会有_InternalQueryInterface(...),所以现在执行转到了<br />它的父 <br />&nbsp;&nbsp;类CMyObject中去，所以将调用CMyObject::_InterfaceQueryInterface(...) <br /><br />3.以后的调用我们已经很熟悉了，还用我再说一遍吗，呵呵 <br />4.这个调用我们也很熟悉了，不用多说了吧 <br />5.现在我们将要查询的是一个非IUnknown接口，所以我们来看看我们以前没列出<br />的代码 <br /> <br />&nbsp;&nbsp;ATLINLINE&nbsp;ATLAPI&nbsp;AtlInternalQueryInterface(void*&nbsp;pThis, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;_ATL_INTMAP_ENTRY*&nbsp;pEntries,&nbsp;REFIID&nbsp;iid,&nbsp;void**&nbsp;ppvObjec<br />t) <br />&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;//确保接口映射的第一项是个简单接口 <br />&nbsp;&nbsp;&nbsp;&nbsp;//若是查询IUnknown接口，执行相应的操作 <br />&nbsp;&nbsp;&nbsp;&nbsp;//以下将遍历接口映射表，试图找到相应的接口 <br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(pEntries-&gt;pFunc&nbsp;!=&nbsp;NULL) <br />&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOL&nbsp;bBlind&nbsp;=&nbsp;(pEntries-&gt;piid&nbsp;==&nbsp;NULL); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bBlind&nbsp;||&nbsp;InlineIsEqualGUID(*(pEntries-&gt;piid),&nbsp;iid)) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//_ATL_SIMPLEMAPENTRY就表明是个简单接口 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pEntries-&gt;pFunc&nbsp;==&nbsp;_ATL_SIMPLEMAPENTRY)&nbsp;//offset <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ATLASSERT(!bBlind); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IUnknown*&nbsp;pUnk&nbsp;=&nbsp;(IUnknown*)((int)pThis+pEntries-&gt;dw);<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pUnk-&gt;AddRef(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ppvObject&nbsp;=&nbsp;pUnk; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;S_OK; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//如果不是一个简单接口，则需要执行相应的函数 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HRESULT&nbsp;hRes=pEntries-&gt;pFunc(pThis,iid,ppvObject,pEntrie<br />s-&gt;dw); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hRes&nbsp;==&nbsp;S_OK&nbsp;||&nbsp;(!bBlind&nbsp;&amp;&amp;&nbsp;FAILED(hRes))) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;hRes; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pEntries++; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;E_NOINTERFACE; <br />&nbsp;&nbsp;} <br />&nbsp;&nbsp;函数的逻辑很清楚，只有两点可能不太理解，一个是 <br />&nbsp;&nbsp;(IUnknown*)((int)pThis+pEntries-&gt;dw)是什么意思，另一个是pEntries-&gt;pF<br />unc到底 <br />&nbsp;&nbsp;要干些什么事。前一个问题将在讲述COM_INTERFACE_ENTRY2中讲述，后一个问<br />题将在 <br />&nbsp;&nbsp;以后讲述不同类型的接口时分别解释。饭总是要一口一口吃的嘛，呵呵。 <br />&nbsp;&nbsp;现在我们只需关心一下我们的IMyObject是怎么被查找的。看一下它的宏 <br />&nbsp;&nbsp;我们把COM_INTERFACE_ENTRY(IMyObject)解开以后形式为： <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&amp;_ATL_IIDOF(IMyObject),&nbsp;\\得到IMyObject的IID值 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetofclass(IMyObject,&nbsp;CMyObject),&nbsp;\\定义偏移量 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ATL_SIMPLEMAPENTRY},\\表明是个简单接口 <br />&nbsp;&nbsp;同样对于offsetofclass(IMyObject,&nbsp;CMyObject)我们也将留到下一次再讲。 <br /><br />&nbsp;&nbsp;根据这个结构，我们很容易就能获得IMyObject接口指针。 <br />0:OK，it&nbsp;is&nbsp;over.依次退栈返回。 <br />&nbsp;&nbsp;其实这次查询发生的过程在刚才的调用序列中也发生了，当查询IClassFactor<br />y接口时就 <br />&nbsp;&nbsp;有类似的过程，但还是把它单独提了出来，只为了看看典型的情形，呵呵。 <br /> <br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------未完待续---------------- <br />今天第一次写，没想到这么累，花了这么多时间，唉，看来还得熬两次夜了 <br /> <br />-- <br />才疏学浅，胡言乱语；不对之处，敬请指正。 <br /> <br /> <br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路漫漫兮，其修远。 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吾将上下而求索。 <br /> <br />&#8251;&nbsp;修改:．lostall&nbsp;于&nbsp;Mar&nbsp;31&nbsp;06:03:02&nbsp;修改本文．[FROM:&nbsp;202.114.1.166] <br />&#8251;&nbsp;来源:．武汉白云黄鹤站&nbsp;bbs.whnet.edu.cn．[FROM:&nbsp;202.114.1.166] <br /><br />--<br />...我是在黑夜里展翅飞翔的恐怖... </p>