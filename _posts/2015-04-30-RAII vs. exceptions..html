<p>析构函数不能抛出异常，</p>
<p>原因</p>
<p><strong>析构函数已经变成了异常处理的一部分</strong></p>
<p><strong>如果对象出了异常，现在异常处理模块为了维护系统对象数据的一致性，避免资源泄漏，有责任释放这个对象的资源，调用对象的析构函数，可现在假如析构过程又再出现异常，那么请问由谁来保证这个对象的资源释放呢?而且这新出现的异常又由谁来处理呢?</strong></p>
<p>咋办呢？</p>
<p>&nbsp;</p>
<p><strong>3.2 那么当无法保证在析构函数中不发生异常时， 该怎么办?</strong></p>
<p>其实还是有很好办法来解决的。那就是<strong>把异常完全封装在析构函数内部，决不让异常抛出函数之外。</strong>这是一种非常简单，也非常有效的方法。 &nbsp;</p>
<p>~ClassName()</p>
<p>{</p>
<p>&nbsp; try{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_something();</p>
<p>&nbsp; }</p>
<p>&nbsp; catch(){&nbsp; //这里可以什么都不做，只是<strong>保证catch块的程序抛出的异常不会被扔出析构函数之外</strong>。</p>
<p>&nbsp;&nbsp; }</p>
<p>}</p>
<p>http://stackoverflow.com/questions/159240/raii-vs-exceptions</p>
<p>&nbsp;</p>
<p>构造函数没有返回值，所以应该用异常来报告发生的问题。构造函数抛出异常就意味着该构造函数没有执行完，所以其对应的析构函数不会被自动调用，因此构造函数应该先析构所有已初始化的基对象、成员对象，再抛出异常。（？？？）</p>
<p>析构函数被期望不向函数外抛出异常。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在该析构函数内部捕获、处理了该异常，不能让异常被抛出析构函数之外。</p>