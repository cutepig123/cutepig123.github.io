
《编程之美》上的一道题目的讨论
Posted on 2008-04-15 0023 ZelluX 阅读(2420) 评论(8)  编辑  收藏 所属分类 Algorithm

计算机科学论坛最近举办了一个阅读样章，提交书评的活动，具体内容请见httpwww.ieee.org.cndispbbs.aspboardID=42&ID=61162。

这里我想针对样章上的一个问题谈谈自己的理解。

问题很简单，求二进制中1的个数。对于一个字节（8bit）的变量，求其二进制表示中1的个数，要求算法的执行效率尽可能的高。

先来看看样章上给出的几个算法：

解法一，每次除二，看是否为奇数，是的话就累计加一，最后这个结果就是二进制表示中1的个数。

解法二，同样用到一个循环，只是里面的操作用位移操作简化了。

   1  int Count(int v)  
   2  {  
   3      int num = 0;
   4      while (v) {  
   5          num += v & 0x01;  
   6          v = 1;  
   7      }  
   8      return num;  
   9  }

解法三，用到一个巧妙的与操作，v & (v -1 )每次能消去二进制表示中最后一位1，利用这个技巧可以减少一定的循环次数。

解法四，查表法，因为只有数据8bit，直接建一张表，包含各个数中1的个数，然后查表就行。复杂度O(1)。

   1  int countTable[256] = { 0, 1, 1, 2, 1, ..., 7, 7, 8 };  
   2     
   3  int Count(int v) {  
   4      return countTable[v];  
   5  }
  
好了，这就是样章上给出的四种方案，下面谈谈我的看法。

首先是对算法的衡量上，复杂度真的是唯一的标准吗？尤其对于这种数据规模给定，而且很小的情况下，复杂度其实是个比较次要的因素。

查表法的复杂度为O(1)，我用解法一，循环八次固定，复杂度也是O(1)。至于数据规模变大，变成32位整型，那查表法自然也不合适了。

其次，我觉得既然是这样一个很小的操作，衡量的尺度也必然要小，CPU时钟周期可以作为一个参考。

解法一里有若干次整数加法，若干次整数除法（一般的编译器都能把它优化成位移），还有几个循环分支判断，几个奇偶性判断（这个比较耗时间，根据CSAPP上的数据，一般一个branch penalty得耗掉14个左右的cycle），加起来大概几十个cycle吧。

再看解法四，查表法看似一次地址计算就能解决，但实际上这里用到一个访存操作，而且第一次访存的时候很有可能那个数组不在cache里，这样一个cache miss导致的后果可能就是耗去几十甚至上百个cycle（因为要访问内存）。所以对于这种“小操作”，这个算法的性能其实是很差的。

这里我再推荐几个解决这个问题的算法，以32位无符号整型为例。

   1  int Count(unsigned x) {  
   2     x = x - ((x  1) & 0x55555555);   
   3     x = (x & 0x33333333) + ((x  2) & 0x33333333);   
   4     x = (x + (x  4)) & 0x0F0F0F0F;   
   5     x = x + (x  8);   
   6     x = x + (x  16);   
   7     return x & 0x0000003F;   
   8  }
  
这里用的是二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。

还有一个更巧妙的HAKMEM算法

   1  int Count(unsigned x) {
   2     unsigned n;   
   3     
   4     n = (x  1) & 033333333333;   
   5     x = x - n;  
   6     n = (n  1) & 033333333333;  
   7     x = x - n;   
   8     x = (x + (x  3)) & 030707070707;  
   9     x = modu(x, 63); 
   10     return x;  
   11  }
  
首先是将二进制各位三个一组，求出每组中1的个数，然后相邻两组归并，得到六个一组的1的个数，最后很巧妙的用除63取余得到了结果。

因为2^6 = 64，也就是说 x_0 + x_1  64 + x_2  64  64 = x_0 + x_1 + x_2 (mod 63)，这里的等号表示同余。

这个程序只需要十条左右指令，而且不访存，速度很快。

由此可见，衡量一个算法实际效果不单要看复杂度，还要结合其他情况具体分析。

关于后面的两道扩展问题，问题一是问32位整型如何处理，这个上面已经讲了。

问题二是给定两个整数A和B，问A和B有多少位是不同的。

这个问题其实就是数1问题多了一个步骤，只要先算出A和B的异或结果，然后求这个值中1的个数就行了。

总体看来这本书还是很不错的，比较喜欢里面针对一个问题提出不同算法并不断改进的风格。这里提出一点个人的理解，望大家指正 ;-)

(by ZelluX   httpwww.blogjava.netzellux)