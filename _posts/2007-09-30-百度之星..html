<p><font face="Verdana">http://gcdn.grapecity.com/cs/forums/permalink/4418/4418/ShowThread.aspx<br />
<span style="color: red">2007百度之星初赛第一场试题 </span></font></p>
<p><font face="Verdana">http://topic.csdn.net/t/20061107/11/5138789.html#<br />
set_intersection&nbsp;&nbsp; <br />
&nbsp; set_difference&nbsp;&nbsp; <br />
&nbsp; set_union&nbsp;&nbsp; <br />
&nbsp; set_symmetric_difference&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp; 详查MSDN或相关函数手册。<br />
&nbsp; set***算法对所有已排序序列区间都可适用，包括vector/list/deque。</font></p>
<p><font face="Verdana"></font>&nbsp;</p>
<p><font face="Verdana">一、.水果开会时段</font></p>
<p><font face="Verdana">每个百度工程师团队都有一笔还算丰裕的食品经费，足够每天购置多种水果。水果往往下午送达公司前台。前台的姐姐们只要看到同时出现五种或以上的水果，就称之为&#8220;水果开会&#8221;。</font></p>
<p><font face="Verdana">从搜索引擎切词的语法角度，只要两种水果的名字中有一个字相同就属于同样的类别。例如&#8220;小雪梨&#8221;和&#8220;大雪梨&#8221;是同一种水果，而&#8220;核桃&#8221;和&#8220;水蜜桃&#8221;也被认为是同一种水果。尤其要指出的是，如果有三种水果x, y, z同时在前台出现，且x和y是同一种水果，y和z也是同一种水果的时候，x和z在此时也被认为是同一种水果（即使x和z并不包含相同的字）。现在前台的姐姐们想知道，今天是否有&#8220;水果开会&#8221;——五种或更多的水果同时在前台出现。</font></p>
<p><font face="Verdana">输入格式<br />
输入的第一行只有一个整数n，表示购置水果的组数。接下来的n行表示水果的到达时间、取走时间（时间用1200到1900之间的正整数表示，保证取走时间大于到达时间）。剩下的字符串以空格分割每一种水果。如&#8220;1400 1600 雪梨水蜜桃&#8221;，表示下午两点到四点（包含两点和四点这两个时间点），雪梨和水蜜桃会在前台等待开会。每种水果名称由不超过十个汉字组成。</font></p>
<p><font face="Verdana">输出格式<br />
输出仅一行，包含一个字符串Yes或No，分别表示今天水果开会与否。</font></p>
<p><font face="Verdana">输入样例1 例<br />
3<br />
1200 1400 雪梨 柠檬<br />
1300 1400 西瓜 苹果<br />
1400 1800 花生 水蜜桃</font></p>
<p><font face="Verdana">输出样例1 例<br />
Yes</font></p>
<p><font face="Verdana">输入样例2 例<br />
3<br />
1200 1400 雪梨 柠檬<br />
1400 1500 哦 大梨 呀<br />
1500 1800 咦 大梨</font></p>
<p><font face="Verdana">输出样例2 例<br />
No</font></p>
<p><font face="Verdana">样例解释<br />
在样例1中，时刻1400有六种水果在前台；在样例2中，由于雪梨和大梨在任何时刻都是同一种水果，最多只有四种水果同时在前台。</font></p>
<p><font face="Verdana">评分规则</font></p>
<p><font face="Verdana">&nbsp;&nbsp; 1. 程序将运行在一台Linux机器上（内存使用不作严格限制），在每一测试用例上运行不能超过1秒，否则该用例不得分；<br />
&nbsp;&nbsp; 2. 要求程序能按照输入样例的格式读取标准输入数据，按照输出样例的格式将运行结果输出到标准输出上。如果不能正确读入数据和输出数据，该题将不得分；<br />
&nbsp;&nbsp; 3. 该题共有10个测试数据集，每组数据均满足n&lt;=10，每个时段最多有10个水果，一共不超过50个水果；<br />
&nbsp;&nbsp; 4. 该题目20分。</font></p>
<font face="Verdana">
<p><br />
&nbsp;</p>
<p>&nbsp;<br />
二、.大话西游与数字游戏</p>
<p>&#8220;叉烧鸡翅膀，我呀最爱吃！&#8230;&#8230;&#8221;</p>
<p>百度spider组的&#8220;黑龙潭之行&#8221;在烤着鸡翅，唱着星爷的经典时达到高潮。大家在篝火旁围成一圈，开始玩&#8220;数7&#8221;加强版游戏，规则如下：<br />
规则1：遇7的倍数或含7的数时pass。<br />
规则2：遇有包含相同数字的数时pass。注意相同数字不必相邻。例如121。</p>
<p>数错的惩罚很残酷——吞食烤全羊。为避免惩罚，百度工程师们需要你——史上最强程序员的帮助。百度工程师想知道：<br />
req1 x：符合规则1的第x个数是什么？<br />
req2 y：符合规则2的第y个数是什么？<br />
req12 z：同时符合规则1、2的第z个数是什么？<br />
query n：数n是规则1中的第几个数，是规则2中的第几个数？</p>
<p>输入格式<br />
输入的每一行为一个查询，由一个查询词和一个无符号整型数组成。共有四种查询，查询词分别为req1、req2、req12、query（区分大小写）。</p>
<p>输出格式<br />
前三种查询输出一个无符号整型的解。对于&#8220;query n&#8221;的查询，若n是规则中的数则输出相应的解，否则输出-1。</p>
<p>输入样例 例<br />
req1 10<br />
req2 10<br />
req12 10<br />
query 14</p>
<p>输出样例 例<br />
11<br />
10<br />
12<br />
-1 13</p>
<p>评分规则</p>
<p>&nbsp;&nbsp; 1. 程序将运行在一台Linux机器上（内存使用不作严格限制），在每一测试用例上运行不能超过1秒，否则该用例不得分；<br />
&nbsp;&nbsp; 2. 要求程序能按照输入样例的格式读取标准输入数据，按照输出样例的格式将运行结果输出到标准输出上。如果不能正确读入数据和输出数据，该题将不得分；<br />
&nbsp;&nbsp; 3. 该题目共有10个测试数据集，其中数据1~5主要考查正确性，满足x,y,z,n&lt;=1000；输入6~10主要考查时间效率，满足x&lt;=10,000,000，y&lt;=1,000,000，z&lt;=240,000，n&lt;=20,000,000。数据1和6只包含req1，数据2和7只包含req2，数据3和8只包含req12，数据4和7只包含query，数据5和10包含全部四种查询。每组数据都恰好包含 100个查询。<br />
&nbsp;&nbsp; 4. 该题目20分。</p>
<p><br />
&nbsp;</p>
<p>三、.繁忙的会议室预定问题</p>
<p>百度由最开始的7人团队迅速发展为几千人的大团队，而工程师们经常需要在一起进行&#8220;头脑风暴&#8221;，这样会议室就成了紧缺资源。为了有效利用资源，大家决定制定规则， 自动安排会议室的使用。</p>
<p>为了公平起见，应按照申请时间从早到晚依次考虑，先到先得，且申请一旦被接受就不能取消。在处理每条请求时，只要当前请求可以和前面已接受的所有请求同时满足时就必须被接受（如有必要，可以调整给已接受申请安排的会议室和开会时间）。注意同一时间开的不同会议必须在不同的会议室，而同一个人不能同时参加两个会议。</p>
<p>输入格式<br />
输入第一行为会议室总数n和请求总数m；第二行是n个整数，表示会议室能够容量的人数。以下m行每行是一个请求，按请求时间先后顺序排列（即应优先满足在输入中更早出现的请求）。<br />
每个请求中第一个是整数，表示会议需要的时间长度（单位：小时）；之后为与会人名单。人名由不超过四个汉字组成，用半角逗号分隔（每人名字固定且唯一，有重名的也在登记时区分开）。名单后的数字表示可以安排会议的时间，也以半角逗号分隔，如 10,11,14,15 表示第10, 11, 14, 15个小时可以开会（会议时间为9到19之间的正整数）。</p>
<p>输出格式<br />
输出m行，依次表示每个请求是否被接受。1表示接受，0表示不接受。</p>
<p>输入样例： 例<br />
2 4<br />
20 2<br />
3 张三,李四,王五 10,11,12,14,15<br />
1 张三 12<br />
4 王六,王七,王八,王九,王十 9,10,11,12,13,14,15<br />
2 张三 14,15</p>
<p>输出样例： 例<br />
1<br />
0<br />
0<br />
1</p>
<p>样例解释<br />
请求1可以满足，因此接受；在请求1接受的前提下请求2和请求3都无法满足，因此不接受。请求1和请求4可以同时满足（都在会议室1，前者用时间 10~12，后者用时间14~15）。需要特别注意的是：如果没有请求1，后三个请求可以同时满足。但是规则是先到先得，请求1只要可以满足就必须接受。</p>
<p>评分规则</p>
<p>&nbsp;&nbsp; 1. 程序将运行在一台Linux机器上（内存使用不作严格限制），在每一测试用例上运行不能超过2秒，否则该用例不得分；<br />
&nbsp;&nbsp; 2. 要求程序能按照输入样例的格式读取标准数据，按照输出样例的格式将运行结果输出到标准输出上。如果不能正确读入数据和输出数据，该题将不得分；<br />
&nbsp;&nbsp; 3. 该题共有15个测试数据集，均满足n&lt;=10，m&lt;=10。每个会议最多有10人参加；<br />
&nbsp;&nbsp; 4. 该题目30分。</p>
<p><br />
&nbsp;</p>
<p>四、.SQL中的SELECT语句</p>
<p>SQL中的SELECT语句用于从数据库中查询记录。某个工程项目数据库中有一个所有数据均为字符串的表，需要查询一些满足条件的记录数。本题考虑SELECT语句的简化形式，相关语句格式如下：</p>
<p>1. 计数语句，查询满足条件的记录条数。有两种格式：<br />
格式1：SELECT COUNT(*) &lt;FROM子句&gt; WHERE &lt;条件&gt;<br />
格式2：SELECT COUNT(*) &lt;FROM子句&gt;</p>
<p>2. 子集选择语句，选择满足条件的记录并组成一个集合。有两种格式<br />
格式1：SELECT * &lt;FROM子句&gt; WHERE &lt;条件&gt;<br />
格式2：SELECT * &lt;FROM子句&gt;</p>
<p>上述两种语句中的FROM子句具有相同的格式：<br />
格式1：FROM &lt;TABLENAME&gt;<br />
格式2：FROM (子集选择语句)<br />
其中TABLENAME为该工程中惟一的表名，子集选择语句即上述用SELECT *开头的语句。</p>
<p>条件的格式为一条或多条&lt;FIELD&gt;=&lt;VALUE&gt;用关键字and连接（不区分大小写），其中FIELD为字段名，VALUE为数据值，它们均为由大小写字母和数字组成的长度不超过10的非空字符串。该条件表示所有特定的字段必须等于给定值。<br />
给定表中的所有记录和若干条计数语句，输出所有语句的结果。</p>
<p>输入格式<br />
输入第一行为三个整数c, n, q，分别表示数据库中表的列数、记录数和查询次数；第二行为表名(即TABLENAME)；第三行为表中的c个字段名(FIELD)，之间用一个或多个空格隔开，字段名各不相同；接下来n行，每行表示一个记录，有c个数据值(VALUE)，之间用空格隔开；接下去有q行，每行一条SELECT记录数语句，该语句长度（包括空格）不超过1000。输入数据保证每条语句满足题目中给出的计数语句的定义，并且FROM子句的格式1中出现的表名和输入的表名一致。</p>
<p>输出格式<br />
输出q行，每行一个整数，表示相应语句输出的结果（即满足条件的记录数）。</p>
<p>输入样例 例<br />
4 5 6<br />
Book<br />
BookName Price PublishDate Author<br />
NBAsports 10 2004 dearboy<br />
SQL 20 2002 absorbed<br />
IntrotoAlgorithm 59 2002 Thomas<br />
MultipeView 60 2002 RichardHautley<br />
NBAsports 10 2004 dearboy<br />
SELECT COUNT(*) FROM Book WHERE BookName=NBAsports and Author=dearboy<br />
SELECT COUNT(*) FROM Book WHERE Price=20<br />
SELECT COUNT(*) FROM Book WHERE Author=lala<br />
SELECT COUNT(*) FROM (SELECT * FROM Book WHERE BookName=NBAsports)<br />
SELECT COUNT(*) FROM (SELECT * FROM Book WHERE BookName=NBAsports) WHERE Price=20<br />
SELECT COUNT(*) FROM Book</p>
<p>输出样例 例<br />
2<br />
1<br />
0<br />
2<br />
0<br />
5</p>
<p>评分规则</p>
<p>&nbsp;&nbsp; 1. 程序将运行在一台Linux机器上（内存使用不作严格限制），在每一测试用例上运行不能超过2秒，否则该用例不得分；<br />
&nbsp;&nbsp; 2. 要求程序能按照输入样例的格式读取标准数据，按照输出样例的格式将运行结果输出到标准输出上。如果不能正确读入数据和输出数据，该题将不得分；<br />
&nbsp;&nbsp; 3. 该题共有10个测试数据集，数据1的表与样例相同，并包含15条SELECT语句。数据2,3,4,5的表分别有1,2,5,7列，数据6~10的表均有8列。数据2~5的表均有恰好1000条记录，并包含100个SELECT语句。数据6~10的表不超过3000条记录，并包含不超过 20000条SELECT语句。本题的后5组数据着重考查程序的时间效率；<br />
&nbsp;&nbsp; 4. 该题目30分。<br />
&nbsp;<br />
<span style="color: red">初赛第一场点评 <br />
</span>本场的四道题目分别涉及到字符串处理、无向图的连通分量、进位值、组合计数、排列生成、二分查找、回溯法、倒排与索引等数据结构与算法，编码时间比较紧张，需要选手根据自己的情况选择合适的题目。</p>
<p>第一题</p>
<p>本题考查对输入的处理、二元关系的理解和简化问题的能力。本题有很多人得满分，但不少选手花费了大量的时间，导致没空再做其他题目了。<br />
算法梗概：枚举输入中出现的所有时间，统计该时间出现的水果所组成无向图的连通分量。规模很小，可以直接遍历，也可用并查集实现。输入时可以一行一行输入，也可以直接用scanf("%s")依次处理各个token，以数字串开头时意味着新行的开始。如果代码精练的话，是可以在1k之内完成本题的，并没有像很多选手想象的那样麻烦。<br />
易错点：题目中给出的二元关系随时间而变化。最稳妥的方法是对于每个时间点重新计算一遍，否则可能会出错</p>
<p>第二题</p>
<p>这是一道数学味道比较浓的题目，可以用多种方法解决。虽然取得一半分数（一个一个数）并不困难，但要在短时间内通过所有数据并不容易。仅有6位选手获得满分。<br />
算法梗概：题目中给出的规模虽然不算很小，但也不算大。事先把所有满足数据限制的三类数（规则1、规则2、规则1+2）生成出来并存放在表中，用二分查找回答query即可。本题也可以使用递推，但是相比之下思维难度较大。生成第一类数时不要一个一个数，比如当数到700000发现出现数字7时应直接加上100000而不是1。生成第二类数可以直接用经典的排列生成算法，或者递归枚举。第三类数可以用类似有序表归并的方法，或者直接使用STL中集合交的算法。<br />
易错点：按规则一个一个的数，导致后5个点严重超时。</p>
<p>第三题</p>
<p>这是一道实际问题，约束比较多，很难找到多项式级别的算法。所有选手中仅有两位获得满分30分，三位28分。<br />
算法梗概：首先预处理得到每个请求涉及到的人，以及该会议可能的开始时间和会议室，然后递归搜索<br />
易错点：尝试用贪心法，导致结果错误。</p>
<p>第四题</p>
<p>本题是第一场比赛中最难的一道，也是最灵活的一道。它的背景是数据库中的SQL查询处理，但是由于表和查询的特殊性，可以有更多的有针对性的处理方法。例如，由于语句总是合法的，而且WHERE子句的条件只用逻辑与连接，我们可以简单的查找等号，并处理它所在的token即可，大大的降低了输入处理的复杂程度。即使采取高效的算法（而不是逐一匹配），也不难把代码量控制在2k以内。本题的提交并不算少，但仅有三位选手获得满分。绝大多数程序由于时间效率太低而只获得了很少的分数。<br />
算法梗概：通常的处理方法是对表进行预处理，例如增加索引：按照某个主关键字给各条记录排序，在查询时首先根据主关键字的值把查询范围缩小，然后在该范围内依次判断是否符合查询。考虑到查询的多样性，可以对每个field做一个索引，然后在查询中选一个合适的field作为主关键字。更复杂的思路是做多级索引，但索引本身的规模和生成的时间将迅速增加，选手需要在索引数量和质量上做一个权衡，甚至可以借鉴机器学习中ID3分类算法的思想，根据不同field的&#8220;分类&#8221;能力来创建分类树。当然，若只是为了通过测试用例，可以简单的用预处理保存所有可能查询所对应的结果，则每次查询处理的时间接近于常数级。本题的各种尝试和实验对算法设计、实现能力的提高都很有帮助，渴望提高算法水平的选手可以试一试。<br />
易错点：不重视算法的时间复杂度，导致大量超时。<br />
</font></p>
