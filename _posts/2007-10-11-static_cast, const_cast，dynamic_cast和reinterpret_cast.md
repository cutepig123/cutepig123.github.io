<A href="http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx">http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx</A><BR><FONT size=2>static_cast在功能上基本上与C风格的类型转换一样强大，含义也一样。它也有功能上限制。例如，你不能用static_cast象用C风格的类型转换一样把struct转换成int类型或者把double类型转换成指针类型，另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换操作符const_cast有这样的功能。 <BR></FONT><BR><FONT size=2>const_cast用于类型转换掉表达式的const或volatileness属性。通过使用const_cast，你向人们和编译器强调你通过类型转换想做的只是改变一些东西的constness或者 volatileness属性。这个含义被编译器所约束。如果你试图使用const_cast来完成修改constness 或者volatileness属性之外的事情，你的类型转换将被拒绝。<BR>&nbsp;<BR>dynamic_cast，它被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）。 <BR><BR>reinterpret_casts，使用这个操作符的类型转换，其的转换结果几乎都是执行期定义（implementation-defined）。因此，使用reinterpret_casts的代码很难移植。 reinterpret_casts的最普通的用途就是在函数指针类型之间进行转换。 <BR><BR>比如转换函数指针的代码是不可移植的（C++不保证所有的函数指针都被用一样的方法表示），在一些情况下这样的转换会产生不正确的结果（参见条款M31），所以你应该避免转换函数指针类型。 <BR><BR>5、如果你使用的编译器缺乏对新的类型转换方式的支持，你可以用传统的类型转换方法代替static_cast, const_cast, 以及reinterpret_cast。也可以用下面的宏替换来模拟新的类型转换语法： <BR>#define static_cast(TYPE,EXPR) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((TYPE)(EXPR)) <BR>#define const_cast(TYPE,EXPR) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((TYPE)(EXPR)) <BR>#define reinterpret_cast(TYPE,EXPR) &nbsp;&nbsp;((TYPE)(EXPR)) <BR><BR>这些模拟不会象真实的操作符一样安全，但是当你的编译器可以支持新的的类型转换时，它们可以简化你把代码升级的过程。 <BR><BR>没有一个容易的方法来模拟dynamic_cast的操作，但是很多函数库提供了函数，安全地在派生类与基类之间进行类型转换。如果你没有这些函数而你有必须进行这样的类型转换，你也可以回到C风格的类型转换方法上，但是这样的话你将不能获知类型转换是否失败。当然，你也可以定义一个宏来模拟dynamic_cast的功能，就象模拟其它的类型转换一样： <BR><BR>#define dynamic_cast(TYPE,EXPR) &nbsp;&nbsp;&nbsp;&nbsp;(TYPE)(EXPR) <BR><BR>请记住，这个模拟并不能完全实现dynamic_cast的功能，它没有办法知道转换是否失败。<BR><BR></FONT>