http://www.newsmth.net/frames.html<br><br>发信人: cutepig (cutepig), 信区: Algorithm<br>标 &nbsp;题: 求助：5道算法题<br>发信站: 水木社区 (Sat Nov 10 18:25:06 2007), 站内<br><br><br>1)given
a integer, output its previous and next neighbor number which has the
same number of bit 1 in their binary representation.<br>（1）只想到一种很笨的方法，就是将这个数递增或者递减，直到找到一个和它1的位数一样多的为止，应该有更好的方法<br>（2）<br>满足条件的比这个数大的数应该是这个数从最低位开始，找到的第一个的01组合对调。<br>满足条件的比这个数小的数应该是这个数从最低位开始，找到的第一个的10组合对调。<br><br>2）
Given 1 GB memory, input a file which contians 4 billion integers,
output one integer that is not in the file. What if you have only 10 MB
memory?<br>这个如果用一位表示一个数的存在与否的话，需要2^32bits=2^32/8bytes=2^29=512MB内存，用10M的话似乎只能读多次文件，每次判断某一部分数存在与否，有没有更好的办法？<br><br>3）
how to divide an integer array into 2 sub-arrays and make their
averages equal? e.g. a[left_portion]/left_portion_num ==
a[right_portion]/right_portion_num.<br><br>4）Given n unsigned integer, output 2 integers which has the maximum result after XOR.<br>莫非要遍历所有可能的组合？<br><br>5）Input an integer array of size n and an integer k (k&lt;=n), output all subsets of size k.<br>（1）这个类似于全排列的生成算法吧，想出一个递归的回溯方法<br>array,n:数组和数组大小<br>k:子数列大小<br>void output(int *array,int n,int k)<br>{<br>&nbsp;&nbsp; static int used[n];//这个静态数组记录是否该元素已经输出了，初始化为0<br>&nbsp;&nbsp; static int outdata[k];//记录已经输出的元素<br>&nbsp;&nbsp; if k&lt;=0 ,return;<br>&nbsp;&nbsp; 对于array的每一个未输出的元素array[i]<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp; &nbsp; 将该元素放到outdata中，标记used[i]=1;<br>&nbsp;&nbsp; &nbsp; 如果满k个了，则输出outdata的数据<br>&nbsp;&nbsp; &nbsp; 否则，递归调用output(array,n,k-1)<br>&nbsp;&nbsp; &nbsp; 回溯，令used[i]=0;<br>&nbsp;&nbsp;}<br>}<br>（2）或者写一个Next函数用来计算当前排列的下一个排列<br><div style="border: 1px solid rgb(204, 204, 204); padding: 4px 5px 4px 4px; background-color: rgb(238, 238, 238); font-size: 13px; width: 98%;"><!--<br><br>Code highlighting produced by Actipro CodeHighlighter (freeware)<br>http://www.CodeHighlighter.com/<br><br>--><span style="color: rgb(0, 0, 0);">BOOL&nbsp;Next(</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">data,</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;nmax,</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;k)<br>{<br></span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;i;<br></span><span style="color: rgb(0, 0, 255);">#define</span><span style="color: rgb(0, 0, 0);">&nbsp;MyMax(i)&nbsp;(nmax-k+i)</span><span style="color: rgb(0, 0, 0);"><br></span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);">&nbsp;(i</span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);">k</span><span style="color: rgb(0, 0, 0);">-</span><span style="color: rgb(0, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">;i</span><span style="color: rgb(0, 0, 0);">&gt;=</span><span style="color: rgb(0, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">&nbsp;;i</span><span style="color: rgb(0, 0, 0);">--</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);">从后向前找到第一个可以增加的数</span><span style="color: rgb(0, 128, 0);"><br></span><span style="color: rgb(0, 0, 0);">{<br>ASSERT(data[i]</span><span style="color: rgb(0, 0, 0);">&gt;=</span><span style="color: rgb(0, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">&amp;&amp;</span><span style="color: rgb(0, 0, 0);">&nbsp;data[i]</span><span style="color: rgb(0, 0, 0);">&lt;=</span><span style="color: rgb(0, 0, 0);">MyMax(i));<br></span><span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 0, 0);">(data[i]</span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);">MyMax(i))<br>{<br></span><span style="color: rgb(0, 0, 255);">break</span><span style="color: rgb(0, 0, 0);">;<br>}<br>}<br></span><span style="color: rgb(0, 0, 255);">if</span><span style="color: rgb(0, 0, 0);">(i</span><span style="color: rgb(0, 0, 0);">&gt;=</span><span style="color: rgb(0, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);">将该位++，后面各位递增</span><span style="color: rgb(0, 128, 0);"><br></span><span style="color: rgb(0, 0, 0);">{<br>data[i]</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;<br></span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);">&nbsp;(</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">&nbsp;j</span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);">i</span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">;j</span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);">k;j</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">)<br>{<br>data[j]</span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);">data[j</span><span style="color: rgb(0, 0, 0);">-</span><span style="color: rgb(0, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">;<br>ASSERT(data[j]</span><span style="color: rgb(0, 0, 0);">&lt;=</span><span style="color: rgb(0, 0, 0);">MyMax(j))<br>}<br></span><span style="color: rgb(0, 0, 255);">return</span><span style="color: rgb(0, 0, 0);">&nbsp;TRUE;<br>}<br></span><span style="color: rgb(0, 0, 255);">else</span><span style="color: rgb(0, 0, 0);"><br></span><span style="color: rgb(0, 0, 255);">return</span><span style="color: rgb(0, 0, 0);">&nbsp;FALSE;<br><br>}</span></div><br>初始化data={0,...,k-1}，再一直调用Next就可以得到所有的排列<br>发信人: scottfield (金蛇郎君), 信区: Algorithm<br>标 &nbsp;题: Re: 求助：5道算法题<br>发信站: 水木社区 (Sat Nov 10 20:18:14 2007), 站内<br><br><i><b>第三个，可以参考CLRS，可以线性时间求得，是weighted-select problem<br>把值看成权就行了。</b></i><br>发信人: scottfield (金蛇郎君), 信区: Algorithm<br>标 &nbsp;题: Re: 求助：5道算法题<br>发信站: 水木社区 (Sat Nov 10 20:24:24 2007), 站内<br><br>第四题,XOR是　00-&gt;1 11-&gt;1是不？<br><br>则只要找出两个最高位相同的倍数最多的不就行了？<br><i><b><br>用Significant-bit Radix Sort　</b></i><br><br>发信人: ttl (小驴|主ID), 信区: Algorithm<br>标 &nbsp;题: Re: 求助：5道算法题<br>发信站: 水木社区 (Sat Nov 10 20:36:27 2007), 站内<br><br>【 在 wlalbert (找个打我球的女朋友) 的大作中提到: 】<br>如何用c++实现？<br>【 在 cutepig (cutepig) 的大作中提到: 】<br><span class="f006">: 似乎真的是这样呀</span><br><span class="f006">: 满足条件的比这个数大的数应该是这个数从最低位开始，找到的第一个的01组合对调。</span><br><span class="f006">: 满足条件的比这个数小的数应该是这个数从最低位开始，找到的第一个的10组合对调。</span><br><span class="f006">: ...................</span><br><br>void find(int i)<br>{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int f = 3; // 11<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int pf = 2; // 10<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int nf = 1; // 01<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int p = 0; // 小<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int n = 0; // 大<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;while (f &lt; 4 * i)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int tmp = f &amp; i;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!p)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (0 == (tmp ^ pf))<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = i ^ f;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!n)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (0 == (tmp ^ nf))<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n = i ^ f;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f &nbsp;&lt;&lt;= 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pf &lt;&lt;= 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nf &lt;&lt;= 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;cout &lt;&lt; p &lt;&lt; endl;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;cout &lt;&lt; n &lt;&lt; endl;<br>}<br>发信人: zgx03 (时间旅客), 信区: Algorithm<br>标 &nbsp;题: Re: 求助：5道算法题<br>发信站: 水木社区 (Sat Nov 10 21:07:26 2007), 站内<br><br>第4题这么做，<br>设原数组为A，里面的元素取反后形成第二个数组B，把这两个数组合起来形成数组C。<br>把C排一下序，找C的相邻两个分别属于A和B且二进制最高几位连续相同最多的，即可。<br>复杂度NlogN。<br><br>