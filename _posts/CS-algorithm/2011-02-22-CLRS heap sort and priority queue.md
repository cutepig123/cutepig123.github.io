---
categories: CS-algorithm
---
<div>//ref: CLRS $6<br /><br />#include &lt;stdio.h&gt; <br />#include &lt;stdlib.h&gt; <br />#include &lt;time.h&gt; <br />#include &lt;assert.h&gt; <br />#include &lt;algorithm&gt; <br /><br />#define MAX 20<br /><br />int number[MAX+1];<br />int heap_size;<br /><br />void printHeap()<br />{<br />&nbsp;&nbsp; &nbsp;for(int i = 1; i &lt;= heap_size; i++) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d ", number[i]); <br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp; &nbsp;printf("\n");<br />}<br /><br />int parentId( int i) <br />{<br />&nbsp;&nbsp; &nbsp;return i/2;<br />}<br /><br />int leftId( int i) <br />{<br />&nbsp;&nbsp; &nbsp;return i*2;<br />}<br /><br />int rightId(int i) <br />{<br />&nbsp;&nbsp; &nbsp;return i*2+1;<br />}<br /><br /><br />//from A[i]-&gt;leaf, to make A[i] at the correct position<br />void maxHeapify(int i) <br />{<br />&nbsp;&nbsp; &nbsp;int l = leftId(i);<br />&nbsp;&nbsp; &nbsp;int r = rightId(i);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;int largest;<br />&nbsp;&nbsp; &nbsp;// if leftId child is larger than current, then <br />&nbsp;&nbsp; &nbsp;if( l&lt;=heap_size &amp;&amp; number[l]&gt;number[i] )<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;largest = l;<br />&nbsp;&nbsp; &nbsp;else<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;largest = i;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;// if rightId child is larger than current, then <br />&nbsp;&nbsp; &nbsp;if( r&lt;=heap_size &amp;&amp; number[r]&gt;number[largest] )<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;largest = r;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;if( largest!=i )&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//swap and <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::swap( number[i], number[largest] );<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;maxHeapify(largest);<br />&nbsp;&nbsp; &nbsp;}<br />}<br /><br />void buildMaxHeap() { <br />&nbsp;&nbsp;&nbsp; for(int i=heap_size/2; i&gt;=1; i--)<br />&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;maxHeapify(i);<br />&nbsp;&nbsp; &nbsp;}<br />} <br /><br />void heapSort() { <br />&nbsp;&nbsp;&nbsp; buildMaxHeap();<br />&nbsp;&nbsp; &nbsp;printf("\ncreate heap:"); <br />&nbsp;&nbsp; &nbsp;printHeap();<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;int heap_size_ = heap_size;<br />&nbsp;&nbsp; &nbsp;for(int i=heap_size; i&gt;=2; i--)<br />&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::swap(number[1], number[i]);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;heap_size--;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;maxHeapify(1);<br />&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;heap_size = heap_size_;<br />} <br /><br />// priority queue<br />int heapMaximum()<br />{<br />&nbsp;&nbsp; &nbsp;return number[1];<br />}<br /><br />int heapExtractMax()<br />{<br />&nbsp;&nbsp; &nbsp;assert(heap_size&gt;=1);<br /><br />&nbsp;&nbsp; &nbsp;int max = number[1];<br /><br />&nbsp;&nbsp; &nbsp;//move the last value to root, then adjust to heap<br />&nbsp;&nbsp; &nbsp;number[1] = number[heap_size];<br />&nbsp;&nbsp; &nbsp;heap_size --;<br />&nbsp;&nbsp; &nbsp;maxHeapify(1);<br /><br />&nbsp;&nbsp; &nbsp;return max;<br />}<br /><br />// update number[i] to key<br />void heapIncreaseKey(int i, int key)<br />{<br />&nbsp;&nbsp; &nbsp;assert(key&gt;=number[i]);<br /><br />&nbsp;&nbsp; &nbsp;//adjust from [i] to root<br />&nbsp;&nbsp; &nbsp;number[i] = key;<br />&nbsp;&nbsp; &nbsp;while( i&gt;1 &amp;&amp; number[parentId(i)]&lt;number[i] )<br />&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;std::swap( number[parentId(i)], number[i] );<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i&nbsp; = parentId(i);<br />&nbsp;&nbsp; &nbsp;}<br />}<br /><br />#define&nbsp;&nbsp; &nbsp;MINIMUM_INT&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-65555<br /><br />void maxHeapInsert(int key)<br />{<br />&nbsp;&nbsp; &nbsp;heap_size ++;<br />&nbsp;&nbsp; &nbsp;number[heap_size] = MINIMUM_INT;<br />&nbsp;&nbsp; &nbsp;heapIncreaseKey( heap_size, key );<br />}<br /><br />int main(void) { <br />&nbsp;//&nbsp;&nbsp; srand(1); <br />&nbsp;//&nbsp; &nbsp;<br />&nbsp;//&nbsp;&nbsp; //init the data<br />&nbsp;//&nbsp;&nbsp; int i;<br />&nbsp;//&nbsp;&nbsp; for(i = 1; i &lt;= MAX; i++) { <br />&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number[i] = rand() % 100; <br />&nbsp;//&nbsp;&nbsp; } <br />&nbsp;&nbsp; &nbsp;//heap_size = MAX;<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;printf("test heapSort\n");<br />&nbsp;&nbsp; &nbsp;int a[] = {4,1,3,2,16,9,10,14,8,7};<br />&nbsp;&nbsp; &nbsp;heap_size = sizeof(a)/sizeof(a[0]);<br />&nbsp;&nbsp; &nbsp;std::copy(a, a+heap_size,number+1);<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;// print<br />&nbsp;&nbsp; &nbsp;printf("before sort:"); <br />&nbsp;&nbsp; &nbsp;printHeap();<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;// sort<br />&nbsp;&nbsp;&nbsp; heapSort(); <br />&nbsp;&nbsp;&nbsp; printf("after sort"); <br />&nbsp;&nbsp; &nbsp;printHeap();<br /><br />&nbsp;&nbsp; &nbsp;printf("test priority queue\n");<br />&nbsp;&nbsp; &nbsp;heap_size = sizeof(a)/sizeof(a[0]);<br />&nbsp;&nbsp; &nbsp;std::copy(a, a+heap_size,number+1);<br /><br />&nbsp;&nbsp; &nbsp;buildMaxHeap();<br />&nbsp;&nbsp; &nbsp;heapIncreaseKey( 9, 15 );<br />&nbsp;&nbsp; &nbsp;printHeap();<br /><br />&nbsp;&nbsp;&nbsp; return 0; <br />} <br /></div>