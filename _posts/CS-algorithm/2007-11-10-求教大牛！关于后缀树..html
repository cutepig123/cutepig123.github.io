<div class="article" id="art9886">发信人: keerling (keer), 信区: Algorithm<br>标 &nbsp;题: 求教大牛！关于后缀树<br>发信站: 水木社区 (Wed Nov &nbsp;7 16:52:12 2007), 站内<br><br>不知道这帖子发这里合适不合适<br><br>见版上的大牛们经常用suffix tree，suffix array来解题，偶也想学习一下，但一直对构造suffix tree的算法不理解，请大牛们不吝赐教！如果能够给出相应的数据结构和伪代码描述，就感激不尽了！<br><br>再次感谢！<br>--<br><br>※ 来源:·水木社区 <a target="_blank" href="http://newsmth.net/">http://newsmth.net</a>·[FROM: 159.226.58.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9889">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9889">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=sheven9">sheven9</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9889">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">2</div></div><div class="article" id="art9889">发信人: sheven9 (IT真苦啊), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Wed Nov &nbsp;7 17:15:58 2007), 站内<br><br><a target="_blank" href="http://www.cs.mcgill.ca/%7Ecs251/OldCourses/1997/topic7/">http://www.cs.mcgill.ca/~cs251/OldCourses/1997/topic7/</a> <br>【 在 keerling (keer) 的大作中提到: 】<br><span class="f006">: 不知道这帖子发这里合适不合适</span><br><span class="f006">: 见版上的大牛们经常用suffix tree，suffix array来解题，偶也想学习一下，但一直对构造suffix tree的算法不理解，请大牛们不吝赐教！如果能够给出相应的数据结构和伪代码描述，就感激不尽了！</span><br><span class="f006">: 再次感谢！</span><br><span class="f006">: ...................</span><br><br>--<br><br>※ 来源:·水木社区 newsmth.net·[FROM: 203.135.175.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9891">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9891">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=wk0571">wk0571</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9891">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">3</div></div><div class="article" id="art9891">发信人: wk0571 (wk0571), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Wed Nov &nbsp;7 17:36:55 2007), 站内<br><br><a target="_blank" href="http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf">http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf</a><br>【 在 keerling (keer) 的大作中提到: 】<br><span class="f006">: 不知道这帖子发这里合适不合适</span><br><span class="f006">: 见版上的大牛们经常用suffix tree，suffix array来解题，偶也想学习一下，但一直对构造suffix tree的算法不理解，请大牛们不吝赐教！如果能够给出相应的数据结构和伪代码描述，就感激不尽了！</span><br><span class="f006">: 再次感谢！</span><br><br><br><br>--<br><br>※ 来源:·水木社区 <a target="_blank" href="http://newsmth.net/">http://newsmth.net</a>·[FROM: 218.80.200.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9900">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9900">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=Key">Key</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9900">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">4</div></div><div class="article" id="art9900">发信人: Key (关键时刻~), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Thu Nov &nbsp;8 00:59:16 2007), 站内<br><br>这一篇给的应该是比较详细的过程了。不过我也想知道有没有现成的库可以调用，或者哪位大牛可以给段c或者python的应用代码，示范给大家学习学习那就太好了<br><a target="_blank" href="http://www.csse.monash.edu.au/%7Elloyd/tildeAlgDS/Tree/Suffix/">http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Suffix/</a><br>【 在 keerling (keer) 的大作中提到: 】<br><span class="f006">: 不知道这帖子发这里合适不合适</span><br><span class="f006">: 见版上的大牛们经常用suffix tree，suffix array来解题，偶也想学习一下，但一直对构造suffix tree的算法不理解，请大牛们不吝赐教！如果能够给出相应的数据结构和伪代码描述，就感激不尽了！</span><br><span class="f006">: 再次感谢！</span><br><span class="f006">: ...................</span><br><br>--<br><br>※ 来源:·水木社区 newsmth.net·[FROM: 211.99.222.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9901">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9901">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=elflord">elflord</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9901">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">5</div></div><div class="article" id="art9901">发信人: elflord (丛林精灵), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Thu Nov &nbsp;8 04:28:35 2007), 站内<br><br>found it on google<br>hope it's helpful<br>/******************************************************************************<br>Suffix Tree Version 2.1<br><br>AUTHORS<br><br>Dotan Tsadok<br>Instructor: Mr. Shlomo Yona, University of Haifa, Israel. December 2002.<br>Current maintainer: Shlomo Yona &lt;shlomo@cs.haifa.ac.il&gt;<br><br>COPYRIGHT<br><br>Copyright 2002-2003 Shlomo Yona<br><br>LICENSE<br><br>This library is free software; you can redistribute it and/or modify it<br>under the same terms as Perl itself.<br><br><br>DESCRIPTION OF THIS FILE:<br><br>This is the implementation file suffix_tree.c implementing the header file<br>suffix_tree.h.<br><br>This code is an Open Source implementation of Ukkonen's algorithm for<br>constructing a suffix tree over a string in time and space complexity<br>O(length of the string). The code is written under strict ANSI C.<br><br>For a complete understanding of the code see Ukkonen's algorithm and the<br>readme.txt file.<br><br>The general pseudo code is:<br><br>n = length of the string.<br>ST_CreateTree:<br>&nbsp;&nbsp; Calls n times to SPA (Single Phase Algorithm). SPA: &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;Increase the variable e (virtual end of all leaves).<br>&nbsp;&nbsp; Calls SEA (Single Extension Algorithm) starting with the first extension that<br>&nbsp;&nbsp; does not already exist in the tree and ending at the first extension that<br>&nbsp;&nbsp; already exists. SEA : &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;Follow suffix link.<br>&nbsp;&nbsp; &nbsp; &nbsp;Check if current suffix exists in the tree.<br>&nbsp;&nbsp; &nbsp; &nbsp;If it does not - apply rule 2 and then create a new suffix link.<br>&nbsp;&nbsp; &nbsp; &nbsp;apply_rule_2: &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Create a new leaf and maybe a new internal node as well.<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; create_node: &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create a new node or a leaf.<br><br><br>For implementation interpretations see Basic Ideas paragraph in the Developement<br>section of the readme.txt file.<br><br>An example of the implementations of a node and its sons using linked lists<br>instead of arrays:<br><br>&nbsp;&nbsp; (1)<br>&nbsp;&nbsp; &nbsp;|<br>&nbsp;&nbsp; &nbsp;|<br>&nbsp;&nbsp; &nbsp;|<br>&nbsp;&nbsp; (2)--(3)--(4)--(5)<br><br>(2) is the only son of (1) (call it the first son). Other sons of (1) are<br>connected using a linked lists starting from (2) and going to the right. (3) is<br>the right sibling of (2) (and (2) is the left sibling of (3)), (4) is the right<br>sibling of (3), etc.<br>The father field of all (2), (3), (4) and (5) points to (1), but the son field<br>of (1) points only to (2).<br><br>*******************************************************************************/<br><br>#include "stdlib.h"<br>#include "stdio.h"<br>#include "string.h"<br>#include "suffix_tree.h"<br><br>/* See function body */<br>void ST_PrintTree(SUFFIX_TREE* tree);<br>/* See function body */<br>void ST_PrintFullNode(SUFFIX_TREE* tree, NODE* node);<br><br>/* Used in function trace_string for skipping (Ukkonen's Skip Trick). */<br>typedef enum SKIP_TYPE &nbsp; &nbsp; {skip, no_skip} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SKIP_TYPE;<br>/* Used in function apply_rule_2 - two types of rule 2 - see function for more<br>&nbsp;&nbsp; details.*/<br>typedef enum RULE_2_TYPE &nbsp; {new_son, split} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RULE_2_TYPE;<br>/* Signals whether last matching position is the last one of the current edge */<br>typedef enum LAST_POS_TYPE {last_char_in_edge, other_char} LAST_POS_TYPE;<br><br>/* Used for statistic measures of speed. */<br>DBL_WORD counter;<br>/* Used for statistic measures of space. */<br>DBL_WORD heap;<br>/* Used to mark the node that has no suffix link yet. By Ukkonen, it will have<br>&nbsp;&nbsp; one by the end of the current phase. */<br>NODE* &nbsp; &nbsp;suffixless;<br><br>typedef struct SUFFIXTREEPATH<br>{<br>&nbsp;&nbsp; DBL_WORD &nbsp; begin;<br>&nbsp;&nbsp; DBL_WORD &nbsp; end;<br>} PATH;<br><br>typedef struct SUFFIXTREEPOS<br>{<br>&nbsp;&nbsp; NODE* &nbsp; &nbsp; &nbsp;node;<br>&nbsp;&nbsp; DBL_WORD &nbsp; edge_pos;<br>}POS;<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; Define STATISTICS in order to view measures of speed and space while<br>&nbsp;&nbsp; constructing and searching the suffix tree. Measures will be printed on the<br>&nbsp;&nbsp; screen.<br>*/<br>/* #define STATISTICS */<br><br>/*<br>&nbsp;&nbsp; Define DEBUG in order to view debug printouts to the screen while<br>&nbsp;&nbsp; constructing and searching the suffix tree.<br>*/<br>/* #define DEBUG */<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; create_node :<br>&nbsp;&nbsp; Creates a node with the given init field-values.<br><br>&nbsp;&nbsp;Input : The father of the node, the starting and ending indices <br>&nbsp;&nbsp;of the incloming edge to that node, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;the path starting position of the node.<br><br>&nbsp;&nbsp;Output: A pointer to that node.<br>*/<br><br><br>NODE* create_node(NODE* father, DBL_WORD start, DBL_WORD end, DBL_WORD position)<br>{<br>&nbsp;&nbsp; /*Allocate a node.*/<br>&nbsp;&nbsp; NODE* node &nbsp; = (NODE*)malloc(sizeof(NODE));<br>&nbsp;&nbsp; if(node == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("\nOut of memory.\n");<br>&nbsp;&nbsp; &nbsp; &nbsp;exit(0);<br>&nbsp;&nbsp; }<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; heap+=sizeof(NODE);<br>#endif<br><br>&nbsp;&nbsp; /* Initialize node fields. For detailed description of the fields see<br>&nbsp;&nbsp; &nbsp; &nbsp;suffix_tree.h */<br>&nbsp;&nbsp; node-&gt;sons &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0;<br>&nbsp;&nbsp; node-&gt;right_sibling &nbsp; &nbsp;= 0;<br>&nbsp;&nbsp; node-&gt;left_sibling &nbsp; &nbsp; = 0;<br>&nbsp;&nbsp; node-&gt;suffix_link &nbsp; &nbsp; &nbsp;= 0;<br>&nbsp;&nbsp; node-&gt;father &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = father;<br>&nbsp;&nbsp; node-&gt;path_position &nbsp; &nbsp;= position;<br>&nbsp;&nbsp; node-&gt;edge_label_start = start;<br>&nbsp;&nbsp; node-&gt;edge_label_end &nbsp; = end;<br>&nbsp;&nbsp; return node;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; find_son :<br>&nbsp;&nbsp; Finds son of node that starts with a certain character. <br><br>&nbsp;&nbsp; Input : the tree, the node to start searching from and the character to be<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searched in the sons.<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; Output: A pointer to the found son, 0 if no such son.<br>*/<br><br>NODE* find_son(SUFFIX_TREE* tree, NODE* node, char character)<br>{<br>&nbsp;&nbsp; /* Point to the first son. */<br>&nbsp;&nbsp; node = node-&gt;sons;<br>&nbsp;&nbsp; /* scan all sons (all right siblings of the first son) for their first<br>&nbsp;&nbsp; character (it has to match the character given as input to this function. */<br>&nbsp;&nbsp; while(node != 0 &amp;&amp; tree-&gt;tree_string[node-&gt;edge_label_start] != character)<br>&nbsp;&nbsp; {<br>#ifdef STATISTICS<br>&nbsp;&nbsp; &nbsp; &nbsp;counter++;<br>#endif<br>&nbsp;&nbsp; &nbsp; &nbsp;node = node-&gt;right_sibling;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return node;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; get_node_label_end :<br>&nbsp;&nbsp; Returns the end index of the incoming edge to that node. This function is<br>&nbsp;&nbsp; needed because for leaves the end index is not relevant, instead we must look<br>&nbsp;&nbsp; at the variable "e" (the global virtual end of all leaves). Never refer<br>&nbsp;&nbsp; directly to a leaf's end-index.<br><br>&nbsp;&nbsp; Input : the tree, the node its end index we need.<br><br>&nbsp;&nbsp; Output: The end index of that node (meaning the end index of the node's<br>&nbsp;&nbsp; incoming edge).<br>*/<br><br>DBL_WORD get_node_label_end(SUFFIX_TREE* tree, NODE* node)<br>{<br>&nbsp;&nbsp; /* If it's a leaf - return e */<br>&nbsp;&nbsp; if(node-&gt;sons == 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;return tree-&gt;e;<br>&nbsp;&nbsp; /* If it's not a leaf - return its real end */<br>&nbsp;&nbsp; return node-&gt;edge_label_end;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; get_node_label_length :<br>&nbsp;&nbsp; Returns the length of the incoming edge to that node. Uses get_node_label_end<br>&nbsp;&nbsp; (see above).<br><br>&nbsp;&nbsp; Input : The tree and the node its length we need.<br><br>&nbsp;&nbsp; Output: the length of that node.<br>*/<br><br>DBL_WORD get_node_label_length(SUFFIX_TREE* tree, NODE* node)<br>{<br>&nbsp;&nbsp; /* Calculate and return the lentgh of the node */<br>&nbsp;&nbsp; return get_node_label_end(tree, node) - node-&gt;edge_label_start + 1;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; is_last_char_in_edge :<br>&nbsp;&nbsp; Returns 1 if edge_pos is the last position in node's incoming edge.<br><br>&nbsp;&nbsp; Input : The tree, the node to be checked and the position in its incoming<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edge.<br><br>&nbsp;&nbsp; Output: the length of that node.<br>*/<br><br>char is_last_char_in_edge(SUFFIX_TREE* tree, NODE* node, DBL_WORD edge_pos)<br>{<br>&nbsp;&nbsp; if(edge_pos == get_node_label_length(tree,node)-1)<br>&nbsp;&nbsp; &nbsp; &nbsp;return 1;<br>&nbsp;&nbsp; return 0;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; connect_siblings :<br>&nbsp;&nbsp; Connect right_sib as the right sibling of left_sib and vice versa.<br><br>&nbsp;&nbsp; Input : The two nodes to be connected.<br><br>&nbsp;&nbsp; Output: None.<br>*/<br><br>void connect_siblings(NODE* left_sib, NODE* right_sib)<br>{<br>&nbsp;&nbsp; /* Connect the right node as the right sibling of the left node */<br>&nbsp;&nbsp; if(left_sib != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;left_sib-&gt;right_sibling = right_sib;<br>&nbsp;&nbsp; /* Connect the left node as the left sibling of the right node */<br>&nbsp;&nbsp; if(right_sib != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;right_sib-&gt;left_sibling = left_sib;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; apply_extension_rule_2 :<br>&nbsp;&nbsp; Apply "extension rule 2" in 2 cases:<br>&nbsp;&nbsp; 1. A new son (leaf 4) is added to a node that already has sons:<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / &nbsp; \ &nbsp; &nbsp; -&gt; &nbsp; / | \<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(2) &nbsp;(3) &nbsp; &nbsp; &nbsp;(2)(3)(4)<br><br>&nbsp;&nbsp; 2. An edge is split and a new leaf (2) and an internal node (3) are added:<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(3)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; -&gt; &nbsp; / \<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1) &nbsp; &nbsp; &nbsp; (1) (2)<br><br>&nbsp;&nbsp; Input : See parameters.<br><br>&nbsp;&nbsp; Output: A pointer to the newly created leaf (new_son case) or internal node<br>&nbsp;&nbsp; (split case).<br>*/<br><br>NODE* apply_extension_rule_2(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Node 1 (see drawings) */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NODE* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Start index of node 2's incoming edge */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;edge_label_begin, &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* End index of node 2's incoming edge */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;edge_label_end, &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Path start index of node 2 */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;path_pos, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Position in node 1's incoming edge where split is to be<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; performed */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;edge_pos, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Can be 'new_son' or 'split' */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RULE_2_TYPE &nbsp; &nbsp; type) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>{<br>&nbsp;&nbsp; NODE *new_leaf,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;*new_internal,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;*son;<br>&nbsp;&nbsp; /*-------new_son-------*/<br>&nbsp;&nbsp; if(type == new_son) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; {<br>#ifdef DEBUG &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp;printf("rule 2: new leaf (%lu,%lu)\n",edge_label_begin,edge_label_end);<br>#endif<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Create a new leaf (4) with the characters of the extension */<br>&nbsp;&nbsp; &nbsp; &nbsp;new_leaf = create_node(node, edge_label_begin , edge_label_end, path_pos);<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Connect new_leaf (4) as the new son of node (1) */<br>&nbsp;&nbsp; &nbsp; &nbsp;son = node-&gt;sons;<br>&nbsp;&nbsp; &nbsp; &nbsp;while(son-&gt;right_sibling != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; son = son-&gt;right_sibling;<br>&nbsp;&nbsp; &nbsp; &nbsp;connect_siblings(son, new_leaf);<br>&nbsp;&nbsp; &nbsp; &nbsp;/* return (4) */<br>&nbsp;&nbsp; &nbsp; &nbsp;return new_leaf;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; /*-------split-------*/<br>#ifdef DEBUG &nbsp; <br>&nbsp;&nbsp; printf("rule 2: split (%lu,%lu)\n",edge_label_begin,edge_label_end);<br>#endif<br>&nbsp;&nbsp; /* Create a new internal node (3) at the split point */<br>&nbsp;&nbsp; new_internal = create_node(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;father,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;edge_label_start,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;edge_label_start+edge_pos,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;path_position);<br>&nbsp;&nbsp; /* Update the node (1) incoming edge starting index (it now starts where node<br>&nbsp;&nbsp; (3) incoming edge ends) */<br>&nbsp;&nbsp; node-&gt;edge_label_start += edge_pos+1;<br><br>&nbsp;&nbsp; /* Create a new leaf (2) with the characters of the extension */<br>&nbsp;&nbsp; new_leaf = create_node(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_internal,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;edge_label_begin,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;edge_label_end,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path_pos);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Connect new_internal (3) where node (1) was */<br>&nbsp;&nbsp; /* Connect (3) with (1)'s left sibling */<br>&nbsp;&nbsp; connect_siblings(node-&gt;left_sibling, new_internal); &nbsp; <br>&nbsp;&nbsp; /* connect (3) with (1)'s right sibling */<br>&nbsp;&nbsp; connect_siblings(new_internal, node-&gt;right_sibling);<br>&nbsp;&nbsp; node-&gt;left_sibling = 0;<br><br>&nbsp;&nbsp; /* Connect (3) with (1)'s father */<br>&nbsp;&nbsp; if(new_internal-&gt;father-&gt;sons == node) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;new_internal-&gt;father-&gt;sons = new_internal;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Connect new_leaf (2) and node (1) as sons of new_internal (3) */<br>&nbsp;&nbsp; new_internal-&gt;sons = node;<br>&nbsp;&nbsp; node-&gt;father = new_internal;<br>&nbsp;&nbsp; connect_siblings(node, new_leaf);<br>&nbsp;&nbsp; /* return (3) */<br>&nbsp;&nbsp; return new_internal;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; trace_single_edge :<br>&nbsp;&nbsp; Traces for a string in a given node's OUTcoming edge. It searches only in the<br>&nbsp;&nbsp; given edge and not other ones. Search stops when either whole string was<br>&nbsp;&nbsp; found in the given edge, a part of the string was found but the edge ended<br>&nbsp;&nbsp; (and the next edge must be searched too - performed by function trace_string)<br>&nbsp;&nbsp; or one non-matching character was found.<br><br>&nbsp;&nbsp; Input : The string to be searched, given in indices of the main string.<br><br>&nbsp;&nbsp; Output: (by value) the node where tracing has stopped.<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (by reference) the edge position where last match occured, the string<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position where last match occured, number of characters found, a flag<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for signaling whether search is done, and a flag to signal whether<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search stopped at a last character of an edge.<br>*/<br><br>NODE* trace_single_edge(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SUFFIX_TREE* &nbsp; &nbsp;tree, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Node to start from */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NODE* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* String to trace */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PATH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Last matching position in edge */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp; edge_pos, &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Last matching position in tree source string */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp; chars_found, &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Skip or no_skip*/<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SKIP_TYPE &nbsp; &nbsp; &nbsp; type, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* 1 if search is done, 0 if not */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;search_done) &nbsp; <br>{<br>&nbsp;&nbsp; NODE* &nbsp; &nbsp; &nbsp;cont_node;<br>&nbsp;&nbsp; DBL_WORD &nbsp; length,str_len;<br><br>&nbsp;&nbsp; /* Set default return values */<br>&nbsp;&nbsp; *search_done = 1;<br>&nbsp;&nbsp; *edge_pos &nbsp; &nbsp;= 0;<br><br>&nbsp;&nbsp; /* Search for the first character of the string in the outcoming edge of<br>&nbsp;&nbsp; &nbsp; &nbsp;node */<br>&nbsp;&nbsp; cont_node = find_son(tree, node, tree-&gt;tree_string[str.begin]);<br>&nbsp;&nbsp; if(cont_node == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Search is done, string not found */<br>&nbsp;&nbsp; &nbsp; &nbsp;*edge_pos = get_node_label_length(tree,node)-1;<br>&nbsp;&nbsp; &nbsp; &nbsp;*chars_found = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;return node;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Found first character - prepare for continuing the search */<br>&nbsp;&nbsp; node &nbsp; &nbsp;= cont_node;<br>&nbsp;&nbsp; length &nbsp;= get_node_label_length(tree,node);<br>&nbsp;&nbsp; str_len = str.end - str.begin + 1;<br><br>&nbsp;&nbsp; /* Compare edge length and string length. */<br>&nbsp;&nbsp; /* If edge is shorter then the string being searched and skipping is<br>&nbsp;&nbsp; &nbsp; &nbsp;enabled - skip edge */<br>&nbsp;&nbsp; if(type == skip)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;if(length &lt;= str_len)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (*chars_found) &nbsp; = length;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (*edge_pos) &nbsp; &nbsp; &nbsp;= length-1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(length &lt; str_len)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*search_done &nbsp;= 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;else<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (*chars_found) &nbsp; = str_len;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (*edge_pos) &nbsp; &nbsp; &nbsp;= str_len-1;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; &nbsp; &nbsp;counter++;<br>#endif<br><br>&nbsp;&nbsp; &nbsp; &nbsp;return node;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Find minimum out of edge length and string length, and scan it */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(str_len &lt; length)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; length = str_len;<br><br>&nbsp;&nbsp; &nbsp; &nbsp;for(*edge_pos=1, *chars_found=1; *edge_pos&lt;length; (*chars_found)++,(*edge_pos)++)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; counter++;<br>#endif<br><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Compare current characters of the string and the edge. If equal - <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(tree-&gt;tree_string[node-&gt;edge_label_start+*edge_pos] != tree-&gt;tree_string[str.begin+*edge_pos])<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(*edge_pos)--;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return node;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; }<br><br>&nbsp;&nbsp; /* The loop has advanced *edge_pos one too much */<br>&nbsp;&nbsp; (*edge_pos)--;<br><br>&nbsp;&nbsp; if((*chars_found) &lt; str_len)<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Search is not done yet */<br>&nbsp;&nbsp; &nbsp; &nbsp;*search_done = 0;<br><br>&nbsp;&nbsp; return node;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; trace_string :<br>&nbsp;&nbsp; Traces for a string in the tree. This function is used in construction<br>&nbsp;&nbsp; process only, and not for after-construction search of substrings. It is<br>&nbsp;&nbsp; tailored to enable skipping (when we know a suffix is in the tree (when<br>&nbsp;&nbsp; following a suffix link) we can avoid comparing all symbols of the edge by<br>&nbsp;&nbsp; skipping its length immediately and thus save atomic operations - see<br>&nbsp;&nbsp; Ukkonen's algorithm, skip trick).<br>&nbsp;&nbsp; This function, in contradiction to the function trace_single_edge, 'sees' the<br>&nbsp;&nbsp; whole picture, meaning it searches a string in the whole tree and not just in<br>&nbsp;&nbsp; a specific edge.<br><br>&nbsp;&nbsp; Input : The string, given in indice of the main string.<br><br>&nbsp;&nbsp; Output: (by value) the node where tracing has stopped.<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (by reference) the edge position where last match occured, the string<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position where last match occured, number of characters found, a flag<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for signaling whether search is done.<br>*/<br><br>NODE* trace_string(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SUFFIX_TREE* &nbsp; &nbsp;tree, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Node to start from */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NODE* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* String to trace */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PATH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Last matching position in edge */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp; edge_pos, &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Last matching position in tree string */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp; chars_found,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* skip or not */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SKIP_TYPE &nbsp; &nbsp; &nbsp; type) &nbsp; &nbsp; &nbsp; &nbsp; <br>{<br>&nbsp;&nbsp; /* This variable will be 1 when search is done.<br>&nbsp;&nbsp; &nbsp; &nbsp;It is a return value from function trace_single_edge */<br>&nbsp;&nbsp; int &nbsp; &nbsp; &nbsp;search_done = 0;<br><br>&nbsp;&nbsp; /* This variable will hold the number of matching characters found in the<br>&nbsp;&nbsp; &nbsp; &nbsp;current edge. It is a return value from function trace_single_edge */<br>&nbsp;&nbsp; DBL_WORD edge_chars_found;<br><br>&nbsp;&nbsp; *chars_found = 0;<br><br>&nbsp;&nbsp; while(search_done == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;*edge_pos &nbsp; &nbsp; &nbsp; &nbsp;= 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;edge_chars_found = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;node = trace_single_edge(tree, node, str, edge_pos, &amp;edge_chars_found, type, &amp;search_done);<br>&nbsp;&nbsp; &nbsp; &nbsp;str.begin &nbsp; &nbsp; &nbsp; += edge_chars_found;<br>&nbsp;&nbsp; &nbsp; &nbsp;*chars_found &nbsp; &nbsp;+= edge_chars_found;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return node;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_FindSubstring :<br>&nbsp;&nbsp; See suffix_tree.h for description.<br>*/<br><br>DBL_WORD ST_FindSubstring(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* The suffix array */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SUFFIX_TREE* &nbsp; &nbsp;tree, &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* The substring to find */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char* &nbsp;W, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* The length of W */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;P) &nbsp; &nbsp; &nbsp; &nbsp; <br>{<br>&nbsp;&nbsp; /* Starts with the root's son that has the first character of W as its<br>&nbsp;&nbsp; &nbsp; &nbsp;incoming edge first character */<br>&nbsp;&nbsp; NODE* node &nbsp; = find_son(tree, tree-&gt;root, W[0]);<br>&nbsp;&nbsp; DBL_WORD k,j = 0, node_label_end;<br><br>&nbsp;&nbsp; /* Scan nodes down from the root untill a leaf is reached or the substring is<br>&nbsp;&nbsp; &nbsp; &nbsp;found */<br>&nbsp;&nbsp; while(node!=0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;k=node-&gt;edge_label_start;<br>&nbsp;&nbsp; &nbsp; &nbsp;node_label_end = get_node_label_end(tree,node);<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Scan a single edge - compare each character with the searched string */<br>&nbsp;&nbsp; &nbsp; &nbsp;while(j&lt;P &amp;&amp; k&lt;=node_label_end &amp;&amp; tree-&gt;tree_string[k] == W[j])<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; j++;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; k++;<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; counter++;<br>#endif<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Checking which of the stopping conditions are true */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(j == P)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* W was found - it is a substring. Return its path starting index */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return node-&gt;path_position;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;else if(k &gt; node_label_end)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Current edge is found to match, continue to next edge */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; node = find_son(tree, node, W[j]);<br>&nbsp;&nbsp; &nbsp; &nbsp;else<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* One non-matching symbols is found - W is not a substring */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return ST_ERROR;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return ST_ERROR;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; follow_suffix_link :<br>&nbsp;&nbsp; Follows the suffix link of the source node according to Ukkonen's rules. <br><br>&nbsp;&nbsp; Input : The tree, and pos. pos is a combination of the source node and the <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position in its incoming edge where suffix ends.<br>&nbsp;&nbsp; Output: The destination node that represents the longest suffix of node's <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path. Example: if node represents the path "abcde" then it returns <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the node that represents "bcde".<br>*/<br><br>void follow_suffix_link(SUFFIX_TREE* tree, POS* pos)<br>{<br>&nbsp;&nbsp; /* gama is the string between node and its father, in case node doesn't have<br>&nbsp;&nbsp; &nbsp; &nbsp;a suffix link */<br>&nbsp;&nbsp; PATH &nbsp; &nbsp; &nbsp;gama; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; /* dummy argument for trace_string function */<br>&nbsp;&nbsp; DBL_WORD &nbsp;chars_found = 0; &nbsp; <br>&nbsp;&nbsp; <br>&nbsp;&nbsp; if(pos-&gt;node == tree-&gt;root)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;return;<br>&nbsp;&nbsp; }<br><br>&nbsp;&nbsp; /* If node has no suffix link yet or in the middle of an edge - remember the<br>&nbsp;&nbsp; &nbsp; &nbsp;edge between the node and its father (gama) and follow its father's suffix<br>&nbsp;&nbsp; &nbsp; &nbsp;link (it must have one by Ukkonen's lemma). After following, trace down <br>&nbsp;&nbsp; &nbsp; &nbsp;gama - it must exist in the tree (and thus can use the skip trick - see <br>&nbsp;&nbsp; &nbsp; &nbsp;trace_string function description) */<br>&nbsp;&nbsp; if(pos-&gt;node-&gt;suffix_link == 0 || is_last_char_in_edge(tree,pos-&gt;node,pos-&gt;edge_pos) == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* If the node's father is the root, than no use following it's link (it <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; is linked to itself). Tracing from the root (like in the naive <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; algorithm) is required and is done by the calling function SEA uppon <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; recieving a return value of tree-&gt;root from this function */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(pos-&gt;node-&gt;father == tree-&gt;root)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;node = tree-&gt;root;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Store gama - the indices of node's incoming edge */<br>&nbsp;&nbsp; &nbsp; &nbsp;gama.begin &nbsp; &nbsp; &nbsp;= pos-&gt;node-&gt;edge_label_start;<br>&nbsp;&nbsp; &nbsp; &nbsp;gama.end &nbsp; &nbsp; &nbsp;= pos-&gt;node-&gt;edge_label_start + pos-&gt;edge_pos;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Follow father's suffix link */<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;node &nbsp; &nbsp; &nbsp;= pos-&gt;node-&gt;father-&gt;suffix_link;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Down-walk gama back to suffix_link's son */<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;node &nbsp; &nbsp; &nbsp;= trace_string(tree, pos-&gt;node, gama, &amp;(pos-&gt;edge_pos), &amp;chars_found, skip);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* If a suffix link exists - just follow it */<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;node &nbsp; &nbsp; &nbsp;= pos-&gt;node-&gt;suffix_link;<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;edge_pos &nbsp; = get_node_label_length(tree,pos-&gt;node)-1;<br>&nbsp;&nbsp; }<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; create_suffix_link :<br>&nbsp;&nbsp; Creates a suffix link between node and the node 'link' which represents its <br>&nbsp;&nbsp; largest suffix. The function could be avoided but is needed to monitor the <br>&nbsp;&nbsp; creation of suffix links when debuging or changing the tree.<br><br>&nbsp;&nbsp; Input : The node to link from, the node to link to.<br><br>&nbsp;&nbsp; Output: None.<br>*/<br><br>void create_suffix_link(NODE* node, NODE* link)<br>{<br>&nbsp;&nbsp; node-&gt;suffix_link = link;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; SEA :<br>&nbsp;&nbsp; Single-Extension-Algorithm (see Ukkonen's algorithm). Ensure that a certain <br>&nbsp;&nbsp; extension is in the tree.<br><br>&nbsp;&nbsp; 1. Follows the current node's suffix link.<br>&nbsp;&nbsp; 2. Check whether the rest of the extension is in the tree.<br>&nbsp;&nbsp; 3. If it is - reports the calling function SPA of rule 3 (= current phase is <br>&nbsp;&nbsp; &nbsp; &nbsp;done).<br>&nbsp;&nbsp; 4. If it's not - inserts it by applying rule 2.<br><br>&nbsp;&nbsp; Input : The tree, pos - the node and position in its incoming edge where <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extension begins, str - the starting and ending indices of the <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extension, a flag indicating whether the last phase ended by rule 3 <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (last extension of the last phase already existed in the tree - and <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if so, the current phase starts at not following the suffix link of <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the first extension).<br><br>&nbsp;&nbsp; Output: The rule that was applied to that extension. Can be 3 (phase is done)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or 2 (a new leaf was created).<br>*/<br><br>void SEA(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SUFFIX_TREE* &nbsp; tree, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;POS* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PATH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp;rule_applied,<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after_rule_3)<br>{<br>&nbsp;&nbsp; DBL_WORD &nbsp; chars_found = 0 , path_pos = str.begin;<br>&nbsp;&nbsp; NODE* &nbsp; &nbsp; &nbsp;tmp;<br>&nbsp;<br>#ifdef DEBUG &nbsp; <br>&nbsp;&nbsp; ST_PrintTree(tree);<br>&nbsp;&nbsp; printf("extension: %lu &nbsp;phase+1: %lu",str.begin, str.end);<br>&nbsp;&nbsp; if(after_rule_3 == 0)<br>&nbsp;&nbsp;
&nbsp; &nbsp;printf(" &nbsp; followed from (%lu,%lu | %lu) ",
pos-&gt;node-&gt;edge_label_start,
get_node_label_end(tree,pos-&gt;node), pos-&gt;edge_pos);<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp;
&nbsp; &nbsp;printf(" &nbsp; starting at (%lu,%lu | %lu) ",
pos-&gt;node-&gt;edge_label_start,
get_node_label_end(tree,pos-&gt;node), pos-&gt;edge_pos);<br>#endif<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; counter++;<br>#endif<br><br>&nbsp;&nbsp; /* Follow suffix link only if it's not the first extension after rule 3 was applied */<br>&nbsp;&nbsp; if(after_rule_3 == 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;follow_suffix_link(tree, pos);<br><br>#ifdef DEBUG &nbsp; <br>#ifdef STATISTICS<br>&nbsp;&nbsp; if(after_rule_3 == 0)<br>&nbsp;&nbsp;
&nbsp; &nbsp;printf("to (%lu,%lu | %lu). counter: %lu\n",
pos-&gt;node-&gt;edge_label_start,
get_node_label_end(tree,pos-&gt;node),pos-&gt;edge_pos,counter);<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; &nbsp; &nbsp;printf(". counter: %lu\n", counter);<br>#endif<br>#endif<br><br>&nbsp;&nbsp; /* If node is root - trace whole string starting from the root, else - trace last character only */<br>&nbsp;&nbsp; if(pos-&gt;node == tree-&gt;root)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;node = trace_string(tree, tree-&gt;root, str, &amp;(pos-&gt;edge_pos), &amp;chars_found, no_skip);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;str.begin = str.end;<br>&nbsp;&nbsp; &nbsp; &nbsp;chars_found = 0;<br><br>&nbsp;&nbsp; &nbsp; &nbsp;/* Consider 2 cases:<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 1. last character matched is the last of its edge */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(is_last_char_in_edge(tree,pos-&gt;node,pos-&gt;edge_pos))<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Trace only last symbol of str, search in the &nbsp;NEXT edge (node) */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; tmp = find_son(tree, pos-&gt;node, tree-&gt;tree_string[str.end]);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(tmp != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pos-&gt;node &nbsp; &nbsp; &nbsp;= tmp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pos-&gt;edge_pos &nbsp; = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;chars_found &nbsp; &nbsp; &nbsp;= 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;/* 2. last character matched is NOT the last of its edge */<br>&nbsp;&nbsp; &nbsp; &nbsp;else<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Trace only last symbol of str, search in the CURRENT edge (node) */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(tree-&gt;tree_string[pos-&gt;node-&gt;edge_label_start+pos-&gt;edge_pos+1] == tree-&gt;tree_string[str.end])<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pos-&gt;edge_pos++;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;chars_found &nbsp; = 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; }<br><br>&nbsp;&nbsp; /* If whole string was found - rule 3 applies */<br>&nbsp;&nbsp; if(chars_found == str.end - str.begin + 1)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;*rule_applied = 3;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* If there is an internal node that has no suffix link yet (only one may <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; exist) - create a suffix link from it to the father-node of the <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; current position in the tree (pos) */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(suffixless != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; create_suffix_link(suffixless, pos-&gt;node-&gt;father);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Marks that no internal node with no suffix link exists */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; suffixless = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp; &nbsp;#ifdef DEBUG &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; printf("rule 3 (%lu,%lu)\n",str.begin,str.end);<br>&nbsp;&nbsp; &nbsp; &nbsp;#endif<br>&nbsp;&nbsp; &nbsp; &nbsp;return;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* If last char found is the last char of an edge - add a character at the <br>&nbsp;&nbsp; &nbsp; &nbsp;next edge */<br>&nbsp;&nbsp; if(is_last_char_in_edge(tree,pos-&gt;node,pos-&gt;edge_pos) || pos-&gt;node == tree-&gt;root)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Decide whether to apply rule 2 (new_son) or rule 1 */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(pos-&gt;node-&gt;sons != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Apply extension rule 2 new son - a new leaf is created and returned <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by apply_extension_rule_2 */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; apply_extension_rule_2(pos-&gt;node, str.begin+chars_found, str.end, path_pos, 0, new_son);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; *rule_applied = 2;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* If there is an internal node that has no suffix link yet (only one <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;may exist) - create a suffix link from it to the father-node of the <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current position in the tree (pos) */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(suffixless != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;create_suffix_link(suffixless, pos-&gt;node);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Marks that no internal node with no suffix link exists */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;suffixless = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Apply extension rule 2 split - a new node is created and returned by <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; apply_extension_rule_2 */<br>&nbsp;&nbsp; &nbsp; &nbsp;tmp = apply_extension_rule_2(pos-&gt;node, str.begin+chars_found, str.end, path_pos, pos-&gt;edge_pos, split);<br>&nbsp;&nbsp; &nbsp; &nbsp;if(suffixless != 0)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; create_suffix_link(suffixless, tmp);<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Link root's sons with a single character to the root */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(get_node_label_length(tree,tmp) == 1 &amp;&amp; tmp-&gt;father == tree-&gt;root)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;suffix_link = tree-&gt;root;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Marks that no internal node with no suffix link exists */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; suffixless = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;else<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Mark tmp as waiting for a link */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; suffixless = tmp;<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Prepare pos for the next extension */<br>&nbsp;&nbsp; &nbsp; &nbsp;pos-&gt;node = tmp;<br>&nbsp;&nbsp; &nbsp; &nbsp;*rule_applied = 2;<br>&nbsp;&nbsp; }<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; SPA :<br>&nbsp;&nbsp; Performs all insertion of a single phase by calling function SEA starting <br>&nbsp;&nbsp; from the first extension that does not already exist in the tree and ending <br>&nbsp;&nbsp; at the first extension that already exists in the tree. <br><br>&nbsp;&nbsp; Input :The tree, pos - the node and position in its incoming edge where <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extension begins, the phase number, the first extension number of that<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phase, a flag signaling whether the extension is the first of this <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phase, after the last phase ended with rule 3. If so - extension will <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be executed again in this phase, and thus its suffix link would not be<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;followed.<br><br>&nbsp;&nbsp; Output:The extension number that was last executed on this phase. Next phase <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;will start from it and not from 1<br>*/<br><br>void SPA(<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* The tree */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SUFFIX_TREE* &nbsp; &nbsp;tree, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Current node */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;POS* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pos, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Current phase number */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD &nbsp; &nbsp; &nbsp; &nbsp;phase, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* The last extension performed in the previous phase */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DBL_WORD* &nbsp; &nbsp; &nbsp; extension, &nbsp; &nbsp; &nbsp; &nbsp; <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* 1 if the last rule applied is 3 */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repeated_extension) &nbsp; <br>{<br>&nbsp;&nbsp; /* No such rule (0). Used for entering the loop */<br>&nbsp;&nbsp; DBL_WORD &nbsp; rule_applied = 0; &nbsp; <br>&nbsp;&nbsp; PATH &nbsp; &nbsp; &nbsp; str;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Leafs Trick: Apply implicit extensions 1 through prev_phase */<br>&nbsp;&nbsp; tree-&gt;e = phase+1;<br><br>&nbsp;&nbsp; /* Apply explicit extensions untill last extension of this phase is reached <br>&nbsp;&nbsp; &nbsp; &nbsp;or extension rule 3 is applied once */<br>&nbsp;&nbsp; while(*extension &lt;= phase+1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;str.begin &nbsp; &nbsp; &nbsp; = *extension;<br>&nbsp;&nbsp; &nbsp; &nbsp;str.end &nbsp; &nbsp; &nbsp; &nbsp; = phase+1;<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Call Single-Extension-Algorithm */<br>&nbsp;&nbsp; &nbsp; &nbsp;SEA(tree, pos, str, &amp;rule_applied, *repeated_extension);<br>&nbsp;&nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Check if rule 3 was applied for the current extension */<br>&nbsp;&nbsp; &nbsp; &nbsp;if(rule_applied == 3)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Signaling that the next phase's first extension will not follow a <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;suffix link because same extension is repeated */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; *repeated_extension = 1;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; break;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;*repeated_extension = 0;<br>&nbsp;&nbsp; &nbsp; &nbsp;(*extension)++;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_CreateTree :<br>&nbsp;&nbsp; Allocates memory for the tree and starts Ukkonen's construction algorithm by <br>&nbsp;&nbsp; calling SPA n times, where n is the length of the source string.<br><br>&nbsp;&nbsp; Input : The source string and its length. The string is a sequence of <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned characters (maximum of 256 different symbols) and not <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null-terminated. The only symbol that must not appear in the string <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is $ (the dollar sign). It is used as a unique symbol by the <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; algorithm ans is appended automatically at the end of the string (by <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the program, not by the user!). The meaning of the $ sign is <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connected to the implicit/explicit suffix tree transformation, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detailed in Ukkonen's algorithm.<br><br>&nbsp;&nbsp; Output: A pointer to the newly created tree. Keep this pointer in order to <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perform operations like search and delete on that tree. Obviously, no<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; de-allocating of the tree space could be done if this pointer is <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lost, as the tree is allocated dynamically on the heap.<br>*/<br><br>SUFFIX_TREE* ST_CreateTree(const char* str, DBL_WORD length)<br>{<br>&nbsp;&nbsp; SUFFIX_TREE* &nbsp;tree;<br>&nbsp;&nbsp; DBL_WORD &nbsp; &nbsp; &nbsp;phase , extension;<br>&nbsp;&nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;repeated_extension = 0;<br>&nbsp;&nbsp; POS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br><br>&nbsp;&nbsp; if(str == 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;return 0;<br><br>&nbsp;&nbsp; /* Allocating the tree */<br>&nbsp;&nbsp; tree = malloc(sizeof(SUFFIX_TREE));<br>&nbsp;&nbsp; if(tree == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("\nOut of memory.\n");<br>&nbsp;&nbsp; &nbsp; &nbsp;exit(0);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; heap+=sizeof(SUFFIX_TREE);<br><br>&nbsp;&nbsp; /* Calculating string length (with an ending $ sign) */<br>&nbsp;&nbsp; tree-&gt;length &nbsp; &nbsp; &nbsp; &nbsp; = length+1;<br>&nbsp;&nbsp; ST_ERROR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= length+10;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Allocating the only real string of the tree */<br>&nbsp;&nbsp; tree-&gt;tree_string = malloc((tree-&gt;length+1)*sizeof(char));<br>&nbsp;&nbsp; if(tree-&gt;tree_string == 0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("\nOut of memory.\n");<br>&nbsp;&nbsp; &nbsp; &nbsp;exit(0);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; heap+=(tree-&gt;length+1)*sizeof(char);<br><br>&nbsp;&nbsp; memcpy(tree-&gt;tree_string+sizeof(char),str,length*sizeof(char));<br>&nbsp;&nbsp; /* $ is considered a uniqe symbol */<br>&nbsp;&nbsp; tree-&gt;tree_string[tree-&gt;length] = '$';<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Allocating the tree root node */<br>&nbsp;&nbsp; tree-&gt;root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= create_node(0, 0, 0, 0);<br>&nbsp;&nbsp; tree-&gt;root-&gt;suffix_link = 0;<br><br>&nbsp;&nbsp; /* Initializing algorithm parameters */<br>&nbsp;&nbsp; extension = 2;<br>&nbsp;&nbsp; phase = 2;<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Allocating first node, son of the root (phase 0), the longest path node */<br>&nbsp;&nbsp; tree-&gt;root-&gt;sons = create_node(tree-&gt;root, 1, tree-&gt;length, 1);<br>&nbsp;&nbsp; suffixless &nbsp; &nbsp; &nbsp; = 0;<br>&nbsp;&nbsp; pos.node &nbsp; &nbsp; &nbsp; &nbsp; = tree-&gt;root;<br>&nbsp;&nbsp; pos.edge_pos &nbsp; &nbsp; = 0;<br><br>&nbsp;&nbsp; /* Ukkonen's algorithm begins here */<br>&nbsp;&nbsp; for(; phase &lt; tree-&gt;length; phase++)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Perform Single Phase Algorithm */<br>&nbsp;&nbsp; &nbsp; &nbsp;SPA(tree, &amp;pos, phase, &amp;extension, &amp;repeated_extension);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return tree;<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_DeleteSubTree :<br>&nbsp;&nbsp; Deletes a subtree that is under node. It recoursively calls itself for all of<br>&nbsp;&nbsp; node's right sons and then deletes node.<br><br>&nbsp;&nbsp;Input : The node that is the root of the subtree to be deleted.<br><br>&nbsp;&nbsp;Output: None.<br>*/<br><br>void ST_DeleteSubTree(NODE* node)<br>{<br>&nbsp;&nbsp; /* Recoursion stoping condition */<br>&nbsp;&nbsp; if(node == 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;return;<br>&nbsp;&nbsp; /* Recoursive call for right sibling */<br>&nbsp;&nbsp; if(node-&gt;right_sibling!=0)<br>&nbsp;&nbsp; &nbsp; &nbsp;ST_DeleteSubTree(node-&gt;right_sibling);<br>&nbsp;&nbsp; /* Recoursive call for first son */<br>&nbsp;&nbsp; if(node-&gt;sons!=0)<br>&nbsp;&nbsp; &nbsp; &nbsp;ST_DeleteSubTree(node-&gt;sons);<br>&nbsp;&nbsp; /* Delete node itself, after its whole tree was deleted as well */<br>&nbsp;&nbsp; free(node);<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_DeleteTree :<br>&nbsp;&nbsp; Deletes a whole suffix tree by starting a recoursive call to ST_DeleteSubTree<br>&nbsp;&nbsp; from the root. After all of the nodes have been deleted, the function deletes<br>&nbsp;&nbsp; the structure that represents the tree.<br><br>&nbsp;&nbsp; Input : The tree to be deleted.<br><br>&nbsp;&nbsp; Output: None.<br>*/<br><br>void ST_DeleteTree(SUFFIX_TREE* tree)<br>{<br>&nbsp;&nbsp; if(tree == 0)<br>&nbsp;&nbsp; &nbsp; &nbsp;return;<br>&nbsp;&nbsp; ST_DeleteSubTree(tree-&gt;root);<br>&nbsp;&nbsp; free(tree);<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_PrintNode :<br>&nbsp;&nbsp; Prints a subtree under a node of a certain tree-depth.<br><br>&nbsp;&nbsp; Input : The tree, the node that is the root of the subtree, and the depth of <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that node. The depth is used for printing the branches that are <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coming from higher nodes and only then the node itself is printed. <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This gives the effect of a tree on screen. In each recoursive call, <br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the depth is increased.<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; Output: A printout of the subtree to the screen.<br>*/<br><br>void ST_PrintNode(SUFFIX_TREE* tree, NODE* node1, long depth)<br>{<br>&nbsp;&nbsp; NODE* node2 = node1-&gt;sons;<br>&nbsp;&nbsp; long &nbsp;d = depth , start = node1-&gt;edge_label_start , end;<br>&nbsp;&nbsp; end &nbsp; &nbsp; = get_node_label_end(tree, node1);<br><br>&nbsp;&nbsp; if(depth&gt;0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Print the branches coming from higher nodes */<br>&nbsp;&nbsp; &nbsp; &nbsp;while(d&gt;1)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; printf("|");<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; d--;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("+");<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Print the node itself */<br>&nbsp;&nbsp; &nbsp; &nbsp;while(start&lt;=end)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; printf("%c",tree-&gt;tree_string[start]);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; start++;<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp;#ifdef DEBUG<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; printf(" &nbsp;\t\t\t(%lu,%lu | %lu)",node1-&gt;edge_label_start,end,node1-&gt;path_position);<br>&nbsp;&nbsp; &nbsp; &nbsp;#endif<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("\n");<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; /* Recoursive call for all node1's sons */<br>&nbsp;&nbsp; while(node2!=0)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;ST_PrintNode(tree,node2, depth+1);<br>&nbsp;&nbsp; &nbsp; &nbsp;node2 = node2-&gt;right_sibling;<br>&nbsp;&nbsp; }<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_PrintFullNode :<br>&nbsp;&nbsp; This function prints the full path of a node, starting from the root. It <br>&nbsp;&nbsp; calls itself recoursively and than prints the last edge.<br><br>&nbsp;&nbsp; Input : the tree and the node its path is to be printed.<br><br>&nbsp;&nbsp; Output: Prints the path to the screen, no return value.<br>*/<br><br>void ST_PrintFullNode(SUFFIX_TREE* tree, NODE* node)<br>{<br>&nbsp;&nbsp; long start, end;<br>&nbsp;&nbsp; if(node==NULL)<br>&nbsp;&nbsp; &nbsp; &nbsp;return;<br>&nbsp;&nbsp; /* Calculating the begining and ending of the last edge */<br>&nbsp;&nbsp; start &nbsp; = node-&gt;edge_label_start;<br>&nbsp;&nbsp; end &nbsp; &nbsp; = get_node_label_end(tree, node);<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; /* Stoping condition - the root */<br>&nbsp;&nbsp; if(node-&gt;father!=tree-&gt;root)<br>&nbsp;&nbsp; &nbsp; &nbsp;ST_PrintFullNode(tree,node-&gt;father);<br>&nbsp;&nbsp; /* Print the last edge */<br>&nbsp;&nbsp; while(start&lt;=end)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;printf("%c",tree-&gt;tree_string[start]);<br>&nbsp;&nbsp; &nbsp; &nbsp;start++;<br>&nbsp;&nbsp; }<br>}<br><br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_PrintTree :<br>&nbsp;&nbsp; This function prints the tree. It simply starts the recoursive function <br>&nbsp;&nbsp; ST_PrintNode with depth 0 (the root).<br><br>&nbsp;&nbsp; Input : The tree to be printed.<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; Output: A print out of the tree to the screen.<br>*/<br><br>void ST_PrintTree(SUFFIX_TREE* tree)<br>{<br>&nbsp;&nbsp; printf("\nroot\n");<br>&nbsp;&nbsp; ST_PrintNode(tree, tree-&gt;root, 0);<br>}<br><br>/******************************************************************************/<br>/*<br>&nbsp;&nbsp; ST_SelfTest :<br>&nbsp;&nbsp; Self test of the tree - search for all substrings of the main string. See <br>&nbsp;&nbsp; testing paragraph in the readme.txt file.<br><br>&nbsp;&nbsp; Input : The tree to test.<br><br>&nbsp;&nbsp; Output: 1 for success and 0 for failure. Prints a result message to the screen.<br>*/<br><br>DBL_WORD ST_SelfTest(SUFFIX_TREE* tree)<br>{<br>&nbsp;&nbsp; DBL_WORD k,j,i;<br><br>#ifdef STATISTICS<br>&nbsp;&nbsp; DBL_WORD old_counter = counter;<br>#endif<br><br>&nbsp;&nbsp; /* Loop for all the prefixes of the tree source string */<br>&nbsp;&nbsp; for(k = 1; k&lt;tree-&gt;length; k++)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp;/* Loop for each suffix of each prefix */<br>&nbsp;&nbsp; &nbsp; &nbsp;for(j = 1; j&lt;=k; j++)<br>&nbsp;&nbsp; &nbsp; &nbsp;{<br>#ifdef STATISTICS<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; counter = 0;<br>#endif<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /* Search the current suffix in the tree */<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; i = ST_FindSubstring(tree, (char*)(tree-&gt;tree_string+j), k-j+1);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; if(i == ST_ERROR)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n\nTest Results: Fail in string (%lu,%lu).\n\n",j,k);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp;&nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; }<br>#ifdef STATISTICS<br>&nbsp;&nbsp; counter = old_counter;<br>#endif<br>&nbsp;&nbsp; /* If we are here no search has failed and the test passed successfuly */<br>&nbsp;&nbsp; printf("\n\nTest Results: Success.\n\n");<br>&nbsp;&nbsp; return 1;<br>}<br><br><br>【 在 Key (关键时刻~) 的大作中提到: 】<br><span class="f006">: 这一篇给的应该是比较详细的过程了。不过我也想知道有没有现成的库可以调用，或者哪位大牛可以给段c或者python的应用代码，示范给大家学习学习那就太好了</span><br><span class="f006">: <a target="_blank" href="http://www.csse.monash.edu.au/%7Elloyd/tildeAlgDS/Tree/Suffix/">http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Suffix/</a></span><br><br><br>--<br><br>※ 来源:·水木社区 newsmth.net·[FROM: 193.54.50.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9902">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9902">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=elflord">elflord</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9902">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">6</div></div><div class="article" id="art9902">发信人: elflord (丛林精灵), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Thu Nov &nbsp;8 04:32:12 2007), 站内<br><br>here's another place that might be interesting for you<br><a target="_blank" href="http://www2.hawaii.edu/%7Echenx/alg/suffixtree/">http://www2.hawaii.edu/~chenx/alg/suffixtree/</a><br><br>【 在 elflord (丛林精灵) 的大作中提到: 】<br><span class="f006">: found it on google</span><br><span class="f006">: hope it's helpful</span><br><span class="f006">: /******************************************************************************</span><br><span class="f006">: ...................</span><br><br>--<br><br>※ 来源:·水木社区 newsmth.net·[FROM: 193.54.50.*]<br></div><br><div class="tconPager smaller left">[<a href="http://www.newsmth.net/bbscon.php?bid=1032&amp;id=9903">本篇全文</a>] [<a href="http://www.newsmth.net/bbspst.php?board=Algorithm&amp;reid=9903">回复文章</a>] [本篇作者：<a href="http://www.newsmth.net/bbsqry.php?userid=keerling">keerling</a>] [<a href="http://www.newsmth.net/bbspstmail.php?board=Algorithm&amp;id=9903">回信给作者</a>] [<a href="http://www.newsmth.net/bbsdoc.php?board=Algorithm">进入讨论区</a>] [<a href="http://www.newsmth.net/bbstcon.php?board=Algorithm&amp;gid=9886#top">返回顶部</a>]<div class="tnum">7</div></div>发信人: keerling (keer), 信区: Algorithm<br>标 &nbsp;题: Re: 求教大牛！关于后缀树<br>发信站: 水木社区 (Thu Nov &nbsp;8 09:14:30 2007), 站内<br><br>感谢大家的帮助，谢谢大家！<br><br><br>【 在 elflord (丛林精灵) 的大作中提到: 】<br><span class="f006">: here's another place that might be interesting for you</span><br><span class="f006">: <a target="_blank" href="http://www2.hawaii.edu/%7Echenx/alg/suffixtree/">http://www2.hawaii.edu/~chenx/alg/suffixtree/</a></span><br><br>