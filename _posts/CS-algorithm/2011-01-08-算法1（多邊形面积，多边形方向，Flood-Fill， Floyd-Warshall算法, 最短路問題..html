<div>算法1（多邊形面积，多边形方向，Flood-Fill， Floyd-Warshall算法, 最短路問題<br /><br />1） 多邊形面积<br />http://zh.wikipedia.org/zh-tw/%E5%A4%9A%E8%BE%B9%E5%BD%A2#.E9.9D.A2.E7.A7.AF<br /><div><h3><span id=".E9.9D.A2.E7.A7.AF">面積</span></h3> <p>對用<img alt="(x_1,y_1), (x_2,y_2), \dots , (x_n,y_n)" src="http://upload.wikimedia.org/math/d/8/6/d8665f7afc03a039393e60fba674f8e6.png" />（按逆時針排列）描述的多邊形，其面積為：</p> <dl><dd><img alt="A = \frac{1}{2} \left( \begin{vmatrix} x_1 &amp; y_1 \\ x_2 &amp; y_2 \end{vmatrix} + \begin{vmatrix} x_2 &amp; y_2 \\ x_3 &amp; y_3 \end{vmatrix} + \dots + \begin{vmatrix} x_n &amp; y_n \\ x_1 &amp; y_1 \end{vmatrix} \right)" src="http://upload.wikimedia.org/math/c/4/b/c4b80f2ba2e25ef327b54535bf7e64e8.png" /></dd></dl> <p>若按順時針排列，取負數即可。</p> <p>對用邊長<img alt="a_1, a_2, \dots , a_n" src="http://upload.wikimedia.org/math/7/a/a/7aaf8239aa023dd5e116e045ea26ebc6.png" />和外角<img alt="\theta_1, \theta_2, \dots ,\theta_n" src="http://upload.wikimedia.org/math/1/d/c/1dc7061850b906ab358c515673e09b57.png" />描述的多邊形，其面積為：</p> <dl><dd><img alt="\begin{align}A = \frac12 ( a_1[a_2 \sin(\theta_1) + a_3 \sin(\theta_1 + \theta_2) + \cdots + a_{n-1} \sin(\theta_1 + \theta_2 + \cdots + \theta_{n-2})] \\ {} + a_2[a_3 \sin(\theta_2) + a_4 \sin(\theta_2 + \theta_3) + \cdots + a_{n-1} \sin(\theta_2 + \cdots + \theta_{n-2})] \\ {} + \cdots + a_{n-2}[a_{n-1} \sin(\theta_{n-2})] ) \end{align}" src="http://upload.wikimedia.org/math/b/1/c/b1c72b33d267eb9f1caece94e029b84e.png" /></dd></dl> <p>用邊長和內角描述如下  N邊形S=&#8721;[(-1)^k*mnsin&#952;]/2這個代表N邊形已知（N-1）個邊的長度，而且知道其中任意兩邊的夾角，對於這兩邊 (-1)^k*mnsin&#952;求和後的一半便是面積 註明：K=0或1，目的是為了表明每個因式mnsin&#952;的正負號與M，N的交點位置有關</p></div><br />2） 判斷一個點是否在凸多邊形內部 射線演算法<br />多边形填充Polygon Filling ，flood fill算法，裝填凸多邊形（ Scanline Fill Algorithm ），裝填簡單多邊形參考： http://alienryderflex.com/polygon_fill/ 。原理與 Point in Polygon 的演算法是一樣的，另一種很常用的方式，是將簡單多邊形進行三角化，每個三角形各自裝填。，延伸閱讀： Pick's Theorem <br />http://www.csie.ntnu.edu.tw/~u91029/Polygon.html<br /><br />3） 判断多边形的方向是顺时针还是逆时针<br />http://hi.baidu.com/cityhacker/blog/item/ad9e1b82aba5cea50cf4d2a7.html<br /><div>取多边形的极点值，多边形的方向和这个顶点与其相邻两边构成的方向相同。</div><br />4） Flood-Fill 种子填充<br />http://hi.baidu.com/richardma_/blog/item/d688828b9e29c9be0f2444a9.html<br />问题描述<br />给出一个点，一张图，算法目的是将该点及其周围同颜色点的颜色替换为某种颜色<br /><br />算法描述<br /><br />Flood-fill（点坐标，目标颜色，替换颜色）<br />1. 如果坐标上的颜色不是目标颜色，则退出<br />2. 将坐标点设置为替换颜色<br />3. 递归调用Flood-fill，填充左侧坐标<br />递归调用Flood-fill，填充右侧坐标<br />递归调用Flood-fill，填充上方坐标<br />递归调用Flood-fill，填充下方坐标<br />4. 返回<br /><br />5） Floyd-Warshall算法（Floyd-Warshall algorithm）是解決任意兩點間的最短路徑的一種算法，可以正確處理有向圖或負權的最短路徑問題。<br />http://zh.wikipedia.org/zh-hk/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95<br /><div><p>Floyd-Warshall算法的原理是<a href="http://zh.wikipedia.org/zh-hk/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" title="動態規劃">動態規劃</a>。</p> <p>設<em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em></sub>為從<em>i</em>到<em>j</em>的只以(1..<em>k</em>)集合中的節點為中間節點的最短路徑的長度。</p> <ol><li>若最短路徑經過點k，則<em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em></sub> = <em>D</em><sub><em>i</em>,<em>k</em>,<em>k</em> &#8722; 1</sub> + <em>D</em><sub><em>k</em>,<em>j</em>,<em>k</em> &#8722; 1</sub>；</li><li>若最短路徑不經過點k，則<em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em></sub> = <em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em> &#8722; 1</sub>。</li></ol> <p>因此，<em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em></sub> = min(<em>D</em><sub><em>i</em>,<em>k</em>,<em>k</em> &#8722; 1</sub> + <em>D</em><sub><em>k</em>,<em>j</em>,<em>k</em> &#8722; 1</sub>,<em>D</em><sub><em>i</em>,<em>j</em>,<em>k</em> &#8722; 1</sub>)。</p> <p><br /> 在實際算法中，為了節約空間，可以直接在原來空間上進行迭代，這樣空間可降至二維。（見下面的算法描述）</p> <h2>[<a href="http://zh.wikipedia.org/w/index.php?title=%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95&amp;action=edit&amp;section=2" title="編輯段落: 算法描述">編輯</a>] <span id=".E7.AE.97.E6.B3.95.E6.8F.8F.E8.BF.B0">算法描述</span></h2> <p>Floyd-Warshall算法的描述如下：</p> <pre><strong>for</strong> k <strong>&#8592;</strong> 1 <strong>to</strong> n <strong>do</strong><br />  <strong>for</strong> i <strong>&#8592;</strong> 1 <strong>to</strong> n <strong>do</strong><br />    <strong>for</strong> j <strong>&#8592;</strong> 1 <strong>to</strong> n <strong>do</strong><br />      <strong>if</strong> (<em>D</em><sub><em>i</em>,<em>k</em></sub> + <em>D</em><sub><em>k</em>,<em>j</em></sub> &lt; <em>D</em><sub><em>i</em>,<em>j</em></sub>) <strong>then</strong><br />        <em>D</em><sub><em>i</em>,<em>j</em></sub> <strong>&#8592;</strong> <em>D</em><sub><em>i</em>,<em>k</em></sub> + <em>D</em><sub><em>k</em>,<em>j</em></sub>;<br /></pre> <p>其中<em>D</em><sub><em>i</em>,<em>j</em></sub>表示由點<em>i</em>到點<em>j</em>的代價，當<em>D</em><sub><em>i</em>,<em>j</em></sub>為 &#8734; 表示兩點之間沒有任何連接。</p></div></div><p>6） Dijkstra算法<br /><br />7） 最短路問題<br />http://zh.wikipedia.org/zh-hk/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF</p>