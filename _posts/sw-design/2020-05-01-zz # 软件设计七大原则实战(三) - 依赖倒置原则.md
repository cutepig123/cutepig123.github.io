---
categories: sw-design
---
# 软件设计七大原则实战(三) - 依赖倒置原则

[![JavaEdge](https://pic2.zhimg.com/v2-1b59899ebcbcdab177a1c13ef83b0dfa_xs.jpg)](https://www.zhihu.com/people/shi-shu-sheng-)

[JavaEdge](https://www.zhihu.com/people/shi-shu-sheng-)

唯爱与编程不可辜负

关注她

4 人赞同了该文章

## 1 定义

- Dependence Inversion Principle,DIP High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

![img](https://pic3.zhimg.com/80/v2-3fe5e827a0a2010a88a06da9ecb89dd2_720w.jpg)

高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块 在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的 细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。 依赖倒置原则在Java语言中的表现就是： ● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的； ● 接口或抽象类不依赖于实现类； ● 实现类依赖接口或抽象类。

更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

![img](https://pic2.zhimg.com/80/v2-5a8debd8826ae52ffd24d641e25d7349_720w.png)



## 2 实战

首先定义一个学习者类

![img](https://pic3.zhimg.com/80/v2-ec802861a32159684fc0716d0ddb09ee_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-a9c75060a8f0b6af2e216d9d114d9161_720w.jpg)

假如现在又想学习 py, 那么面向实现编程就是直接在类添加方法

![img](https://pic4.zhimg.com/80/v2-6465e2341831464b61d4766324b7749f_720w.jpg)

此类需要经常改变,扩展性很差,Test 高层模块, Geely 类为低层模块,耦合度过高 引入抽象

![img](https://pic2.zhimg.com/80/v2-1b334634acce7a3f52400c368fa7bc1d_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-9959b1f5368faef49353d02f6519cb7b_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-eedb568af9efd94fb930274a694316b5_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-01cc9beb1278cfdd72556edcfae9f467_720w.jpg)

于是就可以将原学习者类的方法都消除

![img](https://pic1.zhimg.com/80/v2-d815e73454dbc62fcd6dd4aa8bc04f98_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-5076b36f596a8eaa408e4496f6ec5652_720w.jpg)



## 3 言而无信，你太需要契约

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

证明一个定理是否正确，有两种常用的方法 - 根据提出的论题，经过一番论证，推出和定理相同的结论，这是顺推证法 - 首先假设提出的命题是伪命题，然后推导出一个荒谬、与已知条件互斥的结论，这是反证法

我们今天就用反证法来证明依赖倒置原则是多么优秀和伟大！

## 论题

依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

## 反论题

不使用依赖倒置原则也可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

我们通过一个例子来说明反论题是不成立的

![img](https://pic1.zhimg.com/80/v2-39ecb05ac554a3360b55da691ecc0004_720w.jpg)

奔驰车可以提供一个方法run，代表车辆运行，实现过程如代码清单3-1所示。

```text
public class Driver {      
     //司机的主要职责就是驾驶汽车
     public void drive(Benz benz){
             benz.run();
     }
}
```

司机通过调用奔驰车的run方法开动奔驰车

```text
public class Benz {
     //汽车肯定会跑
     public void run(){
             System.out.println("奔驰汽车开始运行...");
     }
}
```

有车，有司机，在Client场景类产生相应的对象

```text
public class Client {
     public static void main(String[] args) {
             Driver zhangSan = new Driver();
             Benz benz = new Benz();
             //张三开奔驰车
             zhangSan.drive(benz);
     }
}
```

我们在一段貌似磐石的程序上加上一块小石头：张三司机不仅要开奔驰车，还要开宝马车，又该怎么实现呢？麻烦出来了，那好，我们走一步是一步，我们先把宝马车产生出来

```text
public class BMW {
     //宝马车当然也可以开动了
     public void run(){
             System.out.println("宝马汽车开始运行...");
     }
}
```

宝马车也产生了，但是我们却没有办法让张三开动起来，为什么？张三没有开动宝马车的方法呀！一个拿有C驾照的司机竟然只能开奔驰车而不能开宝马车，这也太不合理了！在现实世界都不允许存在这种情况，何况程序还是对现实世界的抽象

我们的设计出现了问题：`司机类和奔驰车类之间是紧耦合的关系，其导致的结果就是系统的可维护性大大降低，可读性降低` 两个相似的类需要阅读两个文件，你乐意吗？还有稳定性，什么是稳定性？固化的、健壮的才是稳定的，这里只是增加了一个车类就需要修改司机类，这不是稳定性，这是易变性。 `被依赖者的变更竟然让依赖者来承担修改的成本，这样的依赖关系谁肯承担！` 证明到这里，我们已经知道反论题已经部分不成立了。

我们继续证明，`“减少并行开发引起的风险”` 什么是并行开发的风险？并行开发最大的风险就是风险扩散，本来只是一段程序的错误或异常，逐步波及一个功能，一个模块，甚至到最后毁坏了整个项目。为什么并行开发就有这样的风险呢？一个团队，20个开发人员，各人负责不同的功能模块，甲负责汽车类的建造，乙负责司机类的建造，在甲没有完成的情况下，乙是不能完全地编写代码的，缺少汽车类，编译器根本就不会让你通过！在缺少Benz类的情况下，Driver类能编译吗？更不要说是单元测试了！在这种不使用依赖倒置原则的环境中，所有的开发工作都是“单线程”的，甲做完，乙再做，然后是丙继续……这在20世纪90年代“个人英雄主义”编程模式中还是比较适用的，一个人完成所有的代码工作。但在现在的大中型项目中已经是完全不能胜任了，一个项目是一个团队协作的结果，一个“英雄”再牛也不可能了解所有的业务和所有的技术，要协作就要并行开发，要并行开发就要解决模块之间的项目依赖关系，那然后呢？依赖倒置原则就隆重出场了！

根据以上证明，如果不使用依赖倒置原则就会加重类间的耦合性，降低系统的稳定性，增加并行开发引起的风险，降低代码的可读性和可维护性。承接上面的例子，引入依赖倒置原则后的类图如图3-2所示。

建立两个接口：IDriver和ICar，分别定义了司机和汽车的各个职能，司机就是驾驶汽车，必须实现drive()方法

```text
public interface IDriver {
     //是司机就应该会驾驶汽车
     public void drive(ICar car);
}
```

接口只是一个抽象化的概念，是对一类事物的最抽象描述，具体的实现代码由相应的实现类来完成

```text
public class Driver implements IDriver{    
     //司机的主要职责就是驾驶汽车
     public void drive(ICar car){
             car.run();
     }
}
```

在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar接口，至于到底是哪个型号的Car，需要在高层模块中声明。

ICar及其两个实现类的实现过程

```text
public interface ICar {
     //是汽车就应该能跑
     public void run();
}

public class Benz implements ICar{
     //汽车肯定会跑
     public void run(){
             System.out.println("奔驰汽车开始运行...");
     }
}

public class BMW  implements ICar{      
     //宝马车当然也可以开动了
     public void run(){
             System.out.println("宝马汽车开始运行...");
     }
}
```

在业务场景中，我们贯彻“抽象不应该依赖细节”，也就是我们认为抽象（ICar接口）不依赖BMW和Benz两个实现类（细节），因此在高层次的模块中应用都是抽象

```text
public class Client {
     public static void main(String[] args) {
             IDriver zhangSan = new Driver();
             ICar benz = new Benz();
             //张三开奔驰车
             zhangSan.drive(benz);
     }
}
```

Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，zhangSan的表面类型是IDriver，Benz的表面类型是ICar，也许你要问，在这个高层模块中也调用到了低层模块，比如new Driver()和new Benz()等，如何解释？确实如此，zhangSan的表面类型是IDriver，是一个接口，是抽象的、非实体化的，在其后的所有操作中，zhangSan都是以IDriver类型进行操作，屏蔽了细节对抽象的影响。当然，张三如果要开宝马车，也很容易，我们只要修改业务场景类就可以

```text
public class Client {
     public static void main(String[] args) {
             IDriver zhangSan = new Driver();
             ICar bmw = new BMW();
             //张三开奔驰车
             zhangSan.drive(bmw);
     }
}
```

在新增加低层模块时，只修改了业务场景类，也就是高层模块，对其他低层模块如Driver类不需要做任何修改，业务就可以运行，把“变更”引起的风险扩散降到最低。

注意　在Java中，只要定义变量就必然要有类型，一个变量可以有两种类型：表面类型和实际类型，表面类型是在定义的时候赋予的类型，实际类型是对象的类型，如zhangSan的表面类型是IDriver，实际类型是Driver。

我们再来思考依赖倒置对并行开发的影响。两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了，而且项目之间的单元测试也可以独立地运行，而TDD（Test-Driven Development，测试驱动开发）开发模式就是依赖倒置原则的最高级应用。我们继续回顾上面司机驾驶汽车的例子，甲程序员负责IDriver的开发，乙程序员负责ICar的开发，两个开发人员只要制定好了接口就可以独立地开发了，甲开发进度比较快，完成了IDriver以及相关的实现类Driver的开发工作，而乙程序员滞后开发，那甲是否可以进行单元测试呢？答案是可以，我们引入一个JMock工具，其最基本的功能是根据抽象虚拟一个对象进行测试

测试类

```text
public class DriverTest extends TestCase{
     Mockery context = new JUnit4Mockery();
     @Test
     public void testDriver() {
             //根据接口虚拟一个对象
             final ICar car = context.mock(ICar.class);
             IDriver driver = new Driver();
             //内部类
             context.checking(new Expectations(){{
                      oneOf (car).run();        
             }});
             driver.drive(car);
     }
}
```

注意粗体部分，我们只需要一个ICar的接口，就可以对Driver类进行单元测试。从这一点来看，两个相互依赖的对象可以分别进行开发，孤立地进行单元测试，进而保证并行开发的效率和质量，TDD开发的精髓不就在这里吗？测试驱动开发，先写好单元测试类，然后再写实现类，这对提高代码的质量有非常大的帮助，特别适合研发类项目或在项目成员整体水平比较低的情况下采用。

抽象是对实现的约束，对依赖者而言，也是一种契约，不仅仅约束自己，还同时约束自己与外部的关系，其目的是保证所有的细节不脱离契约的范畴，确保约束双方按照既定的契约（抽象）共同发展，只要抽象这根基线在，细节就脱离不了这个圈圈，始终让你的对象做到“言必信，行必果”。

## 4 依赖的三种写法

依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止 `只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！`

对象的依赖关系有三种方式来传递

## 4.1 构造函数传递依赖对象

在类中通过构造函数声明依赖对象，`构造函数注入`

```text
public interface IDriver {
     //是司机就应该会驾驶汽车
     public void drive();
}
public class Driver implements IDriver{
     private ICar car;  

     //构造函数注入
     public Driver(ICar _car){
          this.car = _car;
     }

     //司机的主要职责就是驾驶汽车
     public void drive(){
             this.car.run();
     }
}
```

## 4.2 Setter方法传递依赖对象

在抽象中设置Setter方法声明依赖关系,`Setter依赖注入`

```text
public interface IDriver {
     //车辆型号
     public void setCar(ICar car);
     //是司机就应该会驾驶汽车
     public void drive();
}
public class Driver implements IDriver{
     private ICar car;  
     public void setCar(ICar car){
             this.car = car;
     }
     //司机的主要职责就是驾驶汽车
     public void drive(){
             this.car.run();
     }
}
```

## 4.3 接口声明依赖对象

在接口的方法中声明依赖对象

## 5 最佳实践

依赖倒置原则的本质就是`通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合` 我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以： - 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置

- 变量的表面类型尽量是接口或者是抽象类 很多书上说变量的类型一定要是接口或者是抽象类，这个有点绝对化了

- - 比如一个工具类，xxxUtils一般是不需要接口或是抽象类的
  - 如果你要使用类的clone方法，就必须使用实现类，这个是JDK提供的一个规范。

- 任何类都不应该从具体类派生 如果一个项目处于开发状态，确实不应该有从具体类派生出子类的情况，但这也不是绝对的，因为人都是会犯错误的，有时设计缺陷是在所难免的，因此只要不超过两层的继承都是可以忍受的

- 尽量不要覆写基类的方法 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写 类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响

- 结合里氏替换原则使用 父类出现的地方子类就能出现， 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。

那到底什么是“倒置”呢？ 我们先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑 而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的

依赖倒置原则是设计原则中最难以实现的，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭。 在项目中，大家只要记住是`面向接口编程`就基本上抓住了依赖倒置原则的核心。

发布于 2019-01-03