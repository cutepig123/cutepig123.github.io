<p>Ref https://doc.qt.io/archives/qq/qq16-dynamicqobject.html</p>
<p>Trolltech | Documentation | Qt Quarterly</p>
<p>Dynamic Signals and Slots<br />by Eskil Abrahamsen Blomfeldt</p>
<p>Signals and slots are declared at compile-time, and normally you cannot add new signals and slots to a meta-object at run-time. In some situations, it is useful to extend a meta-object while an application is running to obtain truly dynamic function invocation and introspection.<br />信号和曹在编译时期声明，通常你不能运行时添加新的信号槽到meta-object，但有时候你有需要</p>
<p>The need for the dynamic addition of signals and slots arises when binding a script interpreter, such as Qt Script for Applications (QSA), to the C++ code in your application. In QSA, it is possible to use Qt's meta-object system to communicate between objects created in the C++ code and objects created in a script. Qt 4's meta-object system makes this sort of extension possible, with a little bit of hackery.<br />当绑定脚本的时候就需要这个了，不如QSA里面可以利用 Qt's meta-object system 来使c++和script的object通讯。qt4系统上做点hack就能做到该功能</p>
<p>This article will get you started writing a dynamic signals and slots binding layer for Qt 4. We will review an abstract base class, DynamicQObject, that offers the required functionality. The "mini-framework" presented here can serve as a foundation for doing more advanced extensions of Qt's meta-object system.<br />本文告诉你怎办。我们会review一个虚基类DynamicQObject。本文的mini-framework可以作为扩展Qt's meta-object system的基础</p>
<p>[Download source code]</p>
<p>Expanding the Q_OBJECT Macro<br />扩展Q_OBJECT Macro<br />Any QObject subclass that declares signals and slots must contain the Q_OBJECT macro in its definition. This is a magic macro that expands to a set of private declarations:<br />任何QObject的类需要slot的必须声明Q_OBJECT，这个东西被扩展成如下几个声明<br />    // reimplemented from QObject<br />    const QMetaObject *metaObject() const;<br />    void *qt_metacast(const char *className);<br />    int qt_metacall(QMetaObject::Call call, int id,<br />                    void **arguments);<br />    <br />    // static members<br />    static QString tr(const char *sourceText,<br />                      const char *comment = 0);<br />    static QString trUtf8(const char *sourceText,<br />                          const char *comment = 0);<br />    static const QMetaObject staticMetaObject;<br />Q_OBJECT is "magic" because qmake and moc will recognize it and automagically generate code for the class's meta-object during compilation of the project.<br />Q_OBJECT的魔术之处在于qmake and moc认识他，并且自动生成class的meta-object</p>
<p>We want to write a DynamicQObject class that mimics part of the behavior of the moc but that does not limit us to statically declared signals and slots. Since we need to prevent the moc from compiling our class, we can't use the Q_OBJECT macro; instead, we will copy its definition and insert it into our code.<br />我们需要编写DynamicQObject class实现部分的moc功能，我们首先把该macro的定义插入到代码</p>
<p>The Q_OBJECT macro is defined in src/corelib/kernel/qobjectdefs.h (which is included by &lt;QObject&gt;). It declares a number of functions that must be reimplemented to fully support Qt's meta-object system. For the purposes of this article, it will be sufficient to reimplement just one of these functions:<br />我们需要重写如下函数<br />    int qt_metacall(QMetaObject::Call call, int id,<br />                    void **arguments);<br />When a signal is emitted, Qt uses qt_metacall() to invoke the slots connected to the signal. The first parameter, call, is then set to QMetaObject::InvokeMetaMethod. (The qt_metacall() function is also used for other types of access to the meta-object, such as setting or getting properties.)<br />当一个信号emit的时候，qt_metacall用来invoke 对应的slot，第一个参数，call，指向QMetaObject::InvokeMetaMethod</p>
<p>The second parameter is an index that uniquely identifies a signal or slot in the hierarchy of classes inherited by the current object. The last parameter is an array that contains pointers to arguments, preceded by a pointer to the location where the return value should be placed (if any).<br />第二个参数是signal or slot在该class的唯一index。最后一个参数是数组，指向参数以及返回值</p>
<p>The DynamicQObject Class Definition<br />Here's the definition of the DynamicQObject class:</p>
<p>    class DynamicQObject : public QObject<br />    {<br />    public:<br />        int qt_metacall(QMetaObject::Call call, int id,<br />                        void **arguments);<br />        bool emitDynamicSignal(char *signal);<br />        bool connectDynamicSlot(QObject *obj, char *signal,<br />                                char *slot);<br />        bool connectDynamicSignal(char *signal, QObject *obj,<br />                                  char *slot);<br />    <br />        virtual DynamicSlot *createSlot(char *slot) = 0;<br />    <br />    private:<br />        QHash&lt;QByteArray, int&gt; slotIndices;<br />        QList&lt;DynamicSlot *&gt; slotList;<br />        QHash&lt;QByteArray, int&gt; signalIndices;<br />    };<br />The intended usage pattern of DynamicQObject involves subclassing it and adding some functionality. Whenever we add a slot to an object, we would expect this slot to execute code when it is called. Since this part of the mechanism is dependent on the language to which we want to bind, it must be implemented in a subclass.<br />DynamicQObject的使用方法为子类可以添加功能。当添加slot时，希望slot被调用时执行code<br />The pure virtual function createSlot() returns an instance of an appropriate subclass of the abstract class DynamicSlot that handles function invocation for your specific language binding. DynamicSlot is defined as follows:<br />纯虚函数createSlot返回合适的DynamicSlot的子类。DynamicSlot定义为<br />    class DynamicSlot<br />    {<br />    public:<br />        virtual void call(void **arguments) = 0;<br />    };<br />DynamicSlot subclasses must reimplement the call() function to handle a slot invocation. The arguments array's first entry is a pointer to a location where we can put the return value. This pointer is null if the signal's return type is void.<br />DynamicSlot必须实现call函数来实现slot的执行，其参数为返回值的指针</p>
<p>The rest of the array contains pointers to arguments passed to the slot, in order of declaration. We must cast these pointers to the correct data types before we can use them. For example, if the slot expects a parameter of type int as its first parameter, the following code would be safe:<br />数组的其他参数为指向slot的参数。我们必须cast指针为真实的数据类型<br />    int *ptr = reinterpret_cast&lt;int *&gt;(arguments[1]);<br />    qDebug() &lt;&lt; "My first parameter is" &lt;&lt; *ptr;<br />Implementation of connectDynamicSlot()<br />实现connectDynamicSlot<br />The connectDynamicSlot() function connects a static signal declared in an arbitrary QObject instance to a dynamic slot in the current DynamicQObject instance. The function takes a pointer to the sender object (the receiver is always this) and the signatures of the signal and slot. The function returns false on error.<br />connectDynamicSlot用来链接任意QObject的signal到dynamic slot，该函数接受sender指针和signatures of the signal and slot<br />    bool DynamicQObject::connectDynamicSlot(QObject *obj,<br />                                            char *signal,<br />                                            char *slot)<br />    {<br />        QByteArray theSignal =<br />            QMetaObject::normalizedSignature(signal);<br />        QByteArray theSlot =<br />            QMetaObject::normalizedSignature(slot);<br />        if (!QMetaObject::checkConnectArgs(theSignal,<br />                                           theSlot))<br />            return false;<br />The first step is to normalize the signatures passed to the function. This will remove meaningless whitespace in the signatures, making it possible for us to recognize them. Then, we check whether the signatures are compatible, to avoid crashes later.<br />第一步normalize signatures，比如除掉无用空格。然后检查signatures是否兼容<br />      int signalId =<br />                  obj-&gt;metaObject()-&gt;indexOfSignal(theSignal);<br />        if (signalId == -1)<br />            return false;<br />If the argument lists are compatible for the two functions, we can start resolving the signal and slot indexes. The signal is resolved using introspection into the provided QObject object. If the signal was not found, we return false.<br />这里开始解析signal and slot indexes。如果找不到index返回false<br />Resolving the (dynamic) slot is a bit more work:<br />解析(dynamic) slot 是俺们自己写的code啦：<br />      int slotId = slotIndices.value(theSlot, -1);<br />        if (slotId == -1) {<br />            slotId = slotList.size();<br />            slotIndices[theSlot] = slotId;<br />            slotList.append(createSlot(theSlot));<br />        }<br />We check whether the slot signature has been registered before in the same DynamicQObject instance. If it hasn't, we add it to our list of dynamic slots.<br />如果没有就创建一个并且加入进去<br />We use a QHash&lt;QByteArray, int&gt; called slotIndices and a QList&lt;DynamicSlot *&gt; called slotList to store the information needed for the dynamic slots.</p>
<p>      QMetaObject::connect(obj, signalId, this,<br />               slotId + QObject::metaObject()-&gt;methodCount());<br />    }<br />Finally, we register the connection with Qt's meta-object system. When we notify Qt about the connection, we must add the number of methods inherited from QObject to our slotId.<br />最终我们注册connection到Qt's meta-object system。我们需要人为制造一个slotid给它<br />The connectDynamicSignal() function is very similar to connectDynamicSlot(), so we won't review it here.</p>
<p>Implementation of qt_metacall()<br />qt_metacall的实现<br />Qt's meta-object system uses the qt_metacall() function to access the meta-information for a particular QObject object (its signals, slots, properties, etc.).<br />qt_metacall函数用来访问QObject的meta-information（比如signals, slots, properties）<br />    int DynamicQObject::qt_metacall(QMetaObject::Call call,<br />                                    int id, void **arguments)<br />    {<br />        id = QObject::qt_metacall(call, id, arguments);<br />        if (id == -1 || call != QMetaObject::InvokeMetaMethod)<br />            return id;<br />    <br />        Q_ASSERT(id &lt; slotList.size());<br />        slotList[id]-&gt;call(arguments);<br />        return -1;<br />    }<br />Since the call may indicate access to the meta-object of the QObject base class, we must start by calling QObject's implementation of the function. This call will return a new identifier for the slot, indexing the methods in the upper part of the current object's class hierarchy (the current class and its subclasses).<br />首先执行QObject的实现，该函数返回slot的新id<br />If the QObject::qt_metacall() call returns -1, this means that the metacall has been handled by QObject and that there is nothing to do. In that case, we return immediately. Similarly, if the metacall isn't a slot invocation, we follow QObject's convention and return an identifier that can be handled by a subclass.<br />如果返回-1，说明QObject处理过了，我们直接返回。类似，如果metacall不是slot invocation，我们follow QObject's convention，返回子类处理的id'<br />In the case of a slot invocation, the identifier must be a valid identifier for the DynamicQObject object. We don't allow subclasses to declare their own signals and slots.<br />如果是slot invocation，则id必须是DynamicQObject的有效id，我们不允许子类声明他自己的signals and slots.<br />If all goes well, we invoke the specified slot (using DynamicSlot::call()) and return -1 to indicate that the metacall has been processed.<br />如果都ok，则invokespecified slot (using DynamicSlot::call()) ，返回-1表明已经处理过了<br />Implementation of emitDynamicSignal()<br />emitDynamicSignal的实现<br />The last function we need to review is emitDynamicSignal(), which takes a dynamic signal signature and an array of arguments. The function normalizes the signature then emits the signal, invoking any slots connected to it.<br />emitDynamicSignal的参数包括一个动态signal signature和参数数组。<br />    bool DynamicQObject::emitDynamicSignal(char *signal,<br />                                           void **arguments)<br />    {<br />        QByteArray theSignal =<br />                QMetaObject::normalizedSignature(signal);<br />        int signalId = signals.value(theSignal, -1);<br />        if (signalId &gt;= 0) {<br />            QMetaObject::activate(this, metaObject(),<br />                                  signalId, arguments);<br />            return true;<br />        } else {<br />            return false;<br />        }<br />    }<br />The arguments array can be assumed to contain valid pointers. A simple example of how to do this can be found in the accompanying example's source code, but as a general rule, QMetaType::construct() is your friend when you are doing more advanced bindings.</p>
<p>If the (dynamic) signal exists (i.e., it has been connected to a slot), the function simply uses QMetaObject::activate() to tell Qt's meta-object system that a signal is being emitted. It returns true if the signal has previously been connected to a slot; otherwise it returns false.<br />如果(dynamic) signal 存在，函数调用QMetaObject::activate来告诉Qt's meta-object system一个信号已经触发。如果signal已经连到slot，返回true；否则返回false</p>
<p>Pitfalls and Pointers<br />Having explained the architecture of this simple framework, I'd like to conclude by explaining what the framework doesn't do and how you can expand on it or improve it to suit your needs.</p>
<p>Only a subset of the features in Qt's meta-object system is supported by DynamicQObject. Ideally, we would reimplement all the functions declared by the Q_OBJECT macro.<br />Declaring new signals and slots in DynamicQObject subclasses will cause an application to crash. The reason for this is that the meta-object system expects the number of methods declared in a meta-object to be static. A safer workaround would be to use a different pattern than inheritance to employ dynamic signals and slots.<br />The framework is sensitive to misspellings. For instance, if you try to connect two distinct signals to the same dynamic slot and misspell the signature of the slot in one of the connect calls, the framework will create two separate slots instead of indicating a failure. To handle this in a safer way, you could implement a register() function and require the user to register each signal and slot before connecting to them.<br />The framework cannot handle connections where both the signals and the slot are dynamic. This can easily be written as an extension of the DynamicQObject class.<br />Removing connections is not possible with the current framework. This can easily be implemented in a similar way to establishing connections. Make sure not to change the order of entries in slotList, because the list is indexed by slot ID.<br />In real-world applications, you may need to do type conversions before passing parameters between functions declared in scripts and functions declared in C++. The DynamicQObject class can be expanded to handle this in a general way by declaring a set of virtual functions that can be reimplemented for different bindings.<br />       This document is licensed under the Creative Commons Attribution-Share Alike 2.5 license.<br />Copyright ? 2006 Trolltech	Trademarks</p>