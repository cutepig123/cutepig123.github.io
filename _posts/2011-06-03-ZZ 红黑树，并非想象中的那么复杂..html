<br />
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td></td>
<td width="100%">
<div class="msg wdth100" id="msg_017ec6a083c0d14e" style="margin: 0pt -1px;">
<div id="body" class="mb cb fontsize2 ">
<div id="inbdy"><br />
<p>把一年前写的红黑树一章重新写了一遍。红黑树是非常popular的一种self-adjusted的平衡二叉排序树。 </p>
<p>通常他给我们的印象是很复杂，有很多case，要小心的旋转。TL上曾经有人说，在某公司的面试时，被要求实现红黑树。他觉得这很没有道理，几乎很少有 <br /> 人能在不参考教科书的情况下，记清楚那么多的case。 </p>
<p>在这一章里，我将向你展示目前我所见过的最简洁的红黑树实现。简洁到什么程度呢？我打赌你看过后能轻松通过上面的面试&mdash;&mdash;Wow, 红黑树原来可以这么 <br /> 简单！ </p>
<p>这个实现，来自Chris Okasaki在卡耐基梅隆大学(CMU)的博士研究成果。他启发我用同样的方法简洁地实现了AVL tree和 <br /> Splay tree。 </p>
<p>这一章我们讲红黑树，大致内容如下： <br /> &nbsp; 1. 简介&mdash;&mdash;我们看看普通的排序二叉树致命弱点，并且给出树旋转的概念； <br /> &nbsp; 2. 红黑树的定义&mdash;&mdash;我们看看为什么红黑树的性质能解决平衡问题，从而胜过排序二叉树； <br /> &nbsp; 3. 插入&mdash;&mdash;我们给出红黑树插入算法的数学定义，这里是本章的精华； <br /> &nbsp; 4. 删除&mdash;&mdash;删除本来不是个问题，但是我们要展示下删除比起插入有多复杂； <br /> &nbsp; 6. 传统实现&mdash;&mdash;我们看看传统实现的红黑树插入算法有多复杂，并做进一步的比较分析；传统实现的删除算法我们留作练习。 <br /> &nbsp; 7. 其他&mdash;&mdash;多说两句 </p>
<p>全文在 <br /> <a target="_blank" rel="nofollow" href="http://www.google.com/url?sa=D&amp;q=https://sites.google.com/site/algoxy/rbtree">https://sites.google.com/site/algoxy/rbtree</a> </p>
<p>由于google site国内访问不到，所以我放了一份在iteye的附件里。 <br /> <a target="_blank" rel="nofollow" href="http://www.google.com/url?sa=D&amp;q=http://liuxinyu95.iteye.com/blog/1068508">http://liuxinyu95.iteye.com/blog/1068508</a> </p>
<p>全部源代码在github可以获得： <br /> <a target="_blank" rel="nofollow" href="http://www.google.com/url?sa=D&amp;q=https://github.com/liuxinyu95/AlgoXY">https://github.com/liuxinyu95/AlgoXY</a> </p>
</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
﻿