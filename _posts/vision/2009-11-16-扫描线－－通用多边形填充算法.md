---
categories: vision
---
扫描线－－通用多边形填充算法<br />该算法有几个可学习的地方：<br />（1）正负1思想<br />（2）对边界条件的处理<br />（3）数据结构的选择<br /><br />code:<br />sweep.h<br /><br />#ifndef SWEEP_H<br />#define SWEEP_H<br /><br />struct Edge {<br />&nbsp;&nbsp;&nbsp; int nxty;<br />&nbsp;&nbsp;&nbsp; int curx;<br />&nbsp;&nbsp;&nbsp; int dx, dy; // 所在扫描线的增量<br />&nbsp;&nbsp;&nbsp; Edge *nxt;<br />};<br /><br />//扫描线主算法<br />void sweep(int p[][2], int n, void (*setPixel)(int, int));<br />#endifsweep.cpp<br />#include "sweep.h"<br />#include &lt;algorithm&gt;<br />using namespace std;<br /><br />const int MAXN = 1024;<br /><br />int cp[MAXN][2], n;<br />inline bool cmp(int i, int j) {<br />&nbsp;&nbsp;&nbsp; return cp[i][1] &lt; cp[j][1] || (cp[i][1] == cp[j][1] &amp;&amp; cp[i][0] &lt; cp[j][0]);<br />}<br /><br /><br />Edge * e[MAXN], *h, *ph, *data;<br />void insert(int ly, int px, int ind) {<br />&nbsp;&nbsp;&nbsp; int y1,y2,y, nxt, pre, flag=0;<br /><br />&nbsp;&nbsp;&nbsp; nxt = (ind + 1) % n; pre = (ind - 1 + n) % n;<br />&nbsp;&nbsp;&nbsp; y = cp[ind][1]; y1 = cp[nxt][1]; y2 = cp[pre][1];<br />&nbsp;&nbsp;&nbsp; if (y1 &gt; y2) swap(y1, y2);<br />&nbsp;&nbsp;&nbsp; if (y1 &lt; y &amp;&amp; y &lt; y2) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //需缩短一个单位<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag = 1;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; h = e[ly]; ph=NULL;<br />&nbsp;&nbsp;&nbsp; while (h) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (h-&gt;dy &gt; cp[ind][1] || (h-&gt;dy == cp[ind][1] &amp;&amp; h-&gt;dx &gt; cp[ind][0])) break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ph = h;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = h-&gt;nxt;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp; data = new Edge;<br />&nbsp;&nbsp;&nbsp; data-&gt;curx = px; data-&gt;nxty = cp[ind][1]; data-&gt;dx = cp[ind][0] - px; data-&gt;dy = cp[ind][1] - ly; data-&gt;nxt = NULL;<br />&nbsp;&nbsp;&nbsp; if (flag) data-&gt;nxty--;<br /><br />&nbsp;&nbsp;&nbsp; if (ph) {&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;nxt = ph-&gt;nxt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ph-&gt;nxt = data;<br />&nbsp;&nbsp;&nbsp; } else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;nxt = e[ly];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e[ly] = data;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; &nbsp;<br /><br />}<br /><br />int ex[MAXN][MAXN], ne[MAXN];<br />inline int abs(int a) {<br />&nbsp;&nbsp;&nbsp; return a &gt; 0 ? a : -a;<br />}<br />void makepoint(int line, Edge *h) {<br />&nbsp;&nbsp;&nbsp; int dx = h-&gt;dx, dy = h-&gt;dy, cnt=0;<br />&nbsp;&nbsp;&nbsp; int x, y, flag=1;<br />&nbsp;&nbsp;&nbsp; if ((h-&gt;dx)*(h-&gt;dy)&lt;0) flag=0;<br />&nbsp;&nbsp;&nbsp; for (y=line, x=h-&gt;curx; y&lt;=h-&gt;nxty; y++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ex[y][ne[y]++] = x;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt += 2*abs(dx);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (cnt&gt;=2*abs(dy)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt -= 2*abs(dy);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (flag) x++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else x--;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />void sweep(int p[][2], int nn, void (*setPixel)(int, int)) {<br />&nbsp;&nbsp;&nbsp; //对所有点按y坐标递增排序,y坐标相等的按x坐标递增排序<br />&nbsp;&nbsp;&nbsp; n = nn;<br />&nbsp;&nbsp;&nbsp; int i, j, k, ind, nxt, pre;<br />&nbsp;&nbsp;&nbsp; int *num = new int[n];&nbsp;&nbsp;&nbsp; //点索引;<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++) num[i] = i;<br />&nbsp;&nbsp;&nbsp; memcpy(cp, p, sizeof(cp));<br />&nbsp;&nbsp;&nbsp; sort(num, num+n, cmp);<br /><br />&nbsp;&nbsp;&nbsp; //建立有序边表<br />&nbsp;&nbsp;&nbsp; memset(e, 0, sizeof(e));<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ind = num[i]; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nxt = (ind + 1) % n; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pre = (ind - 1 + n) % n;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p[nxt][1] &gt; p[ind][1]) insert(p[ind][1], p[ind][0], nxt);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p[pre][1] &gt; p[ind][1]) insert(p[ind][1], p[ind][0], pre);<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; //处理active edge list<br />&nbsp;&nbsp;&nbsp; memset(ne, 0, sizeof(ne));<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;MAXN; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = e[i]; ph = NULL;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (h) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makepoint(i, h);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = h-&gt;nxt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort(ex[i], ex[i]+ne[i]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=0; j&lt;ne[i]; j+=2) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (k=ex[i][j]; k&lt;=ex[i][j+1]; k++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setPixel(k,i);<br />&nbsp;&nbsp;&nbsp; }<br /><br />}sweepline.cpp<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;GL/glut.h&gt;<br />#include "sweep.h"<br /><br />void myInit();<br /><br />void setPixel(int x, int y);<br /><br />void myDisplay();<br /><br />int main(int argc, char **argv) {<br />&nbsp;&nbsp;&nbsp; glutInit(&amp;argc, argv);<br />&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br />&nbsp;&nbsp;&nbsp; glutInitWindowSize(640, 480);<br />&nbsp;&nbsp;&nbsp; glutInitWindowPosition (100, 150);<br />&nbsp;&nbsp;&nbsp; glutCreateWindow("SweepLine");<br />&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);<br />&nbsp;&nbsp;&nbsp; myInit();<br />&nbsp;&nbsp;&nbsp; glutMainLoop();<br />&nbsp;&nbsp;&nbsp; return 0;<br />}<br /><br /><br />void setPixel(int x, int y) {<br />&nbsp;&nbsp;&nbsp; glBegin(GL_POINTS);<br />&nbsp;&nbsp;&nbsp; glVertex2i(x, y);<br />&nbsp;&nbsp;&nbsp; glEnd();<br />}<br /><br />void myInit() {<br />&nbsp;&nbsp;&nbsp; glClearColor(1.0, 1.0, 1.0, 0.0);<br />&nbsp;&nbsp;&nbsp; glColor3f(0.0, 0.0, 0.0);<br />&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br />&nbsp;&nbsp;&nbsp; glLoadIdentity();<br />&nbsp;&nbsp;&nbsp; gluOrtho2D(0.0, 640.0, 0.0, 480.0);<br />}<br /><br /><br />void myDisplay() {<br />&nbsp;&nbsp;&nbsp; int i, j;<br />&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br />&nbsp;&nbsp;&nbsp; int p[5][2];<br />&nbsp;&nbsp;&nbsp; p[0][0] = 100; p[0][1] = 300;<br />&nbsp;&nbsp;&nbsp; p[1][0] = 200; p[1][1] = 50;<br />&nbsp;&nbsp;&nbsp; p[2][0] = 300; p[2][1] = 100;<br />&nbsp;&nbsp;&nbsp; p[3][0] = 400; p[3][1] = 0;<br />&nbsp;&nbsp;&nbsp; p[4][0] = 350; p[4][1] = 470;<br />&nbsp;&nbsp;&nbsp; sweep(p, 5, setPixel);<br />&nbsp;&nbsp;&nbsp; glFlush();<br />} <br /><br />http://zhidao.baidu.com/question/40582214.html