<p>一般情况下，I/O 复用机制需要<strong>事件分享器</strong>(event demultiplexor [<a href="http://blog.jobbole.com/59676/#resources">1</a>、<a href="http://blog.jobbole.com/59676/#resources">3</a>])。 事件分享器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁的什么东西送了， 快来拿吧。开发人员在开始的时候需要在分享器那里注册感兴趣的事件，并提供相应的处理者(event handlers)，或者是回调函数; 事件分享器在适当的时候会将请求的事件分发给这些handler或者回调函数。</p>
<p>涉及到事件分享器的两种模式称为：Reactor and Proactor [<a href="http://blog.jobbole.com/59676/#resources">1</a>]。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。 在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>而在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作(称有overlapped的技术)，事件分离者等IOCompletion事件完成[<a href="http://blog.jobbole.com/59676/#resources">1</a>]。 这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为&ldquo;系统级别&rdquo;的或者&ldquo;真正意义上&rdquo;的异步，因为具体的读写是由操作系统代劳的。</p>