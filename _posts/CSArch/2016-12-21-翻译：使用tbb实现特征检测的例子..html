<h1 id="page-title" class="page__title title">A feature-detection example using the Intel&reg; Threading Building Blocks flow graph</h1>
<div class="submitted-and-translation clearfix">
<p class="submitted"><span class="user-picture"><a title="View user profile." href="https://software.intel.com/en-us/user/191983"><img title="Michael V. (Intel)'s picture" src="https://software.intel.com/sites/default/files/styles/thumbnail/public/user/7/e/6/10644370.jpg?itok=8xa2pG5L" alt="Michael V. (Intel)'s picture" /></a><span>By&nbsp;<a class="username" title="View user profile" href="https://software.intel.com/en-us/user/191983">Michael V. (Intel)</a>, Added&nbsp;September 9, 2011</span></span></p>
&nbsp;
<div id="translation_button">
<div class="selectricWrapper notranslate select-fancy bing-translate-style selectricResponsive">
<div class="selectricHideSelect"><select id="bing-language-list" class="notranslate select-fancy bing-translate-style" tabindex="0">
<option value="0">Translate</option>
<option value="zh-chs">Chinese Simplified</option>
<option value="zh-cht">Chinese Traditional</option>
<option value="en">English</option>
<option value="fr">French</option>
<option value="de">German</option>
<option value="it">Italian</option>
<option value="pt">Portuguese</option>
<option value="ru">Russian</option>
<option value="es">Spanish</option>
<option value="tr">Turkish</option>
</select></div>
<div class="selectric">
<p class="label">Translate</p>
</div>
<input class="selectricInput" tabindex="0" type="text" /></div>
</div>
<div class="disclaimer">&nbsp;</div>
</div>
<div class="social-share notranslate">
<div class="item-list">
<ul>
<li class="facebook first"><a class="icon-logo-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://software.intel.com/en-us/blogs/2011/09/09/a-feature-detection-example-using-the-intel-threading-building-blocks-flow-graph" target="_blank">Share</a></li>
&nbsp;
<li class="twitter"><a class="icon-logo-twitter-bird" href="https://twitter.com/intent/tweet?text=A+feature-detection+example+using+the+Intel%C2%AE+Threading+Building+Blocks+flow+graph%3A&amp;url=https%3A%2F%2Fsoftware.intel.com%2Fen-us%2Fblogs%2F2011%2F09%2F09%2Fa-feature-detection-example-using-the-intel-threading-building-blocks-flow-graph&amp;hashtags=IntelSoftware" target="_blank" data-hashtags="IntelSoftware" data-text="A feature-detection example using the Intel&reg; Threading Building Blocks flow graph:" data-url="https://software.intel.com/en-us/blogs/2011/09/09/a-feature-detection-example-using-the-intel-threading-building-blocks-flow-graph">Tweet</a></li>
&nbsp;
<li class="google last"><a class="icon-logo-gplus" href="https://plus.google.com/share?url=https://software.intel.com/en-us/blogs/2011/09/09/a-feature-detection-example-using-the-intel-threading-building-blocks-flow-graph" target="_blank">Share</a></li>
</ul>
</div>
</div>
<div class="field field-name-body field-type-text-with-summary field-label-hidden">
<div class="field-items">
<div class="field-item even">
<p>The Intel&reg; Threading Building Blocks ( Intel&reg; TBB )&nbsp; flow graph is fully supported in Intel&reg; TBB 4.0.&nbsp; If you are unfamiliar with the flow graph, you can read an introduction&nbsp;<a href="https://software.intel.com/en-us/blogs/2011/09/08/the-intel-threading-building-blocks-flow-graph-is-now-fully-supported" rel="nofollow">here</a>.<br /><br />Figure 1 below shows&nbsp;a flow graph that implements a simple feature detection application. A number of images will enter the graph and two alternative feature detection algorithms will be applied to each one. If either algorithm detects a feature of interest, the image will be stored for later inspection. In this article, I&rsquo;ll describe each node used in this graph, and then provide and described a complete working implementation.<br /><br /><a href="https://software.intel.com/sites/default/files/m/c/5/4/recog_picture.bmp" rel="nofollow"><img title="recog_picture" src="https://software.intel.com/sites/default/files/m/c/5/4/recog_picture.bmp" alt="" width="525" height="257" /></a><br /><br /><strong>Figure 1: The Intel&reg; TBB flow graph for the feature-detection example.</strong><br /><br />In the figure, there are four different type of nodes used to construct the application: a&nbsp;<code>source_node</code>, a&nbsp;<code>queue_node</code>, two&nbsp;<code>join_node</code>s, and several&nbsp;<code>function_node</code>s. Before I provide a sample implementation, I&rsquo;ll provide a brief overview of each node.<br /><br />The first type of node is a&nbsp;<code>source_node</code>, which is shown pictorially using the symbol below. This type of node has no predecessors, and is used to generate messages that are injected into the graph. It executes a user functor (or lambda expression) to generate its output. The unfilled circle on its right side indicates that it buffers its output and that this buffer can be reserved. The&nbsp;<code>source_node</code>&nbsp;buffers a single item. When a buffer is reserved, a value is held for the caller until the caller either consumes or releases the value. A&nbsp;<code>source_node</code>&nbsp;will only invoke the user functor when there is nothing currently buffered in its single item output buffer.<br /><br /><a href="https://software.intel.com/sites/default/files/m/b/9/2/source_node.png" rel="nofollow"><img title="source_node" src="https://software.intel.com/sites/default/files/m/b/9/2/source_node.png" alt="" width="96" height="99" /></a><br /><br />The second type of node is a&nbsp;<code>queue_node</code>, which is show using the figure below. A queue_node is an unbounded first-in first-out buffer. Like the&nbsp;<code>source_node</code>, its output is reservable.<br /><br /><a href="https://software.intel.com/sites/default/files/m/4/6/8/queue_node.png" rel="nofollow"><img title="queue_node" src="https://software.intel.com/sites/default/files/m/4/6/8/queue_node.png" alt="" width="117" height="87" /></a><br /><br />The third type of node, of which there are two variants used in the example, is the&nbsp;<code>join_node</code>. A&nbsp;<code>join_node</code>&nbsp;has multiple input ports and generates a single output tuple that contains a value received at each port. A&nbsp;<code>join_node</code>&nbsp;can use different policies at its input ports:&nbsp;<code>queueing</code>,&nbsp;<code>reserving</code>&nbsp;or&nbsp;<code>tag_matching</code>. A&nbsp;<code>queueing join_node</code>, greedily consumes all messages as they arrive and generates an output whenever it has at least 1 item at each input queue. A&nbsp;<code>reserving join_node</code>&nbsp;only attempts to generate a tuple when it can successfully reserve an item at each input port. If it cannot successfully reserve all inputs, it releases all of its reservations and will only try again when it receives a message from the port or ports it was previously unable to reserve. Lastly, a&nbsp;<code>tag_matching join_node</code>&nbsp;uses hash tables to buffer messages in its input ports. When it has received messages at each port that have matching keys, it creates an output tuple with these messages. Shown below are the symbol for the&nbsp;<code>reserving</code>&nbsp;and&nbsp;<code>tag_matching join_node</code>s used in Figure 1.<br /><br /><a href="https://software.intel.com/sites/default/files/m/6/7/3/reserving_join.png" rel="nofollow"><img title="reserving_join" src="https://software.intel.com/sites/default/files/m/6/7/3/reserving_join.png" alt="" width="96" height="94" /></a><a href="https://software.intel.com/sites/default/files/m/3/3/d/tag_matching_join.png" rel="nofollow"><img title="tag_matching_join" src="https://software.intel.com/sites/default/files/m/3/3/d/tag_matching_join.png" alt="" width="103" height="102" /></a><br /><br />The final node type used in this example is a&nbsp;<code>function_node</code>; it uses the symbol shown below. A&nbsp;<code>function_node</code>&nbsp;executes a user-provided functor or lambda expression on incoming messages, passing the return value to its successors. A&nbsp;<code>function_node</code>&nbsp;can be constructed with a limited or unlimited allowable concurrency level. A&nbsp;<code>function_node</code>&nbsp;with unlimited concurrency creates a task to apply its functor to each message as they arrive. If a&nbsp;<code>function_node</code>&nbsp;has limited concurrency, it will create tasks only up to its allowed concurrency level, buffering messages at its input as necessary so that they are not dropped.<br /><br /><a href="https://software.intel.com/sites/default/files/m/f/2/a/function_node.png" rel="nofollow"><img title="function_node" src="https://software.intel.com/sites/default/files/m/f/2/a/function_node.png" alt="" width="130" height="103" /></a><br /><br />To save on space, I&rsquo;m going to fake the image processing parts of this example. In particular, each image will simply be an array of characters. An image that contains the character &lsquo;A&rsquo; has a feature recognizable by algorithm A, and an image that contains the character &lsquo;B&rsquo; has a feature recognizable by algorithm B. So in the post, I will provide the complete code to construct and execute a flow graph that has the structure shown in Figure 1, but I&rsquo;ll replace the actual computations with trivial ones.<br /><br />Below is the declaration of&nbsp;<code>struct image</code>, as well as the trivial implementations that can be used as the bodies of the function nodes. The function&nbsp;<code>get_next_image</code>&nbsp;will be used by the&nbsp;<code>source_node</code>&nbsp;to generate images for processing. You might note that in&nbsp;<code>get_next_image</code>, every 11th image will have a feature detectable by algorithm A and every 13th image will contain a feature detectable by algorithm B. The function&nbsp;<code>preprocess_image</code>&nbsp;adds a simple offset to each character, and&nbsp;<code>detect_with_A</code>&nbsp;and&nbsp;<code>detect_with_B</code>&nbsp;do the trivial search for the characters 'A' and 'B', respectively.<br /><br /><code>#include &lt;cstring&gt;</code><br /><code>#include &lt;cstdio&gt;</code><br /><br /><code>const int num_image_buffers = 100;</code><br /><code>int image_size = 10000000;</code><br /><br /><code>struct image {</code><br /><code>&nbsp;&nbsp; const int N;</code><br /><code>&nbsp;&nbsp; char *data;</code><br /><code>&nbsp;&nbsp; image();</code><br /><code>&nbsp;&nbsp; image( int image_number, bool a, bool b );</code><br /><code>};</code><br /><br /><code>image::image() : N(image_size) {</code><br /><code>&nbsp;&nbsp; data = new char[N];</code><br /><code>}</code><br /><br /><code>image::image( int image_number, bool a, bool b ) : N(image_size) {</code><br /><code>&nbsp;&nbsp;&nbsp; data = new char[N];</code><br /><code>&nbsp;&nbsp;&nbsp; memset( data, '\0', N );</code><br /><code>&nbsp;&nbsp;&nbsp; data[0] = (char)image_number - 32;</code><br /><code>&nbsp;&nbsp;&nbsp; if ( a ) data[N-2] = 'A';</code><br /><code>&nbsp;&nbsp;&nbsp; if ( b ) data[N-1] = 'B';</code><br /><code>}</code><br /><br /><code>int img_number = 0;</code><br /><code>int num_images = 64;</code><br /><code>const int a_frequency = 11;</code><br /><code>const int b_frequency = 13;</code><br /><br /><code>image *get_next_image() {</code><br /><code>&nbsp;&nbsp;&nbsp; bool a = false, b = false;</code><br /><code>&nbsp;&nbsp;&nbsp; if ( img_number &lt; num_images ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( img_number%a_frequency == 0 ) a = true;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( img_number%b_frequency == 0 ) b = true;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new image( img_number++, a, b );</code><br /><code>&nbsp;&nbsp;&nbsp; } else {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>}</code><br /><br /><code>void preprocess_image( image *input_image, image *output_image ) {</code><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; input_image-&gt;N; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output_image-&gt;data[i] = input_image-&gt;data[i] + 32;</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>}</code><br /><br /><code>bool detect_with_A( image *input_image ) {</code><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; input_image-&gt;N; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( input_image-&gt;data[i] == 'a' )</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp; return false;</code><br /><code>}</code><br /><br /><code>bool detect_with_B( image *input_image ) {</code><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; input_image-&gt;N; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( input_image-&gt;data[i] == 'b' )</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp; return false;</code><br /><code>}</code><br /><br /><code>void output_image( image *input_image, bool found_a, bool found_b ) {</code><br /><code>&nbsp;&nbsp;&nbsp; bool a = false, b = false;</code><br /><code>&nbsp;&nbsp;&nbsp; int a_i = -1, b_i = -1;</code><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; input_image-&gt;N; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( input_image-&gt;data[i] == 'a' ) { a = true; a_i = i; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( input_image-&gt;data[i] == 'b' ) { b = true; b_i = i; }</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp; printf("Detected feature (a,b)=(%d,%d)=(%d,%d) at (%d,%d) for image %p:%d\n",</code><br /><code>a, b, found_a, found_b, a_i, b_i, input_image, input_image-&gt;data[0]);</code><br /><code>}</code><br /><br />The code to implement the flow graph itself is shown in function&nbsp;<code>main</code>&nbsp;below. I will interject text in the middle of the listing of&nbsp;<code>main</code>&nbsp;to describe the use of the flow graph components. If you want to build this example, you can just cut and paste the code snippets above and below linearly into a single file.<br /><br /><code>int num_graph_buffers = 8;</code><br /><br /><code>#include "tbb/flow_graph.h"</code><br /><br /><code>using namespace tbb;</code><br /><code>using namespace tbb::flow;</code><br /><br /><code>int main() {</code><br /><br />First, a&nbsp;<code>graph g</code>&nbsp;is created. All of the nodes will belong to this single graph. A few typedefs are provided to make it easier to refer to the outputs of the join nodes:<br /><br /><code>&nbsp;&nbsp;&nbsp; graph g;</code><br /><br /><code>&nbsp;&nbsp;&nbsp; typedef std::tuple&lt; image *, image * &gt; resource_tuple;</code><br /><code>&nbsp;&nbsp;&nbsp; typedef std::pair&lt; image *, bool &gt; detection_pair;</code><br /><code>&nbsp;&nbsp;&nbsp; typedef std::tuple&lt; detection_pair, detection_pair &gt; detection_tuple;</code><br /><br />Next, the&nbsp;<code>queue_node</code>&nbsp;that holds the images buffers is created, along with the two join nodes. Again, note that the&nbsp;<code>resource_join</code>&nbsp;is using the&nbsp;<code>reserving</code>&nbsp;policy, while&nbsp;<code>detection_join</code>&nbsp;uses the&nbsp;<code>tag_matching</code>policy. To use&nbsp;<code>tag_matching</code>, the user must provide functors that can extract the tag from the item; these appear as the additional arguments to the constructor.<br /><br /><code>&nbsp;&nbsp;&nbsp; queue_node&lt; image * &gt; buffers( g );</code><br /><code>&nbsp;&nbsp;&nbsp; join_node&lt; resource_tuple, reserving &gt; resource_join( g );</code><br /><code>&nbsp;&nbsp;&nbsp; join_node&lt; detection_tuple, tag_matching &gt; detection_join( g,</code><br /><code>[](const detection_pair &amp;p) -&gt; size_t { return (size_t)p.first; },</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](const detection_pair &amp;p) -&gt; size_t { return (size_t)p.first; }&nbsp; );</code><br /><br />Next, the nodes that execute the user&rsquo;s code are created, including the&nbsp;<code>source_node</code>&nbsp;and the four&nbsp;<code>function_nodes</code>. The user&rsquo;s code is passed to each node using a C++ lambda expression ( a function object could also be used ). For the most part, each lambda expression is a bit of wrapper code that calls the functions that were described earlier, obtaining inputs and creating outputs as necessary. The&nbsp;<code>make_edge</code>&nbsp;calls wire together the nodes as shown in Figure 1.<br /><br /><code>&nbsp;&nbsp;&nbsp; source_node&lt; image * &gt; src( g,</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []( image* &amp;next_image ) -&gt; bool {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_image = get_next_image();</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( next_image ) return true;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return false;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(src, input_port&lt;0&gt;(resource_join) );</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(buffers, input_port&lt;1&gt;(resource_join) );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; function_node&lt; resource_tuple, image * &gt;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preprocess_function( g, unlimited,</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []( const resource_tuple &amp;in ) -&gt; image * {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image *input_image = std::get&lt;0&gt;(in);</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image *output_image = std::get&lt;1&gt;(in);</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preprocess_image( input_image, output_image );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete input_image;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output_image;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; make_edge(resource_join, preprocess_function );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; function_node&lt; image *, detection_pair &gt;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; detect_A( g, unlimited,</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []( image *input_image ) -&gt; detection_pair {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool r = detect_with_A( input_image );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_pair( input_image, r );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; function_node&lt; image *, detection_pair &gt;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; detect_B( g, unlimited,</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []( image *input_image ) -&gt; detection_pair {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool r = detect_with_B( input_image );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_pair( input_image, r );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; make_edge(preprocess_function, detect_A );</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(detect_A, input_port&lt;0&gt;(detection_join) );</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(preprocess_function, detect_B );</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(detect_B, input_port&lt;1&gt;(detection_join) );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; function_node&lt; detection_tuple, image * &gt;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decide( g, serial,</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []( const detection_tuple &amp;t ) -&gt; image * {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const detection_pair &amp;a = std::get&lt;0&gt;(t);</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const detection_pair &amp;b = std::get&lt;1&gt;(t);</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image *img = a.first;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( a.second || b.second ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output_image( img, a.second, b.second );</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return img;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</code><br /><br /><code>&nbsp;&nbsp;&nbsp; make_edge(detection_join, decide);</code><br /><code>&nbsp;&nbsp;&nbsp; make_edge(decide, buffers);</code><br /><br />Because of the reserving join node at the front of the graph, the graph will remain idle until there are image buffers available in the&nbsp;<code>buffers</code>&nbsp;queue. The for-loop below allocates and puts buffers into the queue. After the loop, the call to&nbsp;<code>g.wait_for_all()</code>&nbsp;will block until the graph again becomes idle when all images are processed.<br /><br /><code>&nbsp;&nbsp;&nbsp; // Put image buffers into the buffer queue</code><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; num_graph_buffers; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image *img = new image;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffers.try_put( img );</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>&nbsp;&nbsp;&nbsp; g.wait_for_all();</code><br /><br />When the graph is idle, all of the buffers will again be in the buffers queue. The&nbsp;<code>queue_node</code>&nbsp;therefore needs to be drained and the buffers deallocated.:<br /><br /><code>&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; num_graph_buffers; ++i ) {</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image *img = NULL;</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( !buffers.try_get(img) )</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("ERROR: lost a buffer\n");</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete img;</code><br /><code>&nbsp;&nbsp;&nbsp; }</code><br /><code>return 0;</code><br /><code>}&nbsp;</code><br /><br />I hope that this feature-detection example demonstrates how a reasonably complex flow graph that passes messages between nodes can be implemented. To learn more about the new features in Intel&reg; Threading Building Blocks 4.0, visit&nbsp;<a href="http://www.threadingbuildingblocks.org/" rel="nofollow">http://www.threadingbuildingblocks.org</a>&nbsp;or to learn more about the Intel&reg; TBB flow graph, check-out the other blog articles at&nbsp;<a href="https://software.intel.com/en-us/blogs/tag/flow_graph/" rel="nofollow">/en-us/blogs/tag/flow_graph/</a>.</p>

</div>

</div>

</div>
<div class="optimization-notice">For more complete information about compiler optimizations, see our&nbsp;<a href="https://software.intel.com/en-us/articles/optimization-notice#opt-en">Optimization Notice</a>.</div>
<fieldset id="article-taxo-wrap" class="form-wrapper">
<div class="fieldset-wrapper">Categories:&nbsp;
<ul id="article-taxo-wrap-list">
<li class="field-item even"><a href="https://software.intel.com/en-us/search/site/field_topic/graphics-20864/language/en">Graphics</a>&nbsp;</li>
<li class="field-item odd">&nbsp;<a href="https://software.intel.com/en-us/search/site/field_topic/open_source-20865/language/en">Open Source</a>&nbsp;</li>
<li class="field-item even">&nbsp;<a href="https://software.intel.com/en-us/search/site/field_topic/parallel_computing-20867/language/en">Parallel Computing</a>&nbsp;</li>
<li class="field-item even">&nbsp;<a href="https://software.intel.com/en-us/search/site/field_software_products/intel_threading_building_blocks-20828/language/en">Intel&reg; Threading Building Blocks</a></li>

</ul>

</div>

</fieldset><fieldset id="article-tags-wrap" class="form-wrapper">
<div class="fieldset-wrapper">Tags:&nbsp;
<ul id="article-tags-wrap-list">
<li class="field-item even"><a href="https://software.intel.com/en-us/search/site/field_tags/flowgraph-17218/language/en">flow_graph</a></li>

</ul>

</div>

</fieldset>
<div id="button-links-wrap" class="clearfix">&nbsp;</div>
<div id="block-idz-responsive-blocks-idz-responsive-subnav" class="block block-idz-responsive-blocks first last odd">&nbsp;</div>