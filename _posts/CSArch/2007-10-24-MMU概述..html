<DIV class=title>
<H1><A href="http://www.yuanma.org/data/2006/1225/article_2005.htm">http://www.yuanma.org/data/2006/1225/article_2005.htm</A></H1>
<H1>MMU概述</H1>
<H2><STRONG>作者：</STRONG><A href="http://www.yuanma.org/member.php?action=show&amp;username=webmaster" target=_blank></A> &nbsp;&nbsp;&nbsp;&nbsp; <STRONG>来源：</STRONG><A href="" target=_blank>zz</A>&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>发表时间：</STRONG>2006-12-25&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>浏览次数：</STRONG>
<SCRIPT language=Javascript src="/view.php?articleid=2005"></SCRIPT>
 19393 &nbsp;&nbsp;&nbsp;&nbsp; <STRONG>字号：</STRONG><A class=black href="javascript:fontZoom(16)">大</A>&nbsp;&nbsp;<A class=black href="javascript:fontZoom(14)">中</A>&nbsp;&nbsp;<A class=black href="javascript:fontZoom(12)">小</A></H2></DIV>
<DIV class=content id=fontzoom>
<P>I. 什么是MMU,MMU的作用<BR>MMU是Memory Management Unit的缩写. 针对各种CPU, MMU是个可选的配件. MMU负责的是虚拟地址 &amp;O1663;&amp;O1664; 物理地址的转换. 提供硬件机制的内存访问授权. <BR>现 代的多用户多进程操作系统, 需要MMU, 才能达到每个用户进程都拥有自己的独立的地址空间的目标. 使用MMU, OS划分出一段地址区域, 在这块地址区域中, 每个进程看到的内容都不一定一样. 例如MICROSOFT WINDOWS操作系统, 地址4M-2G处划分为用户地址空间. 进程A在地址 0X400000映射了可执行文件. 进程B同样在地址 0X400000映射了可执行文件. 如果A进程读地址0X400000, 读到的是A的可执行文件映射到RAM的内容. 而进程B读取地址0X400000时则读到的是B的可执行文件映射到RAM的内容.<BR>这就是MMU在当中进行地址转换所起的作用.<BR>II. X86系列的MMU<BR>INTEL出品的80386CPU或者更新的CPU中都集成有MMU. 可以提供32BIT共4G的地址空间.<BR><BR>III. ARM系列的MMU<BR>&nbsp;&nbsp;&nbsp; ARM出品的CPU, MMU作为一个协处理器存在. 根据不同的系列有不同搭配. 需要查询DATASHEET才可知道是否有MMU. 如果有的话, 一定是编号为15的协处理器. 可以提供32BIT共4G的地址空间.<BR><BR>IV X86启动MMU后的寻址模式<BR>1.&nbsp;&nbsp;&nbsp; X86 MMU提供的模式有4K/2M/4M的PAGE模式(根据不同的CPU, 提供不同的能力), 此处提供的是目前大部分OS使用的4K PAGE模式的描述. 并且不提供ACCESS CHECK的部分. (毕竟不是完整的CPU手册. &amp;O1514;)<BR>2.&nbsp;&nbsp;&nbsp; 涉及的寄存器<BR>a)&nbsp;&nbsp;&nbsp; GDT<BR>b)&nbsp;&nbsp;&nbsp; LDT<BR>c)&nbsp;&nbsp;&nbsp; CR0<BR>d)&nbsp;&nbsp;&nbsp; CR3<BR>e)&nbsp;&nbsp;&nbsp; SEGMENT REGISTER<BR>3.&nbsp;&nbsp;&nbsp; 虚拟地址到物理地址的转换步骤(INTEL的2M/4M的PAGE或许会在将来文章中描述)<BR>a)&nbsp;&nbsp;&nbsp; SEGMENT REGISTER作为GDT或者LDT的INDEX, 取出对应的GDT/LDT ENTRY. <FONT color=#ffff00>注 意: SEGMENT是无法取消的, 即使是FLAT模式下也是如此. 说FLAT模式下不使用SEGMENT REGISTER是错误的. 任意的RAM寻址指令中均有DEFAULT的SEGMENT假定. 除非使用SEGMENT OVERRIDE PREFIX来改变当前寻址指令的SEGMENT, 否则使用的就是DEFAULT SEGMENT.</FONT><BR>i.&nbsp;&nbsp;&nbsp; ENTRY格式<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; limit_0_15;<BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; base_0_15;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; base_16_23;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; accessed&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; readable&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; conforming&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; code_data&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; app_system&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 2;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; present&nbsp;&nbsp;&nbsp;&nbsp; : 1;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; limit_16_19 : 4;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unused&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; always_0&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; seg_16_32&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; granularity : 1;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; base_24_31;<BR>} CODE_SEG_DESCRIPTOR,*PCODE_SEG_DESCRIPTOR;<BR><BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; limit_0_15;<BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; base_0_15;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; base_16_23;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; accessed&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; writeable&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; expanddown&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; code_data&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; app_system&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 2;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; present&nbsp;&nbsp;&nbsp;&nbsp; : 1;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; limit_16_19 : 4;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unused&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; always_0&nbsp;&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; seg_16_32&nbsp;&nbsp; : 1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; granularity : 1;<BR><BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; base_24_31;<BR>} DATA_SEG_DESCRIPTOR,*PDATA_SEG_DESCRIPTOR;<BR><BR>共 有4种ENTRY格式, 此处提供的是CODE SEGMENT和DATA SEGMENT的ENTRY格式. FLAT模式下的ENTRY在base_0_15, base_16_23处为0, 而limit_0_15, limit_16_19处为0xfffff.&nbsp; granularity处为1. 表名SEGMENT地址空间是从0到0XFFFFFFFF的4G的地址空间.<BR>b)&nbsp;&nbsp;&nbsp; 从SEGMENT处取出BASE ADDRESS 和LIMIT. 将要访问的ADDRESS首先进行ACCESS CHECK, 是否超出SEGMENT的限制.<BR>c)&nbsp;&nbsp;&nbsp; 将要访问的ADDRESS+BASE ADDRESS, 形成需要32BIT访问的虚拟地址. 该地址被解释成如下格式:<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; offset&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :12;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; page_index&nbsp;&nbsp;&nbsp; :10;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; pdbr_index&nbsp;&nbsp;&nbsp; :10;<BR>} VA,*LPVA;<BR>d)&nbsp;&nbsp;&nbsp; pdbr_index作为CR3的INDEX, 获得到一个如下定义的数据结构<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; present&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; writable&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; supervisor&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; writethrough:1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; cachedisable:1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; accessed&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; reserved1&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; pagesize&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; ignoreed&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; avl&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :3;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; ptadr_12_15&nbsp;&nbsp;&nbsp; :4;<BR><BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; ptadr_16_31;<BR>}PDE,*LPPDE;<BR>e)&nbsp;&nbsp;&nbsp; 从中取出PAGE TABLE的地址. 并且使用page_index作为INDEX, 得到如下数据结构<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; present&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; writable&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; supervisor&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; writethrough:1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; cachedisable:1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; accessed&nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; dirty&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; pta&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; global&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :1;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; avl&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :3;<BR>&nbsp;&nbsp;&nbsp; UINT8&nbsp;&nbsp;&nbsp; ptadr_12_15&nbsp;&nbsp;&nbsp; :4;<BR><BR>&nbsp;&nbsp;&nbsp; UINT16&nbsp;&nbsp;&nbsp; ptadr_16_31;<BR>}PTE,*LPPTE;<BR>f)&nbsp;&nbsp;&nbsp; 从PTE中获得PAGE的真正物理地址的BASE ADDRESS. 此BASE ADDRESS表名了物理地址的.高20位. 加上虚拟地址的offset就是物理地址所在了.<BR><BR>ARM启动MMU后的寻址模式<BR>1.&nbsp;&nbsp;&nbsp; ARM MMU提供的分页模式有1K/4K/64K 3种模式. 本文介绍的是目前OS通常使用的4K模式. 并且不提供ACCESS CHECK的部分. (毕竟不是完整的CPU手册. &amp;O1514;)<BR>2.&nbsp;&nbsp;&nbsp; 涉及的寄存器, 全部位于协处理器15.&nbsp; <BR>3.&nbsp;&nbsp;&nbsp; ARM没有SEGMENT的寄存器, 是真正的FLAT模式的CPU. 给定一个ADDRESS. 该地址可以被理解为如下数据结构:<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; offset&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :12;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; page_index&nbsp;&nbsp;&nbsp; :8;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; pdbr_index&nbsp;&nbsp;&nbsp; :12;<BR>} VA,*LPVA;<BR>4.&nbsp;&nbsp;&nbsp; 从MMU寄存器2中取出BIT14-31. pdbr_index就是这个表的索引. 每个入口为4BYTE大小. 结构为<BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :2;&nbsp;&nbsp;&nbsp; //always set to 01b<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; writebackcacheable:1;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; writethroughcacheable:1;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; ignore&nbsp;&nbsp;&nbsp; :1;&nbsp;&nbsp;&nbsp; //set to 1b always<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; domain&nbsp;&nbsp;&nbsp; :4;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; reserved&nbsp;&nbsp;&nbsp; :1;&nbsp;&nbsp;&nbsp; //set 0<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; base_addr:22;<BR>} PDE,*LPPDE;<BR>5.&nbsp;&nbsp;&nbsp; 获得的PDE地址, 获得如下结构的ARRAY, 用page_index作为索引,取出内容. <BR>typedef struct<BR>{<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :2;&nbsp;&nbsp;&nbsp; //always set to 11b<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; ignore&nbsp;&nbsp;&nbsp; :3;&nbsp;&nbsp;&nbsp; //set to 100b always<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; domain&nbsp;&nbsp;&nbsp; :4;<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; reserved&nbsp;&nbsp;&nbsp; :3;&nbsp;&nbsp;&nbsp; //set 0<BR>&nbsp;&nbsp;&nbsp; UINT32&nbsp;&nbsp;&nbsp; base_addr:20;<BR>} PTE,*LPPTE;<BR>6.&nbsp;&nbsp;&nbsp; 从PTE中获得的基地址和上offset,组成了物理地址.<BR>7.&nbsp;&nbsp;&nbsp; PDE/PTE中其他的BIT, 用于访问控制. 这边讲述的是一切正常, 物理地址被正常组合出来的状况.<BR><BR>ARM/X86 MMU使用上的差异<BR>1.&nbsp;&nbsp;&nbsp; X86始终是有SEGMENT的概念存在. 而ARM则没有此概念(没有SEGMENT REGISTER.).<BR>2.&nbsp;&nbsp;&nbsp; ARM有个DOMAIN的概念. 用于访问授权. 这是X86所没有的概念. 当通用OS尝试同时适用于此2者的CPU上, 一般会抛弃DOMAIN的使用.&nbsp;</P></DIV>