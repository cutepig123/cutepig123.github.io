<p>http://www.cs.jhu.edu/~yairamir/cs418/os3/sld019.htm</p><p>&nbsp;</p><p>http://stackoverflow.com/questions/938309/implementing-semaphores-locks-and-condition-variables</p><p>&nbsp;</p><p><img src="file:///C:/DOCUME%7E1/ADMINI%7E1/LOCALS%7E1/Temp/moz-screenshot.png" alt="" />&nbsp;Semaphores, locks, condition variables etc.  are operating system  concepts and must typically be implemented in terms of features of the  operating system kernel. It is therefore not generally possible to study  them in isolation - you need to consider the kernel code too. Probably  the best way of doing this is to take a look at the Linux Kernel, with  the help of a book such as <a href="http://oreilly.com/catalog/9780596000028/" rel="nofollow">Understandiong The Linux Kernel</a>.</p><p>&nbsp;</p><p><div><p>Semaphore at the very simplest is just a  counter you can add and subtract from with a single atomic operation.  Wikipedia has an easy to understand explanation that pretty much covers  your question about them:</p>  <p><a href="http://en.wikipedia.org/wiki/Semaphore%5F%28programming%29" rel="nofollow">http://en.wikipedia.org/wiki/Semaphore_(programming)</a></p> </div></p><p><div><p>The minix stuff is pretty good.  A simpler  example is the MicroC/OS stuff.  It comes with a textbook that goes into  good detail, all the source is there.  It has the basic elements there  and the code is small enough that you can understand it in a relatively  short period of time.</p>  <p><a href="http://www.micrium.com/products/rtos/kernel/rtos.html" rel="nofollow">http://www.micrium.com/products/rtos/kernel/rtos.html</a></p>  <p><a href="http://en.wikipedia.org/wiki/MicroC/OS-II" rel="nofollow">http://en.wikipedia.org/wiki/MicroC/OS-II</a></p>  <p>Another thing you can do, is make a faked out OS in an application on  linux.  I did this by setting up the basic tick with an itimer, then  swapping threads around with the function call swapcontext (man 2  swapcontext) which will save the regs on the stack.  That gets the ugly  stuff out of the way and you are left to implement the  semaphores/mutexes/timers and all that.  It was quite fun.</p>  <p>Despite what some of the posts say, assembler is not required.  A  knowledge of it will always help.  It never hurts to understand how the  internals/complilers/etc work when you are writing even high level  applications.</p> </div>&nbsp;</p>