<pre>http://www-d0.fnal.gov/d0dist/dist/releases/development/l3xDAQSuper/src/debug_utils/Source/memory_leak_checker.cpp<br />//<br />// memory_leak_checker.cpp<br />//<br />//  This guy's constructor will start leak checking and when<br />// its destructor is called it will print out error messages<br />// if there is any memory that has been allocated.<br />//<br />#include "memory_leak_checker.hpp"<br />#include &lt;iostream&gt;<br /><br />#include &lt;CRTDBG.H&gt;<br />#include &lt;windows.h&gt;<br /><br />//<br />// memory_leak_checker<br />//<br />//  Cache our state<br />//<br />memory_leak_checker :: memory_leak_checker (void)<br />#ifdef _DEBUG<br />: _memory_state (new _CrtMemState), _filename_valid (false)<br />#else<br />  : _memory_state (0)<br />#endif<br />{<br />#ifdef _DEBUG<br />	//<br />	// Turn on leek checking<br />	//<br /><br />	_old_tracking_flags = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG | _CRTDBG_LEAK_CHECK_DF);// Turn on leak-checking bit<br /><br />	//<br />	// Remember what the memory stuff looks like<br />	//<br /><br />	_report_mode_warn = _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );<br />	_report_mode_error = _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );<br />	_report_mode_assert = _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );<br /><br />	_report_file_warn = _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );<br />	_report_file_error = _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );<br />	_report_file_assert = _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );<br /><br />	_CrtMemCheckpoint(_memory_state);<br /><br />#endif<br />}<br /><br />//<br />// set_file<br />//<br />//  Set the output file<br />//<br />void memory_leak_checker::set_file (const char *filename, bool append)<br />{<br />	unsigned int create_flags = CREATE_ALWAYS;<br />	if (append) {<br />		create_flags = OPEN_ALWAYS;<br />	}<br /><br />	_filename_handle = ::CreateFile (filename, GENERIC_WRITE, 0, 0, create_flags, FILE_ATTRIBUTE_NORMAL, 0);<br />	_filename_valid = _filename_handle != INVALID_HANDLE_VALUE;<br /><br />	if (_filename_valid) {<br /><br />		//<br />		// Get to the end of the file<br />		//<br /><br />		::SetFilePointer (_filename_handle, 0, 0, FILE_END);<br /><br />		//<br />		// Set up the various report handles<br />		//<br /><br />		_CrtSetReportFile ( _CRT_WARN, _filename_handle);<br />		_CrtSetReportFile ( _CRT_ERROR, _filename_handle);<br />		_CrtSetReportFile ( _CRT_ASSERT, _filename_handle);<br />	}<br />}<br /><br />//<br />// ~memory_leak_checker<br />//<br />//  Restore everything and print out the current state of<br />// the memory heap.<br />//<br />memory_leak_checker :: ~memory_leak_checker (void)<br />{<br />#ifdef _DEBUG<br />	//<br />	// See if there is any difference between now and then.<br />	//<br /><br />	_CrtMemState state_now;<br />	_CrtMemCheckpoint(&amp;state_now);<br /><br />	_CrtMemState the_difference;<br />	if (_CrtMemDifference(&amp;the_difference, _memory_state, &amp;state_now)) {<br />		std::cout &lt;&lt; "***" &lt;&lt; std::endl &lt;&lt; "*** Memory Leak Seen!" &lt;&lt; std::endl &lt;&lt; "***" &lt;&lt; std::endl;<br />		_CrtMemDumpStatistics(&amp;the_difference);<br />		_CrtMemDumpAllObjectsSince(_memory_state);<br />	}<br /><br />	delete _memory_state;<br />	//<br />	// Reset the memory tracking flags<br />	//<br /><br />	_CrtSetDbgFlag (_old_tracking_flags);<br /><br />	//<br />	// Reset the error reporting<br />	//<br /><br />	_CrtSetReportMode( _CRT_WARN, _report_mode_warn);<br />	_CrtSetReportMode( _CRT_ERROR, _report_mode_error);<br />	_CrtSetReportMode( _CRT_ASSERT, _report_mode_assert);<br /><br />	_CrtSetReportFile( _CRT_WARN, _report_file_warn);<br />	_CrtSetReportFile( _CRT_ERROR, _report_file_error);<br />	_CrtSetReportFile( _CRT_ASSERT, _report_file_assert);<br /><br />	//<br />	// CLose a file if we have it open<br />	//<br /><br />	if (_filename_valid) {<br />		::CloseHandle (_filename_handle);<br />	}<br /><br />#endif<br />}<br /><br />//<br />// break_on_block<br />//<br />//  Cause a debugger break point when a certian block is allocated.<br />//<br />void memory_leak_checker::break_on_block (long block_number)<br />{<br />#ifdef _DEBUG<br />	_CrtSetBreakAlloc(block_number);<br />	_crtBreakAlloc = block_number;<br /><br />#endif<br />}</pre>