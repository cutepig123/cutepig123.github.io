<h1 class="titel"></h1><h1 class="titel">Valgrind技术参考</h1><br /><h1 class="titel">http://valgrind.org/docs/manual/tech-docs.html</h1><br /><br /><h1 class="titel">防止内存泄露 Linux下用Valgrind做检查  </h1>                                          <table style="margin: 2px 0px 20px;" width="560" border="0" cellpadding="0" cellspacing="0">           <tr>             <td bgcolor="#b1bcc0" height="1"><br /></td>           </tr>         </table> 		         <table style="margin-bottom: 20px;" width="560" border="0" cellpadding="0" cellspacing="0">           <tr> 		               <td align="center"><span class="content01"></span><span class="b">发布时间：2007.10.25 06:15</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="b"> 来源：赛迪网</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="b">作者：sixth</span></td>           </tr>         </table>                                                                  <span id="zoom" class="a14c">                                <p style="text-indent: 2em;">用C/C++开发其中最令人头疼的一个问题就是内存管理，有时候为了查找一个内存泄漏或者一个内存访问越界，需要要花上好几天时间，如果有一款工具能够帮助我们做这件事情就好了，valgrind正好就是这样的一款工具。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">Valgrind是一款基于模拟linux下的程序调试器和剖析器的软件套件，可以 运行于x86, amd64和ppc32架构上。valgrind包含一个核心，它提供一个虚拟的CPU运行程序，还有一系列的工具，它们完成调试，剖析和一些类似的任 务。valgrind是高度模块化的，所以开发人员或者用户可以给它添加新的工具而不会损坏己有的结构。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind的官方网址是：http://valgrind.org </p><p style="text-indent: 2em;">你可以在它的网站上下载到最新的valgrind，它是开放源码和免费的。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;"><strong>一、介绍</strong> </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind包含几个标准的工具，它们是： </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">1、memcheck </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">memcheck探测程序中内存管理存在的问题。它检查所有对内存的读/写操作，并截取所有的malloc/new/free/delete调用。因此memcheck工具能够探测到以下问题： </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">1）使用未初始化的内存 </p><p style="text-indent: 2em;">2）读/写已经被释放的内存 </p><p style="text-indent: 2em;">3）读/写内存越界 </p><p style="text-indent: 2em;">4）读/写不恰当的内存栈空间 </p><p style="text-indent: 2em;">5）内存泄漏 </p><p style="text-indent: 2em;">6）使用malloc/new/new[]和free/delete/delete[]不匹配。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">2、cachegrind </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">cachegrind是一个cache剖析器。它模拟执行CPU中的L1, D1和L2 cache，因此它能很精确的指出代码中的cache未命中。如果你需要，它可以打印出cache未命中的次数，内存引用和发生cache未命中的每一行 代码，每一个函数，每一个模块和整个程序的摘要。如果你要求更细致的信息，它可以打印出每一行机器码的未命中次数。在x86和amd64 上，cachegrind通过CPUID自动探测机器的cache配置，所以在多数情况下它不再需要更多的配置信息了。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">3、helgrind </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">helgrind查找多线程程序中的竞争数据。helgrind查找内存地址，那些被多于一条线程访问的内存地址，但是没有使用一致的锁就会被查出。这表示这些地址在多线程间访问的时候没有进行同步，很可能会引起很难查找的时序问题。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;"><strong>二、valgrind对你的程序都做了些什么</strong> </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind被设计成非侵入式的，它直接工作于可执行文件上，因此在检查前不需要重新编译、连接和修改你的程序。要检查一个程序很简单，只需要执行下面的命令就可以了 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=tool_name  program_name </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">比如我们要对ls -l命令做内存检查，只需要执行下面的命令就可以了 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=memcheck ls -l </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">不管是使用哪个工具，valgrind在开始之前总会先取得对你的程序的控制权，从 可执行关联库里读取调试信息。然后在valgrind核心提供的虚拟CPU上运行程序，valgrind会根据选择的工具来处理代码，该工具会向代码中加 入检测代码，并把这些代码作为最终代码返回给valgrind核心，最后valgrind核心运行这些代码。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">如果要检查内存泄漏，只需要增加--leak-check=yes就可以了，命令如下 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=memcheck --leak-check=yes ls -l </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">不同工具间加入的代码变化非常的大。在每个作用域的末尾，memcheck加入代码检查每一片内存的访问和进行值计算，代码大小至少增加12倍，运行速度要比平时慢25到50倍。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind模拟程序中的每一条指令执行，因此，检查工具和剖析工具不仅仅是对你的应用程序，还有对共享库，GNU C库，X的客户端库都起作用。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;"><strong>三、现在开始</strong> </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">首先，在编译程序的时候打开调试模式（gcc编译器的-g选项）。如果没有调试信 息，即使最好的valgrind工具也将中能够猜测特定的代码是属于哪一个函数。打开调试选项进行编译后再用valgrind检查，valgrind将会 给你的个详细的报告，比如哪一行代码出现了内存泄漏。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">当检查的是C++程序的时候，还应该考虑另一个选项 -fno-inline。它使得函数调用链很清晰，这样可以减少你在浏览大型C++程序时的混乱。比如在使用这个选项的时候，用memcheck检查 openoffice就很容易。当然，你可能不会做这项工作，但是使用这一选项使得valgrind生成更精确的错误报告和减少混乱。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">一些编译优化选项(比如-O2或者更高的优化选项)，可能会使得memcheck提交错误的未初始化报告，因此，为了使得valgrind的报告更精确，在编译的时候最好不要使用优化选项。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">如果程序是通过脚本启动的，可以修改脚本里启动程序的代码，或者使用--trace-children=yes选项来运行脚本。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">下面是用memcheck检查ls -l命令的输出报告，在终端下执行下面的命令 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=memcheck ls -l </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">程序会打印出ls -l命令的结果，最后是valgrind的检查报告如下： </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">==4187== </p><p style="text-indent: 2em;">==4187== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 19 from 2) </p><p style="text-indent: 2em;">==4187== malloc/free: in use at exit: 15,154 bytes in 105 blocks. </p><p style="text-indent: 2em;">==4187== malloc/free: 310 allocs, 205 frees, 60,093 bytes allocated. </p><p style="text-indent: 2em;">==4187== For counts of detected errors, rerun with: -v </p><p style="text-indent: 2em;">==4187== searching for pointers to 105 not-freed blocks. </p><p style="text-indent: 2em;">==4187== checked 145,292 bytes. </p><p style="text-indent: 2em;">==4187== </p><p style="text-indent: 2em;">==4187== LEAK SUMMARY: </p><p style="text-indent: 2em;">==4187==    definitely lost: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4187==      possibly lost: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4187==    still reachable: 15,154 bytes in 105 blocks. </p><p style="text-indent: 2em;">==4187==         suppressed: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4187== Reachable blocks (those to which a pointer was found) are not shown. </p><p style="text-indent: 2em;">==4187== To see them, rerun with: --show-reachable=yes </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">这里的&#8220;4187&#8221;指的是执行ls -l的进程ID，这有利于区别不同进程的报告。memcheck会给出报告，分配置和释放了多少内存，有多少内存泄漏了，还有多少内存的访问是可达的，检查了多少字节的内存。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">下面举两个用valgrind做内存检查的例子 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">例子一 (test.c)： </p><p style="text-indent: 2em;"> </p><center><ccid_nobr> <table bordercolorlight="black" bordercolordark="#FFFFFF" width="400" align="center" border="1" cellpadding="2" cellspacing="0"> <tr>     <td class="code" style="font-size: 9pt;" bgcolor="#e6e6e6">     <pre><ccid_code>#include &lt;string.h&gt;<br /><br />int main(int argc, char *argv[])<br />{<br />    char *ptr;<br /><br />    ptr = (char*) malloc(10);<br />    strcpy(ptr, "01234567890");<br /><br />    return 0;<br />}</ccid_code></pre>     </td>   </tr> </table> </ccid_nobr></center> <p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">编译程序 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">gcc -g -o test test.c </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">用valgrind执行命令 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=memcheck --leak-check=yes ./test </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">报告如下 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">==4270== Memcheck, a memory error detector. </p><p style="text-indent: 2em;">==4270== Copyright (C) 2002-2006, and GNU GPL'd, by Julian Seward et al. </p><p style="text-indent: 2em;">==4270== Using LibVEX rev 1606, a library for dynamic binary translation. </p><p style="text-indent: 2em;">==4270== Copyright (C) 2004-2006, and GNU GPL'd, by OpenWorks LLP. </p><p style="text-indent: 2em;">==4270== Using valgrind-3.2.0, a dynamic binary instrumentation framework. </p><p style="text-indent: 2em;">==4270== Copyright (C) 2000-2006, and GNU GPL'd, by Julian Seward et al. </p><p style="text-indent: 2em;">==4270== For more details, rerun with: -v </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== Invalid write of size 1 </p><p style="text-indent: 2em;">==4270==    at 0x4006190: strcpy (mc_replace_strmem.c:271) </p><p style="text-indent: 2em;">==4270==    by 0x80483DB: main (test.c:8) </p><p style="text-indent: 2em;">==4270==  Address 0x4023032 is 0 bytes after a block of size 10 alloc'd </p><p style="text-indent: 2em;">==4270==    at 0x40044F6: malloc (vg_replace_malloc.c:149) </p><p style="text-indent: 2em;">==4270==    by 0x80483C5: main (test.c:7) </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== Invalid write of size 1 </p><p style="text-indent: 2em;">==4270==    at 0x400619C: strcpy (mc_replace_strmem.c:271) </p><p style="text-indent: 2em;">==4270==    by 0x80483DB: main (test.c:8) </p><p style="text-indent: 2em;">==4270==  Address 0x4023033 is 1 bytes after a block of size 10 alloc'd </p><p style="text-indent: 2em;">==4270==    at 0x40044F6: malloc (vg_replace_malloc.c:149) </p><p style="text-indent: 2em;">==4270==    by 0x80483C5: main (test.c:7) </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 12 from 1) </p><p style="text-indent: 2em;">==4270== malloc/free: in use at exit: 10 bytes in 1 blocks. </p><p style="text-indent: 2em;">==4270== malloc/free: 1 allocs, 0 frees, 10 bytes allocated. </p><p style="text-indent: 2em;">==4270== For counts of detected errors, rerun with: -v </p><p style="text-indent: 2em;">==4270== searching for pointers to 1 not-freed blocks. </p><p style="text-indent: 2em;">==4270== checked 51,496 bytes. </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1 </p><p style="text-indent: 2em;">==4270==    at 0x40044F6: malloc (vg_replace_malloc.c:149) </p><p style="text-indent: 2em;">==4270==    by 0x80483C5: main (test.c:7) </p><p style="text-indent: 2em;">==4270== </p><p style="text-indent: 2em;">==4270== LEAK SUMMARY: </p><p style="text-indent: 2em;">==4270==    definitely lost: 10 bytes in 1 blocks. </p><p style="text-indent: 2em;">==4270==      possibly lost: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4270==    still reachable: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4270==         suppressed: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4270== Reachable blocks (those to which a pointer was found) are not shown. </p><p style="text-indent: 2em;">==4270== To see them, rerun with: --show-reachable=yes </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">从这份报告可以看出，进程号是4270，test.c的第8行写内存越界了，引起写内存越界的是strcpy函数， </p><p style="text-indent: 2em;">第7行泄漏了10个字节的内存，引起内存泄漏的是malloc函数。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">例子二（test2.c) </p><p style="text-indent: 2em;"> </p><center><ccid_nobr> <table bordercolorlight="black" bordercolordark="#FFFFFF" width="400" align="center" border="1" cellpadding="2" cellspacing="0"> <tr>     <td class="code" style="font-size: 9pt;" bgcolor="#e6e6e6">     <pre><ccid_code>#include &lt;stdio.h&gt;<br /><br />int foo(int x)<br />{<br />    if (x &lt; 0) {<br />        printf("%d ", x);<br />    }<br /><br />    return 0;<br />}<br /><br />int main(int argc, char *argv[])<br />{<br />    int x;<br />   <br />    foo(x);<br /><br />    return 0;<br />}</ccid_code></pre>     </td>   </tr> </table> </ccid_nobr></center> <p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">编译程序 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">gcc -g -o test2 test2.c </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">用valgrind做内存检查 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind --tool=memcheck ./test2 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">输出报告如下 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">==4285== Memcheck, a memory error detector. </p><p style="text-indent: 2em;">==4285== Copyright (C) 2002-2006, and GNU GPL'd, by Julian Seward et al. </p><p style="text-indent: 2em;">==4285== Using LibVEX rev 1606, a library for dynamic binary translation. </p><p style="text-indent: 2em;">==4285== Copyright (C) 2004-2006, and GNU GPL'd, by OpenWorks LLP. </p><p style="text-indent: 2em;">==4285== Using valgrind-3.2.0, a dynamic binary instrumentation framework. </p><p style="text-indent: 2em;">==4285== Copyright (C) 2000-2006, and GNU GPL'd, by Julian Seward et al. </p><p style="text-indent: 2em;">==4285== For more details, rerun with: -v </p><p style="text-indent: 2em;">==4285== </p><p style="text-indent: 2em;">==4285== Conditional jump or move depends on uninitialised value(s) </p><p style="text-indent: 2em;">==4285==    at 0x8048372: foo (test2.c:5) </p><p style="text-indent: 2em;">==4285==    by 0x80483B4: main (test2.c:16) </p><p style="text-indent: 2em;">==4285==p p  </p><p style="text-indent: 2em;">==4285== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 12 from 1) </p><p style="text-indent: 2em;">==4285== malloc/free: in use at exit: 0 bytes in 0 blocks. </p><p style="text-indent: 2em;">==4285== malloc/free: 0 allocs, 0 frees, 0 bytes allocated. </p><p style="text-indent: 2em;">==4285== For counts of detected errors, rerun with: -v </p><p style="text-indent: 2em;">==4285== All heap blocks were freed -- no leaks are possible. </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">从这份报告可以看出进程PID是4285，test2.c文件的第16行调用了foo函数，在test2.c文件的第5行foo函数使用了一个未初始化的变量。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">valgrind还有很多使用选项，具体可以查看valgrind的man手册页和valgrind官方网站的在线文档。 </p><p style="text-indent: 2em;"> </p><p style="text-indent: 2em;">（责任编辑：云子）               </p></span>