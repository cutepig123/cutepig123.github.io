<p><br />探索qt的信号<br />ref： http://crazyeddiecpp.blogspot.hk/2011/01/quest-for-sane-signals-in-qt-step-1.html</p>
<p>If it wasn't for the particular implementation of signals that Qt has, it would be a quite wonderful library. So much about it has been made very easy in comparison to most other UI libraries for C++. I really enjoy working with the library except for its signal architecture. Don't get me wrong, the signal/slot idea is a vast improvement over every other thing out there; what I don't like is Qt's way of doing it.</p>
<p>The way I see it, there's two fundamental problems with Qt's approach:<br />qt的信号机制有两个根本问题</p>
<p>1) If I wanted Python I'd use it. C++ is a strongly typed language and this feature is extremely powerful in that it provides much opportunity to catch bugs before they ever happen. The designers of Qt apparently don't like this feature though and spent a lot of time and effort making QObjects dynamic types. You can connect slots to signals without knowing whether or not either one is actually real. The problem with this is that you don't know that you've spelled something wrong until you run the program and happen upon the problem; this can be damn difficult to debug in some cases too, which is one good reason why I'm NOT using Python.<br />没有了强类型<br />2) Qt slots can only exist in Q_OBJECT classes. This has more implications than simply being bound to QObject because Q_OBJECT classes must be processed by the moc. The moc, in turn, implements an incomplete C++ preprocessor and is not compatible with template classes. Since only slots can be connected to signals you're stuck having to implement a hand-coded Q_OBJECT for each one. This means you can't auto-generate slot classes. Furthermore, since slots have to be complete objects and not just functors as with other C++ implementations of the signal/slot architecture, you can't connect to binds or lambda expressions.<br />你不能自动生成槽类<br />您无法连接到绑定或lambda表达式<br />The first of these is frustrating and slows me down, but the second is actually fairly debilitating compared to other signal/slot implementations. The really great thing about implementations like boost::signals (or signals2 - even better) is that you can connect signals to objects that don't even know anything about signals or slots. This means that your model and data classes don't have to be bound to this kind of use and you don't need to hand-code in-between objects to connect them (as you do in Qt). In fact, these mechanisms allow you to even connect to free functions, giving you even more possibilities for expression without creating new, pointless coupling.</p>
<p>However, like I said, the rest of the Qt library is great and since the developers actually cared about commercial development on Windows operating systems, it makes the single best C++ option that exists for UI development on that system. Even though it is "cross-platform" it is still the best for native development that you never intend to use anywhere else. The simple fact is that native options, such as MFC, are horrible to use. The GTKmm library uses something similar to boost::signals but unfortunately doesn't provide accessibility on Windows, unlike Qt. This feature is absolutely needed by anyone who intends to auto-drive their UI through testing scripts on that system since all such test suites use the accessibility framework to do their thing.<br />但是qt支持ui测试啊<br />So, given that I hate the Qt signal system but need to use Qt, my quest is to find a method to sanitize Qt's signals. I don't intend to "fix" them, they'll still be there and being used, but I do intend to fix the interface to them. I want static typing back and I want to be able to connect to any function like interface, just like boost::signals. Thus the real goal here is to turn a Qt signal into a boost signal. We don't have to go the other way around because Qt slots are just functions (with some junk about them in some meta-information) so we can connect them to any boost signal freely.<br />所以虽然我很恨他的slot机制，但也必须用他<br />我想搞掉slot<br />It would be nice to be able to do this on the fly. So I'm looking for a use case something like so:<br />我想实现如下功能：</p>
<p>connect_static(qt_object, qt_signal, [](args){ ... });</p>
<p><br />Of course the problem I have at this point is that whatever does the translation MUST be a Q_OBJECT. Of course it can't be because I need to be able to generate the translation functor from the parameter description. The only ways to do that is of course to extend the moc in some way, use the preprocessor, or (my preferred choice) template meta-programming. The first is simply not practical and the later two are incompatible with the moc. Thus, what we need to do here is create a Q_OBJECT without using the moc. Today I pulled this off and it actually turned out to be a LOT easier than looking at the source code and various web sites would indicate.</p>
<p>The first thing I did was to examine the source code that is generated by the moc and try to figure it out. I actually made it pretty far but it was obvious that creating preprocessor macros (didn't think TMP would do it) to mimic the MOC would be damn daunting. Here's one website that describes the Qt metamodel:</p>
<p>Qt Internals &amp; Reversing</p>
<p>I also tried to ask on stackoverflow and qtcentre for help to see if all of this was even necessary. The former generated few responses indicating the MOC and any of my ideas to do this where incompatible. The latter just generated a flame war in response to my frustration with a whole lot of very silly answers, such as telling me to put a particular class definition in "#ifdef" blocks (not a good place to go to for help, lots of really poor advice being handed out at that site). I did, however, eventually yank out a link from one individual that actually ended up holding what I believe is the key to getting this accomplished:</p>
<p><span style="background-color: #ff0000;">Dynamic Signals and Slots</span></p>
<p>That site alone does not contain exactly what I need, but pulling various bits from it and adding bits I learned from looking at what qt_metacall does (stepped all the way through it quite a few times trying to figure out why my slots where not being called) resulted in the ability to create a QObject derived class that responds to any signal attached to it and could then be extended to forward to a subclass, which would not have to be a Q_OBJECT:<br />我从这个网站学到如何写一个class能反映任何连接到她的signal，然后forward到子类，而该子类不必是qobject</p>
<p><br />struct listener2 : public QObject<br />{<br />  int qt_metacall(QMetaObject::Call call, int id,void** args)<br />  {<br />    id = QObject::qt_metacall(call,id,args);<br />    if (id == -1 || call != QMetaObject::InvokeMetaMethod)<br />      return id;</p>
<p>    assert(id == 42);</p>
<p>    std::cout &lt;&lt; "Funky slot!!" &lt;&lt; std::endl;<br />    return -1;<br />  }</p>
<p>  void make_connection(QObject * obj, char const* signal)<br />  {<br />    QByteArray sig = QMetaObject::normalizedSignature(signal);<br />    int sigid = obj-&gt;metaObject()-&gt;indexOfSignal(sig);</p>
<p>    QMetaObject::connect(obj, sigid, this, QObject::metaObject()-&gt;methodCount() + 42);<br />  }<br />};</p>
<p><br />This object must be connected with "make_connection" rather than with connect, because otherwise the system breaks down when it tries to find the slot and doesn't, but besides that it is almost perfect. The args void* array actually points at the arguments generated by the signal and then must be reinterpret_cast to the appropriate thing (see the .moc output of any of your classes). <br />该object必须使用"make_connection"链接，否则系统会尝试着slot但找不到。除此之外他是完美的。参数void*指向信号产生的参数，他必须reinterpret_cast到合适的类型</p>
<p><span style="color: #ff0000;">The key here is to find the id of the signal you want to connect to and use QMetaObject::connect instead, supplying an id you can recognize on the other side. You must add the methodCount() of your base so that it can take care of existing slots. In the qt_metacall function you first let the base attempt to take care of it. This will subtract from the input id resulting in id's that YOUR derived object is meant to take care of. The assert is unnecessary but adds some semblance of safety. The return of -1 in standard Qt speak for, "I've handled this call."</span><br /><span style="color: #ff0000;">这里的关键是找到你想连接的信号的id，然后使用QMetaObject::connect链接 (mm的，俺要学习一下具体是怎么回事）</span></p>
<p>This is a big step. A subclass to this thing could take the void** data and then use TMP to generate the correct casts and invoke a boost::signal. Implementing that will be the subject of "step 2" followed by attempts to regain static typing and safety.<br />POSTED BY CRAZY EDDIE AT 3:55 PM   <br />1 COMMENT:</p>
<p><br />user117January 5, 2011 at 2:08 PM<br />Don't you think this Qt's explanation is reasonable:<br />http://doc.qt.nokia.com/4.7/templates.html<br />?</p>