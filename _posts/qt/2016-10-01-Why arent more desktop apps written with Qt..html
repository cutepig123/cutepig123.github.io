<p>Ref&nbsp;http://programmers.stackexchange.com/questions/88685/why-arent-more-desktop-apps-written-with-qt</p>
<p>&nbsp;</p>
<p>I don't really intend this to be a bashing answer, but these are the reasons I do not personally use Qt. There are plenty of good things to say about it -- namely that the API works most of the time, and that it does seamlessly bridge platforms. But I do not use Qt, because:<br />我真的不打算这是一个bashing&nbsp;的答案，但这些都是我不亲自使用Qt的原因。说关于它有很多好东西 - 即该API大部分时间工作，其无缝桥接平台。但我不使用Qt的，因为：<br />In some cases, it just doesn't look like native programs look. Designing a single UI for all platforms inherently is not going to look right when moved from machine to machine, for various visual styling reasons. For example, on Mac machines, split bars are usually relatively thick, and buttons are small and rounded with icons. On Windows machines, split bars are typically narrow, and buttons are more textual, with more square designs. Just because you can write one UI for every platform does not mean that you should for most applications.<br />在某些情况下，它看起来并不像本地程序的外表。例如，在Mac机，拆分条通常比较厚，按钮都很小，使用圆交图标。在Windows计算机上，拆分条是典型的窄，按键上文本更多，更多的方形设计。你可以写一个UI为各种平台，并不意味着你适合大多数应用。<br />Qt is not a C++ library. It requires a separate compilation step, which makes the build process much more complicated when compared with most other libraries.<br />Qt是不是C ++库。它需要一个单独的编译步骤，当与其他大多数库相比，这使得构建过程复杂得多。<br />As a result of (2), C++ IDEs and tools can flag Qt expressions as errors, because they do not understand Qt's specifics. This almost forces use of QtCreator or a textual only editor like vim.<br />由于（2），C ++ IDE和工具可以标志Qt的表达式为错误，因为他们并不了解Qt的特点。这几乎是强制使用QtCreator或文本编辑器如vim。<br />Qt is a large amount of source, which must be present and preinstalled on any machine you use before compiling. This can make setting up a build environment much more tedious.<br />Qt有大量的源代码，必须存在，并预装在计算机上以便编译。这可以使建立一个构建环境更加繁琐。<br />It's available only under LGPL, which makes it difficult to use single-binary-deployment when one needs to release under a more restrictive or less restrictive license.<br />它只能根据LGPL，这使得它难以用单二进制部署<br />It produces extremely large compiled binaries when compared with similarly written "plain ol' native applications" (excepting of course applications written for KDE).<br />当与同样写有&ldquo;纯醇'本机应用程序&rdquo;（除了为KDE编写的课程申请）相比，它产生非常大的编译的二进制文件。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>As people say, each tool fits to each problem and situation...</p>
<p>But if you're C++ programmer, Qt is your framework. No rival.</p>
<p>We develop a complex medical imaging commercial application, and Qt holds on.<br />正如有人说，每个工具适合于每个问题的情况...</p>
<p>但如果你是C ++程序员，Qt是你的框架。没有对手。</p>
<p>我们开发了一个复杂的医疗成像商业应用，使用Qt。</p>
<p>I don't say that the 'cons' that people say about it are false, but I have the feeling that they don't have tried Qt for a long time (its continously improving on each new version...) And, mostly all of the issues they comment are not a problem if you take care.<br />我不会说大家说的&ldquo;弊&rdquo;是假的，但我的感觉是，他们很长一段时间没有尝试过的Qt（其continously提高每个新版本...），并且大多其实他们的问题并不是问题。</p>
<p>UI platform inconsistency: only if you use the UI widgets 'as they are', with no customization or custom art.</p>
<p>Qt preprocessor overload: Only if you abuse of signal-slot mechanism, or QObject inheritance, when there is no really need.</p>
<p>By the way, We still write applications in C#.NET, and been doing it for a long time. So I think I have enouch perspective.</p>
<p>As I said, each tool for each situation,</p>
<p>but Qt is with no doubt a consistent and useful framework.</p>
<p><br />UI平台不一致性：只有当您直接使用UI部件，没有定制的额时候。</p>
<p>Qt的预处理过载：只有当你滥用信号插槽机制，或者QObject的继承。</p>
<p>顺便说一句，我们仍然在写C＃.NET应用程序，并且已经做了很长一段时间。因此，我认为我有足够的视角。</p>
<p>正如我所说的，每一个工具，有适合他的情况，</p>
<p>但Qt是毫无疑问一致和有用的框架。</p>
<p>&nbsp;</p>
<p>Of all the things I don't like about Qt, the fact that it doesn't play well with templates bugs me the most. You can't do this:<br />我最不喜欢Qt的是，它的模板有bug。你不可以这样做：<br />template &lt; typename T &gt;<br />struct templated_widget : QWidget<br />{<br />  Q_OBJECT;</p>
<p>public signals:<br />  void something_happened(T);<br />};<br />It also doesn't play well with the preprocessor. You can't do this:<br />预处理也处理的不好，你不能这样<br />#define CREATE_WIDGET(name,type) \<br />struct name ## _widget : QWidget \<br />{ \<br />  Q_OBJECT; \<br />\<br />public signals: \<br />  void something_happened(type); \<br />}<br />That, mixed with the fact that everything that responds to a signal has to be a Q_OBJECT, makes Qt hard to work in for a C++ programmer. People used to Java or Python style programming probably fair better actually.<br />再就是，每个需要相应信号的都需要时Q_OBJECT，使C ++程序员很难适应Qt。使用Java或Python编程风格可能感觉好一些。</p>
<p>I actually spent a lot of time and effort researching and devising a way to gain type safety back and connect a Qt signal to any functor object: http://crazyeddiecpp.blogspot.com/2011/01/quest-for-sane-signals-in-qt-step-1.html<br />我居然花了很多的时间和精力研究和一边找到一种方式能安全的链接qt信号到任意的functor比如<br />The kind of thing I want to do there is basic, everyday C++ development made next to impossible by the Qt moc...which itself is entirely unnecessary now days, if it ever actually was.<br />这种事情是基本的，载入Qt的MOC ...这本身现在是完全没有必要<br />Frankly though, I'm stuck with it because if you want to do automated UI testing, Qt is pretty much the only game in town short of MFC...which is so 1980 (it sucks working in that shit really hard). Some might say WX but it's got even more serious problems. GTKmm would have been my first choice but since it's all owner drawn and doesn't do accessibility...can't be driven by industry standard testing software. Qt is hard enough in that regard (barely works when you modify the accessibility plugin).<br />坦率地说，虽然，我坚持了下来，因为如果你想要做的自动化UI测试，Qt是几乎唯一的选择。而MFC的...这是1980年的东西。而WX有更严重的问题。 gtkmm的将是我的第一选择，但因为它是由一切所有者和没有做的无障碍...无法通过行业标准的测试软件来驱动。 Qt在这方面不错（你几乎没有修改插件的辅助工作）。</p>
<p>&nbsp;</p>