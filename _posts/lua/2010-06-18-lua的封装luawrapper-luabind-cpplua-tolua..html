<br />       CppLua，跨平台，用法简单，缺点是接口多，且不能向lua注册类。代码质量一般<br />tolua，跨平台，说是automatically bindC/C++ code to Lua，感觉还是说手动比较恰当，接口繁多。<br />luawrapper， 基于魔板，需要boost支持，功能强大，略有瑕疵(例如函数参数个数不能大于9，当然一般情况下，如果函数参数超过5个，恐怕嘿嘿嘿)，代码质量上乘且 代码量最少（少得可怜，个人认为还可以废除1个不太可能用到的类），接口最少，跨平台，目前只支持VC7.0编译器。但略懂魔板编程的话，非常容易修改为 其他编译器支持。<strong>[注：国产]</strong><br /><p>luabind，基于魔板，需要boost支持，功能最强大，是所有封装程序中最好的一个，代码质量上乘（太多大师级别的boost调用，看着好晕），说是跨平台，目前只VC7.0编译器，尝试修改，可惜个人水平过次，没有成功。个人推荐luawrapper</p><p>&nbsp;</p><p><br />       顶下金大大, <br />下载地址<br />CPPlua <a href="http://sourceforge.net/projects/cpplua/" target="_blank">http://sourceforge.net/projects/cpplua/</a><br />tolua <a href="http://www.tecgraf.puc-rio.br/%7Eceles/tolua/" target="_blank">http://www.tecgraf.puc-rio.br/~celes/tolua/</a><br />tolua++ <a href="http://www.codenix.com/%7Etolua/" target="_blank">http://www.codenix.com/~tolua/</a><br />luawrapper <a href="http://www.d2-life.com/LBS/blogview.asp?logID=41" target="_blank">http://www.d2-life.com/LBS/blogview.asp?logID=41</a><br />luabind <a href="http://luabind.sourceforge.net/" target="_blank">http://luabind.sourceforge.net/</a>&nbsp;</p><p>&nbsp;</p><p><h1> 			<a target="_blank" id="ctl04_TitleUrl" href="http://www.cnblogs.com/flying_bat/archive/2007/09/18/897229.html">如何在C++中集成LUA脚本(LuaWrapper For C++篇) </a> 		</h1> 		 		 			为什么要用Lua作脚本？<br />　 　使用Lua作脚本，主要是因为它小巧玲珑（体积小，运行快），而且它的语法又比较简单明了。不过，使用LuaAPI将Lua引擎集成到程序中，确实有一 些不方便&#8212;&#8212;用落木随风网友的话来说，就是"就象用汇编"。当然，现在你不用再这么辛苦了，因为你可以使用LuaWrapper For C++。使用这个工具，在C++中集成Lua脚本就是轻而易举的事。你原有的C++函数和类，几乎不需要任何改变，就可以与Lua脚本共享。<br />　　我们接下来，用实例来说明，如何用LuaWrapper来集成Lua脚本到你的程序中去。<br /><br />1.&nbsp;&nbsp;创建Lua引擎<br />　　LuaWrap lua; 或者 LuaWrap* lua = new LuaWrap;<br />　　创建一个LuaWrap对象，就是创建一个Lua脚本引擎。并且根据Lua的特性，你可以创建任意多个Lua引擎，甚至可以分布在不同的线程当中。<br /><br />2.&nbsp;&nbsp;装载并执行脚本程序<br />　　你可以从缓冲区中装载Lua脚本：<br />　　lua.LoadString(<br />　　　　"print('Hello World')"<br />　　);<br />　　当然，你也可以从文件中装入，并执行Lua脚本：<br />　　Lua.LoadFile("./test.lua");<br />　　Lua的脚本，可以是源代码，也可以经过编译后的中间代码。也许你对编译后的中间代码更感兴趣&#8212;&#8212;如果你不希望让源代码赤裸裸的袒露在大家的眼前。<br /><br />3.&nbsp;&nbsp;获取和设置Lua变量<br />　　能够获取和设置脚本变量的内容，是一个最基本的功能。你可以使用GetGlobal和SetGlobal函数来做到这一点：<br />　　(1)&nbsp;&nbsp;获取变量：<br />　　　　int a = lua.GetGlobal&lt;int&gt;("a");<br />　　　　LuaTable table = lua.GetGlobal&lt;LuaTable&gt;("t");<br />　　　　这里，&lt;&gt; 里头的类型，就是想要的变量的类型。<br />　　(2)&nbsp;&nbsp;设置变量：<br />　　　　lua.SetGlobal("a", a); <br />　　　　lua.SetGlobal("t", table);<br /><br />4.&nbsp;&nbsp;调用Lua函数<br />　　使用Call函数，就可以很简单的从你的程序中调用Lua函数：<br />　　lua.Call&lt;void&gt;("print", "Hello World");<br />　　int sum = lua.Call&lt;int&gt;("add", 2, 3);<br />　　这里，&lt;&gt; 里头的类型是返回值的类型。<br /><br />5.&nbsp;&nbsp;如何让Lua也能调用C++的函数<br />　　精采的地方来了。假如有下面这样的一个函数：<br />　　int add(int a, int b)<br />　　{<br />　　　　return a + b;<br />　　}<br />　　如果想让它能够让Lua使用，只需将它注册到Lua引擎当中就可以了：<br />　　lua.RegisterFunc("add", int(int,int), add);<br />　　这样，Lua中就可以用直接使用了：<br />　　（Lua脚本）sum = add(1, 3) <br /><br />　　(*) RegisterFunc的功能，就是让你把C++的函数注册到Lua中，供Lua脚本使用。<br />　　　　第一个参数，是想要在Lua中用的函数名。<br />　　　　第二个参数，是C++中函数的原型； C++允许函数重载的，你可以使用函数原型，来选择需要注册到Lua引擎中的那个函数。<br />　　　　第三个参数，就是C++中函数的指针了。<br /><br />6.&nbsp;&nbsp;如何能让C++的类在Lua中使用<br />　　我们先看看下面这个C++类：<br />class MyArray<br />{<br />&nbsp;&nbsp;std::vector&lt;double&gt; array;<br />public:<br />&nbsp;&nbsp;void setvalue(int index, double value);<br />&nbsp;&nbsp;double getvalue(int index);<br />&nbsp;&nbsp;int size();<br />&nbsp;&nbsp;const char* ToString();<br />};<br /><br />　　你准备要让Lua能够自由访问并操作这个类。很简单，你只需增加几个宏定义就可以了：<br /><br />class MyArray<br />{<br />&nbsp;&nbsp;std::vector&lt;double&gt; array;<br />public:<br />&nbsp;&nbsp;void setvalue(int index, double value);<br />&nbsp;&nbsp;double getvalue(int index);<br />&nbsp;&nbsp;int size();<br />&nbsp;&nbsp;const char* ToString();<br />&nbsp;&nbsp;// 将一个 class 作为一个 Lua 对象是很容易的，只需要增加以下宏定义。<br />&nbsp;&nbsp;DEFINE_TYPENAME("My.array");<br />&nbsp;&nbsp;BEGIN_REGLUALIB("array")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_create("new", MyArray )&nbsp;&nbsp;// 创建MyArray (注：由于发表的原因，create应为全部大写)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_DESTROY("del", MyArray )&nbsp;&nbsp;// 消除MyArray。<br />&nbsp;&nbsp;END_REGLUALIB()<br />&nbsp;&nbsp;BEGIN_REGLUALIB_MEMBER()<br />&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_FUNC("size", int (MyArray*), &amp;MyArray::size)<br />&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_FUNC("__getindex", double(MyArray*, int), &amp;MyArray::getvalue)&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_FUNC("__newindex", void (MyArray*, int, double), &amp;MyArray::setvalue)<br />&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_FUNC("__tostring", const char* (MyArray*), &amp;MyArray::ToString)<br />&nbsp;&nbsp;&nbsp;&nbsp;LUALIB_ITEM_DESTROY("__gc", MyArray ) &nbsp;&nbsp;// 垃圾收集时消除对象用。<br />&nbsp;&nbsp;END_REGLUALIB_MEMBER()<br />};<br /><br />　　只要有了这些宏定义，这个类就是可以在Lua中使用的类了，我们就可以在Lua中注册这个类了：<br />　　lua.Register&lt;MyArray&gt;()<br /><br />　　这样注册以后，我们在Lua中就可以使用这个类了：<br />　　a = array.new()&nbsp;&nbsp;-- 创建对象，相当于 a = new Myarray<br />　　a[1] = 10&nbsp;&nbsp;-- 调用__newindex，也就是C++中的 a-&gt;setvalue(1, 10)<br />　　a[2] = 20&nbsp;&nbsp;-- 调用__newindex，也就是C++中的 a-&gt;setvalue(2, 20)<br />　　print(<br />　　　　a,&nbsp;&nbsp;-- 调用 __tostring，也就是C++中的 a-&gt;ToString()<br />　　　　a:size(), -- 相当于C++中的 a-&gt;size()<br />　　　　a[1], -- 调用__getindex，也就是C++中的a-&gt;getvalue(1)<br />　　　　a[2]) --调用__getindex，也就是C++中的a-&gt;getvalue(2)<br />　　array.del(a)&nbsp;&nbsp;-- 清除对象，相当于 delete a<br />　　a = nil&nbsp;&nbsp;-- 清空 a，很象C++中的 a = NULL<br /><br />　　当然，你也可以不用del这个对象，而是等待Lua帮你自动进行垃圾回收。在Lua进行垃圾回收时，它会自动调用这个对象的 __gc ，相当于 delete。<br /><br />　　那么，在C++中要创建MyArray对象，并且传递给Lua全局变量怎么办？就象前面讲过的一样，使用SetGlobal：<br />　　MyArray* a = new MyArray; <br />　　lua.SetGlobal("a", a);<br />　　要获取该对象，同样的，应该使用GetGlobal：<br />　　MyArray* a = lua.GetGlobal&lt;MyArray&gt;("a");<br />　　<br />　　对于传递给Lua的对象，就让Lua来管理该对象的生存周期好了。如果你非要删除它的话，你可以使用DelGlobalObject：<br />　　lua.DelGlobalObject&lt;MyArray&gt;("a");<br />　　不过这么做的话，你应当明白你在做什么，因为在Lua的脚本中，可能已经在多处引用了这个对象了。删除了其中一个，将导致其它引用对象失效，从而可能引致系统崩溃。<br /><br />　　(1)&nbsp;&nbsp;DEFINE_TYPENAME("My.array");<br />　　　　定义类型的名称。在Lua中，这个类型名称是唯一用来识别C++类型的，你必须为不同的对象给予不同的名称。<br /><br />　　(2)&nbsp;&nbsp;BEGIN_REGLUALIB("array") &#8230; END_REGLUALIB()<br />　　　　你可以为一个对象定义一个程序库，"array"就是程序库的名字。在程序库中定义的函数是全局函数，在Lua中，使用该函数，需要在函数前加上库的名字，如：array.new（）。通常，程序库会包含创建对象的方法。如：<br />　　　　LUALIB_ITEM_create("new", MyArray )&nbsp;&nbsp;// 创建MyArray (注：由于发表的原因，create应为全部大写)<br />　　　　这样子，你才能在Lua中创建MyArray：<br />　　　　a = array.new()<br />　　<br />　　　　你也可以选择增加一个删除对象操作：<br />　　　　LUALIB_ITEM_DESTROY("del", MyArray ) &nbsp;&nbsp;// 删除MyArray<br />　　　　这样，你就可以直接删除一个对象了：<br />　　　　array.del(a)<br /><br />　　(3)&nbsp;&nbsp;BEGIN_REGLUALIB_MEMBER() &#8230;END_REGLUALIB_MEMBER()<br />　　　　在此处，你可以定义对象的成员函数，也可以重载对象的操作符&#8212;&#8212;是的，就象C++的operator重载。例如：<br />　　　　LUALIB_ITEM_FUNC("__newindex", void (MyArray*, int, double), &amp;MyArray::setvalue)<br />　　　　就是重载 operator[] 操作符。Lua中可重载的操作符还有许多，如：<br /><br />　　　　__getindex：操作符[]，支持读取访问，如 v = a[10]<br />　　　　__newindex：操作符[]，支持赋值访问，如 a[10] = 1.22<br />　　　　__tostring：将变量转换成字串__add：等同于operator +<br />　　　　__add：操作符 ＋<br />　　　　__sub：操作符 &#8211;<br />　　　　__mul：操作符 &#215;<br />　　　　__div：操作符 &#247;<br />　　　　__pow：操作符 ^ (乘方)<br />　　　　__unm：一元操作符 &#8211;<br />　　　　__concat：操作符 .. (字符串连接)<br />　　　　__eq：操作符 == (a ~= b等价于 not a == b)<br />　　　　__lt：操作符 &lt; (a &gt; b 等价于 b &lt; a)<br />　　　　__le：操作符 &lt;= (a &gt;= b 等价于 b &lt;= a，要注意的是，如果没有定义"__le"，则Lua将会尝试将a&lt;=b 转换成 not (b &lt; a) )<br /><br />　　　　__gc：在垃圾回收时调用此函数，相当于C++的析构函数。强烈建议定义此操作符，以免造成内存泄漏等情况。比如：<br />　　　　LUALIB_ITEM_DESTROY("__gc", MyArray ) &nbsp;&nbsp;// 垃圾收集时消除对象用。<br /><br />　　　　(注) 这里要说明一下，在lua中，访问索引操作符是__index，不是__getindex，在luaWrapper库中，为了方便使用，将其映射为__getindex，同时，对__index的定义将会被忽略。<br /><br />　　　　就这么简单。假如你已经有现成的类，而你没有修改该类的权力，如何将其加入到Lua中呢？答案就是，继承它，将把派生类加入到Lua中。<br /><br />结束语<br />　 　LuaWrapper 需要用到boost库的支持：boost/type_traits.hpp, boost/function.hpp, boost/bind.hpp，它使用了C++的模板部份特化，因此，C++编译器如果不支持此特性，将无法编译。目前支持此特性的编译器已经有很多。在 VisualStudo产品系列中，只有VC7.1能支持此特性，因此，您如果正在使用VisualStudio，请确认你用的是 VisualStudio2003。<br />　　如果你觉得 LuaWrapper For C++ 能够帮助你，我会感觉很荣幸。我很愿意将这个程序库分享给大家。顺便一提的是，如果你在使用过程中发现BUG，或是有好的建议，希望您能与我联系。你在使 用过程中，请不要删除文件中的署名信息；如果你修改了程序库，请您在修改的文件中加入您的修改说明。当然，我会非常欢迎您能将修改后的程序回馈给我。我会 继续优化并完善它。<br /><br />=============================================================<br /><br /><a target="_blank" href="http://www.d2-life.com/lbs/attachments/month_200407/22_1xp4LuaWrapper.zip"><img src="http://www.d2-life.com/lbs/images/icon_save.gif" align="absMiddle" border="0"  alt="" /><strong>File:</strong> Click Here Download: LuaWrapper For C++</a><br /><a target="_blank" href="http://www.d2-life.com/lbs/attachments/month_200407/22_85waTestLua.zip"><img src="http://www.d2-life.com/lbs/images/icon_save.gif" align="absMiddle" border="0"  alt="" /><strong>File:</strong> Click Here Download: LuaWrapper test program</a>&nbsp;</p>