<h2>发掘Scons<span class="category"> - [<a href="http://bigwhite.blogbus.com/c1678111/">开源世界</a>]</span></h2>
                                    <div class="tags">Tag：<a href="http://bigwhite.blogbus.com/tag/%E5%BC%80%E6%BA%90%E4%B8%96%E7%95%8C/">开源世界</a> </div>
                                
                                
                                    <p class="cc-lisence" style="line-height: 180%;">
<a href="http://creativecommons.org/licenses/by/3.0/deed.zh" target="_blank">版权声明</a>：转载时请以超链接形式标明文章原始出处和作者信息及<a href="http://bangzhuzhongxin.blogbus.com/logs/11205960.html" target="_blank">本声明</a><br><a href="http://bigwhite.blogbus.com/logs/32477272.html">http://bigwhite.blogbus.com/logs/32477272.html</a><br><br>
</p>发现或者说知道<a href="http://www.scons.org/" target="_blank">SCons</a>是缘于Google的<a href="http://groups.google.com/group/comp.lang.c/topics?hl=en" target="_blank">comp.lang.c group</a>上的一则名为"<a href="http://groups.google.com/group/comp.lang.c/browse_thread/thread/cc51287c88c85bcb?hl=en" target="_blank">Best Build Tool for large C projects</a> "的帖子，帖子的作者列出了11条他认为"Best Build Tool"应该具备的特点，并欲找到这样的Build Tool。在该帖子的回复中，有人提到了Scons，说来惭愧，这是我第一次听说到有这样一个工具。一直在Unix下编写<a href="http://en.wikipedia.org/wiki/C_%28programming_language%29" target="_blank">C程序</a>，习惯了Make，也对Make的复杂度和较为陡峭的学习曲线有所了解，曾经尝试使用<a href="http://www.gnu.org/software/autoconf/" target="_blank">Autoconf</a>和<a href="http://www.gnu.org/software/automake/" target="_blank">Automake</a>，但是都因上手困难而放弃。自己心底也一直想找到一个更简单一些的但又不失功能的适合C的Build Tool，Scons是否能满足的需要的呢？好奇心驱使着我去发掘一下Scons。<br><br>工具的进化一直在持续着。高手能把<a href="http://www.gnu.org/software/make/" target="_blank">Make</a>玩
弄于股掌之中，但是大多数人水平还是一般的，在经历了"Make
hell"后他们要寻求更简单、更人性的工具，这也是工具进化的动力之一。Scons是用Python实现的一款跨平台的开源Build
Tool，用Python实现意味着Scons比Make所使用的类Shell语言更贴近于自然语言，更易于理解和控制；用Python实现的另一个好处
也是Make所不具备的就是很好的跨平台能力，一次编写Build脚本，在多种平台上无需修改即可运行无误，特别是从Unix-&gt;Windows这
样的移植，如果使用Make则势必要修改。<br><br>先简单说说Scons的安装，要运行Scons势必你的机器上要有<a href="http://www.python.org/" target="_blank">Python</a>，虽然<a href="http://www.python.org/download/releases/3.0/" target="_blank">Python 3.0</a>已经Release，但目前主流Python开源项目仍然在用2.x版本。我的机器上安装的就是Python 2.5。下载<a href="http://jaist.dl.sourceforge.net/sourceforge/scons/scons-1.1.0.zip" target="_blank">Scon-1.10稳定版</a>，unzip，进入unzip后的目录，执行安装命令：python setup.py install即可。Scons会被安装到默认目录下，如果你想指定安装目标目录的话，可以使用--prefix=YOUR_INSTALL_DIR参数。<br><br>按照惯例，我们先来一个"<a href="http://zh.wikipedia.org/wiki/Hello_World" target="_blank">Hello, World!</a>"的例子，在你的测试目录下，编写一个HelloWorld.c<br>/* HelloWorld.c */<br>#include &lt;stdio.h&gt;<br>&nbsp;<br>int main(int argc, char* argv[])<br>{<br>&nbsp;&nbsp; printf("Hello, world!\n");<br>&nbsp;&nbsp; return 0;<br>}<br>在同一级目录下，建立一个新文件SConstruct，编辑该文件，输入内容：<br>Program('HelloWorld.c')<br>在命令行下执行scons，一个名为HelloWorld.exe的可执行文件(在Unix下可执行文件为HelloWorld)被编译链接成功。第一次上手成功会给使用者带来莫大的成就感，提高该使用者继续发掘该工具的可能性。<br><br>SConstruct
是个什么文件？SConstruct之于Scons就好比Makefile之于Make；它是Scons的输入，SConstruct中的内容采用的是
Python的语法，而Python的语法比较简单，这样很容易被接受，而Program则只是一个方法调用。
Program('HelloWorld.c')意味着告诉Scons我要将HelloWorld.c编译成一个名为‘HelloWorld.exe'的
可执行文件，当然了Scons会自动分析HelloWorld.c，自动得出目标程序名字。<br><br>我们日常工作构建代码的类型不外乎如下几种：
简单一点的包括编译object文件、构建静态库、构建动态链接库和构建可执行程序；复杂的则是要对一个拥有众多目录和几十万、上百万行代码的项目进行整
体体系构建，而复杂的构建也是由一系列的简单构建组合而成的，我们先说说简单类构建。<br><br>HelloWorld例子只是一个最简单的由单个源文件构建程序的例子，现实中我们构建可执行程序可能依赖的不止是一个文件，可能还有头文件或链接其他第三方库；下面这个SConstruct文件中的语句就是一个稍微复杂些的例子：<br>Program(target
= 'test', source = ['main.c', 'file1.c', 'file2.c'], LIBS = ['lib1',
'lib2'], LIBPATH = ['lib1/lib', 'lib2/lib'], CPPPATH = ['include',
'/lib1/include', 'lib2/include'], CCFLAGS='-D_DEBUG')<br><br>这个例子中具备我们常用
的诸多元素，这些参数中：'test'是构建后的程序名，source是一个源文件数组，LIBPATH则是要链接库的目录数组，LIBS是要链接的具体
的库文件的名字。CPPPATH则是-I的替代品，是头文件所在目录的数组，CCFLAGS则是负责传递编译器的编译选项参数。<br><br>通过这些Keyword Arguments，Scons可以在用户和编译器之间传递信息，并控制编译器完成构建。同样的，编译目标文件，构建静态库、动态库可以由下面的一些builder来完成。<br><br>Library('foo', ['f1.c', 'f2.c', 'f3.c'])&nbsp;&nbsp; #生成名为foo的静态库，在Windows上是foo.lib，在unix上为libfoo.a<br>&lt;=&gt; StaticLibrary('foo', ['f1.c', 'f2.c', 'f3.c']) #生成名为foo的静态库，在Windows上是foo.lib，在unix上为libfoo.a<br>SharedLibrary('foo', ['f1.c', 'f2.c', 'f3.c']) #生成名为foo的动态库，在Windows上是foo.dll，在unix上为libfoo.so<br>Object('add.c') #生成名为add的目标文件，在Windows上是add.obj，在unix上为add.o<br><br>Scons没有明显的依赖定义，Scons会为我们自动扫描依赖。我们只需告诉它构建出一个目标需要什么即可。Scons检查依赖关系中的文件变化的方法，除了通过时间戳，还可以通过<a href="http://en.wikipedia.org/wiki/MD5" target="_blank">MD5</a>来判别，你可以通过设置Env来决定使用哪个。另外更强大的是你也可以自己编写文件更新检查方法放到SConstruct中被Scons调用，这些都是高级一些的功能，这里不细说，详情可参见Scons的<a href="http://www.scons.org/doc/1.1.0/HTML/scons-user/book1.html" target="_blank">doc</a>。<br><br>前面说过，实际项目的代码往往不可能都放到单一目录下，而是按照一定规则被放到有层次结构的目录体系中，Scons提供一个叫SConscript的方法支持这种情形。下面用一个复杂一些的例子来说明这种情形。<br>我们假设有一项目的目录结构如下：<br>- Test_Proj<br>&nbsp;&nbsp; &nbsp;- SConstruct<br>&nbsp;&nbsp; &nbsp;- include<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- base.h<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- module1.h<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- module2.h <br>&nbsp;&nbsp; &nbsp;- main<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- main.c<br>&nbsp;&nbsp; &nbsp;- module1<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- module1.c<br>&nbsp;&nbsp; &nbsp;- module2<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- module2.c<br>&nbsp;&nbsp; &nbsp;- xlib<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- include<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- xlib_base.h<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- add.h<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- sub.h<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- add<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- add.c<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- sub<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- sub.c<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- lib<br>针对该Proj，我们要将整个工程构建为一个可执行程序。简单分析一下，这个程序依赖xlib下的两个库以及main、module1和module2下的多个目标文件，这样顶层的SConstruct文件大致应该是这样的：<br>SConscript(['xlib/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'module1/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'module2/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'main/SConscript'])<br>obj_files = ['main/main.obj', 'module1/module1.obj', 'module2/module2.obj']<br>Program('test-main', obj_files, LIBS = ['add', 'sub'], LIBPATH = 'xlib/lib')<br><br>在
顶层执行Scons时，Scons将递归的执行子目录下的SConscript，最后将SConscript执行后的成果放入到Program中进行
build。在module1、module2和main下面的SConscript则负责将本目录下的.c编译为目标文件，大致是这样的：<br>Object('module1.c', CPPPATH=['../include', '../xlib/include'])<br><br>而在xlib下的SConscript文件如下：<br>SConscript(['add/SConscript', 'sub/SConscript']) # 调用两个子目录下的SConscript<br><br>add和sub下的SConscript完成的是将目录下的文件编译成静态库后，copy到上层目录的lib下：<br>libfile = StaticLibrary('sub.c', CPPPATH = ['../include'])<br>libfilename = str(libfile[0])<br>Command('../lib/'+ libfilename, libfilename, Copy("$TARGET", "$SOURCE")) <br><br>编辑好所有文件后，在顶层执行scons，工程被顺利编译。如果想clean proj，我们无需像Make那样写一个clean target，而是直接执行scons -c即可完成clean。<br><br>上
面的SConstruct虽然可以正确的进行项目构建，但是还有缺陷，Scons一个大的优点就是有很好的可移植性，但是上面的SConstruct
中，obj_files中显式的出现了.obj字样，这在Windows平台是没有问题的，但是在unix等其他平台上则会构建错误。<br><br>解决这个问题的方法就是通过环境参数自动获得目标文件的后缀，见下面代码：<br># SConstruct<br>import os<br><br>env = Environment();<br>dict = env.Dictionary()<br>objsuffix = dict['OBJSUFFIX']<br><br>SConscript(['xlib/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'module1/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'module2/SConscript',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'main/SConscript'])<br>obj_files = ['main/main'+objsuffix, 'module1/module1'+objsuffix, 'module2/module2'+objsuffix]<br>Program('test-main', obj_files, LIBS = ['add', 'sub'], LIBPATH = 'xlib/lib')<br><br>上
面只是一个能满足初步build工程的示例，但绝不是理想的SConstruct。如果你对Python非常熟悉(我连Python的初学者都不算
^_^)，相信会有更多的技巧来组织SConstruct。经过上面的例子的实践，我发现Scons基本功能上不逊色于Make，而易理解方面则要远好于
Make。有人说在项目规模较大时，Scons性能被人质疑。但至少我目前还没有什么数据可参考。<br><br>在工作中，我们不是每次都去重新在顶层
进行build，而是在某个src目录下局部编译进行语法检查，比如只在module1下将module1.c编译为目标文件，在Scons中，我们可以
用以下命令来完成这个功能：scons -f SConscript；同样如果只在module1下clean，可以执行scons -f
SConscript -c；在这方面Scons的确比make多输入一些命令字符，不过你可以想办法(比如设置alias)解决这个问题。<br><br>这次先发掘到这，Scons还有很多高级功能，在其<a href="http://www.scons.org/doc/1.1.0/HTML/scons-user/book1.html" target="_blank">Doc</a>里有说明，有需要者自取^_^。<div class="relpost"><br><h3>随机文章：</h3><div><a href="http://bigwhite.blogbus.com/logs/35797428.html">“扶正”Bash Shell</a> 2009-02-27</div><div><a href="http://bigwhite.blogbus.com/logs/35619026.html">CSCOPE使用中问题小解</a> 2009-02-23</div><div><a href="http://bigwhite.blogbus.com/logs/33121799.html">VIM“重装上阵”</a> 2008-12-30</div><div><a href="http://bigwhite.blogbus.com/logs/32790581.html">使用Scons改造现有项目</a> 2008-12-21</div><div><a href="http://bigwhite.blogbus.com/logs/32606027.html">为Ubuntu下的Firefox提速</a> 2008-12-17</div></div><div class="addfav"><br>收藏到：<span class="delicious"><a href="http://delicious.com/save?url=http%3A%2F%2Fbigwhite.blogbus.com%2Flogs%2F32477272.html&amp;title=%E5%8F%91%E6%8E%98Scons" target="_blank">Del.icio.us</a></span></div>