<p>最近想把写过的一个多线程程序整理一下，这个程序主要特点是有一系列的互相之间有依赖关系的task。于是在网上找相关类库</p>
<p><br />1，一类是简单的线程池了，这也是原本俺的做法。之前使用的是手工调度，代码实现的很蛋疼。<br />外面的lib有poco https://pocoproject.org/slides/130-Threads.pdf<br /><br />3，微软的并行库<br />1）MS PPL （Parallel Patterns Library）之类的类库，感觉这里一类本质上和1没有大的分别<br />2）MS tpl (Task Parallel Library) ，是Dataflow，可以显式指明task之间的依赖关系<br />https://msdn.microsoft.com/en-us/library/hh228603(v=vs.110).aspx<br />http://blog.i3arnon.com/2016/05/23/tpl-dataflow/<br />3） MS Asynchronous Agents Library ，没研究，抽空看看</p>
<p>Update 20161220： 貌似大家对这个actor model不满意，他实现得不够完整，并且很久没有更新。 http://www.cnblogs.com/cutepig/p/6206114.html<br />https://msdn.microsoft.com/en-us/library/dd492627.aspx<br />https://msdn.microsoft.com/en-us/library/ff601928.aspx<br />4) MS Concurrency Runtime，没看过，有时间研究下<br />From stackoverflow， The concurrency runtime is a cooperative scheduling infrastructure也就是说需要task互相协作，如果某个task是io密集的，就不适合？<br />https://msdn.microsoft.com/en-us/library/ff601929.aspx<br />https://msdn.microsoft.com/en-us/library/dd504870.aspx<br />5) AMP https://msdn.microsoft.com/en-us/library/hh265137.aspx<br />6） MS CCR （Concurrency and Coordination Runtime）<br />https://msdn.microsoft.com/en-us/library/bb648752.aspx</p>
<p>more<br />https://msdn.microsoft.com/zh-cn/library/ff963546.aspx</p>
<p>3, 有人说过asyn, future之类，但这一类其实都没有优化task调度</p>
<p>6， actor model<br />貌似这是普遍的公认的并行处理方法，其好处是task互相隔离，通过发消息彼此通信实现同步</p>
<p>caf： https://www.actor-framework.org/	c++11的写法比较爽<br />	caf读书笔记 http://www.cnblogs.com/zhejiangxiaomai， http://blog.csdn.net/xzwdev/article/details/41700001， http://wenku.baidu.com/view/7e2b6be16529647d2728528e.html， https://arxiv.org/pdf/1505.07368.pdf，https://pdfs.semanticscholar.org/9bc2/003f58a240143bcfdb1f58183e8a172b7d05.pdf，https://www.meetup.com/ACCU-Bay-Area/events/233766624/<br />Theron	写法有点蛋疼，但其实可以用c++11包一层的<br />SObjectizer</p>
<p>skynet https://github.com/cloudwu/skynet/wiki<br />https://github.com/i11cn/simple-cpp-actor</p>
<p>7，task dependency based c++ library <br />这一类稳定的类库比较少，很多都是用来写paper<br />其实可以在actor model包装一层函数实现这一类的用法</p>
<p>比如 SuperGlue: http://tillenius.github.io/superglue/ It's a C++98 header-only library for tasks with dependencies between them.<br />https://github.com/RichieSams/FiberTaskingLib<br />http://www.des.udc.es/~basilio/papers/Gonzalez13-DepSpawn.pdf</p>
<p>papers<br />http://www.ademiller.com/tech/reports/paraplop_2010_the_task_graph_pattern.pdf<br />8，intel 的类库<br />1）tbb<br />2）cnc （Concurrent Collections for C++）<br />https://icnc.github.io/api/tutorial.html<br />据说很不同，有空研究下</p>
<p>3）intel tbb-flow-graph<br />https://www.threadingbuildingblocks.org/tutorial-intel-tbb-flow-graph</p>
<p>9，hpx http://stellar.cct.lsu.edu/files/hpx-0.9.99/html/hpx/tutorial/examples/accumulator.html<br />没研究过<br />10，Spark <br />没研究过<br />11，相关资料<br />Stream processing	https://en.wikipedia.org/wiki/Stream_processing<br />Dataflow programming <br />Actor model<br />Data-driven programming<br />Digital signal processing<br />Event-driven programming<br />Flow-based programming	https://en.wikipedia.org/wiki/Flow-based_programming<br />Functional reactive programming<br />Glossary of reconfigurable computing<br />High-performance reconfigurable computing<br />Incremental computing<br />Parallel programming model<br />Partitioned global address space<br />Signal programming<br />Stream processing<br />Pipeline (Unix)<br />Yahoo Pipes</p>