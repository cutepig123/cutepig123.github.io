---
categories: cpp
---
asio



# asio的設計簡單而强大

https://www.crazygaze.com/blog/2016/03/04/boost-asio-thread-safety-and-reinventing-the-wheel/

- 为什么 

  tcp :: acceptor

   仅用于接受连接而不管理它们？为什么没有整洁的服务器类很好地聚合所有连接？然后，在使用它时，将其作为基本服务器类，因为更多的OOP只能是一件好事，并且让该基本类调用您的虚拟方法来获得所有好东西吗？

  - 最好不要尝试猜测应用程序需要什么。库猜的次数越多，最终处理对象生存期问题，多线程问题或死锁的原因就越多，因为您（a）需要保护数据；（b）在某些情况下，您还需要调用应用程序代码。因此，库无法猜测在这些回调/虚拟函数中您将要做什么。

- 为什么大多数Asio类不是线程安全的？在这个多核疯狂的时代，您当然希望所有事情都是线程安全的！

  - 并不是的。同上。最好不要尝试进行任何猜测，而将其留给应用程序。
  - 这次在乐队训练营中，我试图使我的网络库完全线程安全！最终效果不佳。当您认为一切都很好并且您的单元测试如此说时，您自豪地决定将您的单元测试放在一个晚上进行循环，直到数小时后出现随机崩溃或死锁。没关系。这只是您需要修复的另一种情况，对吗？

- 为什么Boost Asio保证仅在执行io_service :: run（或run_one（），poll（），poll_one（））的线程中确保一次调用处理程序？

  - 一致性。您无需猜测在大多数情况下会发生什么。处理程序中止了吗？您仍然可以通过处理非中止的处理程序的方式来了解它。

- 我到底需要

  io_service :: strand

  干什么？

  - 因此，尝试创建线程安全的处理程序不会使您一团糟。
  - 因此，您不会因为尝试为同一连接提供服务而阻塞所有IO线程，而只是因为该连接的特定处理程序决定退出以获取一品脱并锁上了门。

创建非平凡的线程安全代码总是比看起来困难。这是我开发先前的网络层…

![img](img_56d8c344c40e7.png)



# 异步编程和多线程有什么区别？

https://www.quora.com/What-is-the-difference-between-asynchronous-programming-and-multi-threading

## 线程

对于大多数程序员来说，线程化**似乎更简单**，因为他们仍然可以顺序地围绕I / O操作进行思考。由于必须开始在线程之间添加同步，因此**逐渐变得痛苦**，后来，当与内核相比，线程环境增加了10倍时，线程环境无法扩展。

## 异步编程

异步编程从**一开始就很尴尬**，因为程序员需要先思考更多，将“开始”操作与“完成”操作分开，并在等待时找到要做的事情。这可能涉及队列的显式管理。异步编程可以在单个线程上实现惊人的扩展。

更高级别的框架和语言使异步编程更加容易，尤其是在使用lambda，闭包和承诺处理补全的情况下。这些的缺点是在**调试**中，因为您会从地狱获得堆栈跟踪。最好的例子可能是node.js。

**可扩展性最高**的高性能系统执行异步I / O，并为可用的CPU使用正确数量的线程。从高层来看，似乎没有太多轻量级的事情可以做到这一点。



# 并行編程之work steal算法