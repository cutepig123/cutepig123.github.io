<div class="post"> 	<div class="postTitle"> 		<a id="viewpost1_TitleUrl" href="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html">CAsyncSocket对象不能跨线程之分析</a> 	</div><p>http://blog.vckbase.com/arong/archive/2005/12/03/15578.html</p><p>&nbsp;</p> 	 	<div class="postText"> 		<h2>现象</h2> 用多线程方法设计socket程序时，你会发现在跨线程使用CAsyncSocket及其派生类时，会出现程序崩溃。所谓跨线程，是指该对象在一个线程中 调用Create/AttachHandle/Attach函数，然后在另外一个线程中调用其他成员函数。下面的例子就是一个典型的导致崩溃的过程： <pre>CAsyncSocket Socket;<br />UINT Thread(LPVOID)<br />{<br />       Socket.Close ();<br />       return 0;<br />}<br />void CTestSDlg::OnOK() <br />{<br />       // TODO: Add extra validation here<br />       Socket.Create(0);<br />       AfxBeginThread(Thread,0,0,0,0,0);<br />}<br /></pre> <p>其中Socket对象在主线程中被调用，在子线程中被关闭。 </p><h2>跟踪分析</h2> <p>这个问题的原因可以通过单步跟踪(F11)的方法来了解。我们在Socket.Create(0)处设断点，跟踪进去会发现下面的函数被调用： </p><pre>void PASCAL CAsyncSocket::AttachHandle(<br />          SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead)<br />{<br />    _AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;<br />    BOOL bEnable = AfxEnableMemoryTracking(FALSE);<br />    if (!bDead)<br />    {<br />             ASSERT(CAsyncSocket::LookupHandle(hSocket, bDead) == NULL);<br />             if (pState-&gt;m_pmapSocketHandle-&gt;IsEmpty())<br />             {<br />                  ASSERT(pState-&gt;m_pmapDeadSockets-&gt;IsEmpty());<br />                  ASSERT(pState-&gt;m_hSocketWindow == NULL);<br />                  CSocketWnd* pWnd = new CSocketWnd;<br />                  pWnd-&gt;m_hWnd = NULL;<br />                  if (!pWnd-&gt;CreateEx(0, AfxRegisterWndClass(0),<br />                                   _T("Socket Notification Sink"),<br />                                 WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL))<br />                 {<br />                       TRACE0("Warning: unable to create socket notify window!\n");<br />                       AfxThrowResourceException();<br />                 }<br />                 ASSERT(pWnd-&gt;m_hWnd != NULL);<br />                 ASSERT(CWnd::FromHandlePermanent(pWnd-&gt;m_hWnd) == pWnd);<br />                 pState-&gt;m_hSocketWindow = pWnd-&gt;m_hWnd;<br />            }<br />            pState-&gt;m_pmapSocketHandle-&gt;SetAt((void*)hSocket, pSocket);<br />    }<br />    else<br />    {<br />           int nCount;<br />           if (pState-&gt;m_pmapDeadSockets-&gt;Lookup((void*)hSocket, (void*&amp;)nCount))<br />                     nCount++;<br />           else<br />                     nCount = 1;<br />           pState-&gt;m_pmapDeadSockets-&gt;SetAt((void*)hSocket, (void*)nCount);<br />   }<br />   AfxEnableMemoryTracking(bEnable);<br />}<br /></pre> <p>在这个函数的开头，首先获得了一个pState的指针指向_afxSockThreadState对象。从名字可以看出，这似乎是一个和线程相关的变量，实际上它是一个宏，定义如下：</p> <pre>#define _afxSockThreadState AfxGetModuleThreadState()<br /></pre> <p>我们没有必要去细究这个指针的定义是如何的，只要知道它是和当前线程密切关联的，其他线程应该也有类似的指针，只是指向不同的结构。</p> <p>在这个函数中，CAsyncSocket创建了一个窗口，并把如下两个信息加入到pState所管理的结构中： </p><pre>    pState-&gt;m_pmapSocketHandle-&gt;SetAt((void*)hSocket, pSocket);<br />    pState-&gt;m_pmapDeadSockets-&gt;SetAt((void*)hSocket, (void*)nCount);<br />    pState-&gt;m_hSocketWindow = pWnd-&gt;m_hWnd;<br />    pState-&gt;m_pmapSocketHandle-&gt;SetAt((void*)hSocket, pSocket);<br /></pre> <p>当调用Close时，我们再次跟踪，就会发现在KillSocket中，下面的函数出现错误:  </p><pre>    void PASCAL CAsyncSocket::KillSocket(SOCKET hSocket, CAsyncSocket* pSocket)<br />    {<br />            ASSERT(CAsyncSocket::LookupHandle(hSocket, FALSE) != NULL);<br /></pre> <p>我们在这个ASSERT处设置断点，跟踪进LookupHandle，会发现这个函数定义如下： </p><pre>CAsyncSocket* PASCAL CAsyncSocket::LookupHandle(SOCKET hSocket, BOOL bDead)<br />{<br />     CAsyncSocket* pSocket;<br />     _AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;<br />     if (!bDead)<br />     {<br />             pSocket = (CAsyncSocket*)<br />             pState-&gt;m_pmapSocketHandle-&gt;GetValueAt((void*)hSocket);<br />             if (pSocket != NULL)<br />                  return pSocket;<br />    }<br />    else<br />    {<br />             pSocket = (CAsyncSocket*)<br />                  pState-&gt;m_pmapDeadSockets-&gt;GetValueAt((void*)hSocket);<br />             if (pSocket != NULL)<br />                   return pSocket;<br />    }<br />    return NULL;<br />}<br /></pre> <p>显然，这个函数试图从当前线程查询关于这个 socket的信息，可是这个信息放在创建这个socket的线程中，因此这种查询显然会失败，最终返回NULL。 </p> <p>有人会问，既然它是ASSERT出错，是不是Release就没问题了。这只是自欺欺人。ASSERT/VERIFY都是检验一些程序正常运行必须正确的条件。如果ASSERT都失败，在Release中也许不会显现，但是你的程序肯定运行不正确，啥时候出错就不知道了。</p> <h2>如何在多线程之间传递socket</h2> <p>有些特殊情况下，可能需要在不同线程之间传递socket。当然我不建议在使用CAsyncSOcket的时候这么做，因为这增加了出错的风险（尤其当出现拆解包问题时，有人称为粘包，我基本不认同这种称呼）。如果一定要这么做，方法应该是： </p><ol type="1"><li>当前拥有这个socket的线程调用Detach方法，这样socket句柄和C++对象及当前线程脱离关系 </li><li>当前线程把这个对象传递给另外一个线程 </li><li>另外一个线程创建新的CAsyncSocket对象，并调用Attach </li></ol> <p>上面的例子，我稍微做修改，就不会出错了： </p><pre>CAsyncSocket Socket;<br />UINT Thread(LPVOID sock)<br />{<br />         Socket.Attach((SOCKET)sock);<br />         Socket.Close ();<br />         return 0;<br />}<br />void CTestSDlg::OnOK() <br />{<br />         // TODO: Add extra validation here<br />         Socket.Create(0);<br />         SOCKET hSocket = Socket.Detach ();<br />         AfxBeginThread(Thread,(LPVOID)hSocket,0,0,0,0);<br />}<br /></pre> 	</div> 	 	<div class="postfoot"> 		posted on 2005-12-03 14:08 馨荣家园 阅读(6771) <a href="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html#Post">评论(15)</a> &nbsp;<a href="http://blog.vckbase.com/arong/admin/EditPosts.aspx?postid=15578">编辑</a>&nbsp;<a href="http://blog.vckbase.com/arong/AddToFavorite.aspx?id=15578">收藏</a> 	</div> </div> <div id="main">  <!-- <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"> <rdf:Description rdf:about="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html" dc:identifier="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html" dc:title="CAsyncSocket对象不能跨线程之分析" trackback:ping="http://blog.vckbase.com/arong/services/trackbacks/15578.aspx" /> </rdf:RDF> -->   <a name="评论"> <br /> </a><div id="comments"> <a name="评论">	</a><h3><a name="评论">评论</a></h3> <a name="评论">		 		 				</a><div class="post"><a name="评论">			 					</a><div class="postTitle"> <a name="评论">						</a><a title="permalink: re: CAsyncSocket对象不能跨线程之分析" href="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html#17736">#</a>&nbsp;<a name="17736"></a>re: CAsyncSocket对象不能跨线程之分析 							<span> 								2006-02-15 15:42 							</span> 						<a id="Comments1_CommentList__ctl0_NameLink" target="_blank">ocean</a> 					</div> 					<div class="postText"> 						很好！ 						<br /> 						 					</div> 				</div> 				<br /> 			 				<div class="post">			 					<div class="postTitle"> 						<a title="permalink: re: CAsyncSocket对象不能跨线程之分析" href="http://blog.vckbase.com/arong/archive/2005/12/03/15578.html#18129">#</a>&nbsp;<a name="18129"></a>re: CAsyncSocket对象不能跨线程之分析 							<span> 								2006-03-02 22:55 							</span> 						<a id="Comments1_CommentList__ctl1_NameLink" target="_blank">babazhang</a> 					</div> 					<div class="postText"> MSDN里给出的是一句不痛不痒的话，CSocket&nbsp;/CAsyncSocket&nbsp;is&nbsp;not&nbsp;thread-safety.&nbsp;&nbsp;说白了就是数据一旦 跟窗口搭上钩后，消息循化就会和子线程有数据竞争，而socket缓冲区是没有采用同步对象保护的，所以就会不安全。 </div><p>&nbsp;</p><p>------------分割线-----------------</p><p>&nbsp;</p><p>&nbsp;CSocket多线程<br /><br />//公有变量 &nbsp;<br />&nbsp; CSocket&nbsp;&nbsp; ServerSocket; &nbsp;<br />&nbsp; CSocket&nbsp;&nbsp; ClientSocket; &nbsp;<br />&nbsp; //主程序 &nbsp;<br />&nbsp; { &nbsp;<br />&nbsp; ServerSocket.Create(m_Port);//创建监听端口 &nbsp;<br />&nbsp; ServerSocket.Listen(-1); &nbsp;<br />&nbsp; while(true) &nbsp;<br />&nbsp; { &nbsp;<br />&nbsp; ServerSocket.Accept(ClientSocket); &nbsp;<br />&nbsp; clientCount+=1; &nbsp;<br />&nbsp; SOCKET&nbsp;&nbsp; hSocket=NULL; &nbsp;<br />&nbsp; hSocket = ClientSocket.Detach(); //获得句柄 &nbsp;<br />&nbsp; if(ClientSocket&nbsp;&nbsp; !=NULL&nbsp;&nbsp; &amp;&amp;&nbsp;&nbsp; clientCount&lt;=Maxnum)//连接用户未超过限制 &nbsp;<br />&nbsp; { &nbsp;<br />&nbsp; AfxBeginThread(Listened,(LPVOID)hSocket,THREAD_PRIORITY_NORMAL); //启动线程 &nbsp;<br />&nbsp; } &nbsp;<br />&nbsp; else &nbsp;<br />&nbsp; { &nbsp;<br />&nbsp; .... &nbsp;<br />&nbsp; } &nbsp;<br />&nbsp; } &nbsp;<br />&nbsp; &nbsp;<br />&nbsp; &nbsp;<br />&nbsp; 线程： &nbsp;<br />&nbsp;UINT&nbsp;&nbsp; Listened&nbsp;&nbsp; (LPVOID&nbsp;&nbsp; pParam) &nbsp;<br />&nbsp; { &nbsp;<br />&nbsp; SOCKET&nbsp;&nbsp; sock&nbsp;&nbsp; =(SOCKET)pParam; &nbsp;<br />&nbsp; CSocket&nbsp;&nbsp; sockRecv; &nbsp;<br />&nbsp; sockRecv.Attach(sock); &nbsp;<br />&nbsp; ....... &nbsp;<br />&nbsp; return&nbsp;&nbsp; 0; &nbsp;<br />&nbsp; } &nbsp;<br />&nbsp; s<br />&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;<br />设置connet超时<br />int&nbsp;&nbsp; ioctlsocket( &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET&nbsp;&nbsp; s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp; cmd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_long&nbsp;&nbsp; FAR&nbsp;&nbsp; *argp&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp; ); &nbsp;<br />&nbsp; &nbsp;<br />&nbsp; cmd&nbsp;&nbsp; =&nbsp;&nbsp; FIONBIO&nbsp;&nbsp; ; &nbsp;<br />&nbsp; argp&nbsp;&nbsp; =&nbsp;&nbsp; 10000;<br />&nbsp; <br />&nbsp; 设置发送超时<br />&nbsp; /set&nbsp;&nbsp; time&nbsp;&nbsp; out &nbsp;<br />&nbsp; int&nbsp;&nbsp; TimeOut=6000;&nbsp;&nbsp; &nbsp;<br />&nbsp; if(::setsockopt(cClient,SOL_SOCKET,SO_SNDTIMEO,(char&nbsp;&nbsp; *)&amp;TimeOut,sizeof(TimeOut))==SOCKET_ERROR){ &nbsp;<br />&nbsp; return&nbsp;&nbsp; 0; &nbsp;<br />&nbsp; }<br />&nbsp; 下面这个什么意思??<br />&nbsp; select(sock,&nbsp;&nbsp; &amp;Socket_Read,(fd_set&nbsp;&nbsp; *)&nbsp;&nbsp; 0,(fd_set&nbsp;&nbsp; *)&nbsp;&nbsp; 0,&amp;timeout); &nbsp;<br />&nbsp;&nbsp; <br /></p></div></div></div>