<p>oc</p>
<p>Short list of some of the major differences:</p>
<p>C++ allows multiple inheritance, Objective-C doesn't.<br />一个允许多继承，一个不允许<br />Unlike C++, Objective-C allows method parameters to be named and the method signature includes only the names and types of the parameters and return type (see bbum's and Chuck's comments below). In comparison, a C++ member function signature contains the function name as well as just the types of the parameters/return (without their names).<br />OC允许参数命名，方法的signature包含了名称，包括参数类型，返回类型。<br />而c++的成员函数signature包含函数名，和参数类型，返回类型，不包括名字<br />C++ uses bool, true and false, Objective-C uses BOOL, YES and NO.<br />bool的不同<br />C++ uses void* and nullptr, Objective-C prefers id and nil.<br />void*的不同<br />Objective-C uses "selectors" (which have type SEL) as an approximate equivalent to function pointers.<br />？？<br />Objective-C uses a messaging paradigm (a la Smalltalk) where you can send "messages" to objects through methods/selectors.<br />messaging机制<br />Objective-C will happily let you send a message to nil, unlike C++ which will crash if you try to call a member function of nullptr<br />可以发送消息给nil<br />Objective-C allows for dynamic dispatch, allowing the class responding to a message to be determined at runtime, unlike C++ where the object a method is invoked upon must be known at compile time (see wilhelmtell's comment below). This is related to the previous point.<br />oc允许dynamic dispatch，允许class运行时对消息进行反映。而c++的方法必须在编译时确定<br />Objective-C allows autogeneration of accessors for member variables using "properties".<br />支持properties，实现队成员变量accessors的自动生成<br />Objective-C allows assigning to self, and allows class initialisers (similar to constructors) to return a completely different class if desired. Contrast to C++, where if you create a new instance of a class (either implicitly on the stack, or explicitly through new) it is guaranteed to be of the type you originally specified.<br />Similarly, in Objective-C other classes may also dynamically alter a target class at runtime to intercept method calls.<br />Objective-C lacks the namespace feature of C++.<br />Objective-C lacks an equivalent to C++ references.<br />Objective-C lacks templates, preferring (for example) to instead allow weak typing in containers.<br />Objective-C doesn't allow implicit method overloading, but C++ does. That is, in C++ int foo (void) and int foo (int) define an implicit overload of the method foo, but to achieve the same in Objective-C requires the explicit overloads - (int) foo and - (int) foo:(int) intParam. This is due to Objective-C's named parameters being functionally equivalent to C++'s name mangling.<br />Objective-C will happily allow a method and a variable to share the same name, unlike C++ which will typically have fits. I imagine this is something to do with Objective-C using selectors instead of function pointers, and thus method names not actually having a "value".<br />Objective-C doesn't allow objects to be created on the stack - all objects must be allocated from the heap (either explicitly with an alloc message, or implicitly in an appropriate factory method).<br />Like C++, Objective-C has both structs and classes. However, where in C++ they are treated as almost exactly the same, in Objective-C they are treated wildly differently - you can create structs on the stack, for instance.</p>
<p>In my opinion, probably the biggest difference is the syntax. You can achieve essentially the same things in either language, but in my opinion the C++ syntax is simpler while some of Objective-C's features make certain tasks (such as GUI design) easier thanks to dynamic dispatch.<br />我觉得最大的不同是语法，俺觉得C++ syntax的语法更简单。而oc对dynamic dispatch的支持更好</p>
<p>Probably plenty of other things too that I've missed, I'll update with any other things I think of. Other than that, can highly recommend the guide LiraNuna pointed you to. Incidentally, another site of interest might be this.</p>
<p>I should also point out that I'm just starting learning Objective-C myself, and as such a lot of the above may not quite be correct or complete - I apologise if that's the case, and welcome suggestions for improvement.</p>
<p>EDIT: updated to address the points raised in the following comments, added a few more items to the list.</p>
<p><br />While they are both rooted in C, they are two completely different languages.</p>
<p>A major difference is that Objective-C is focused on runtime-decisions for dispatching and heavily depends on its runtime library to handle inheritance and polymorphism, while in C++ the focus usually lies on static, compile time, decisions.<br />主要的不同是oc关注运行时的决策，用于dispatching，严重依赖于运行时库来处理inheritance and polymorphism。而c++关注静态，编译时的决策<br />Regarding libraries, you can use plain C libraries in both languages - but their native libraries are completely different.</p>
<p>Of interest though is that you can mix both languages (with some limitations). The result is called Objective-C++.</p>
<p><br />They're completely different. Objective C has more in common with Smalltalk than with C++ (well, except for the syntax, really).<br />oc和smalltalk更相似，而不是c++</p>
<p>&nbsp;</p>