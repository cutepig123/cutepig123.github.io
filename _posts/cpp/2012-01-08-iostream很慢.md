---
categories: cpp
---
<p>在这里，我不得不纠正大家以为iostream很慢的这样一个以讹传讹流毒无穷的错误观念。<br />大家观察到的iostream慢，通常都是因为C++需要保持对C的IO Library兼容，所以C++的io library是没有buffer的，而且必须一个字符一个字符来读取！<br />比如说有人蛋疼这么写：<br />getline(cin, s);<br />scanf("%d", &amp;i);<br />这 里getline只能一个字符一个字符读取，假如它一次读了100个字符，只用到了10个，剩下的90个没办法放回stdin里面，这样下面的scanf 就是从错误的位置读取的。所以C++的library为了兼容C，不得不一个字符一个字符读取。这样就导致C++的iostream比较慢。<br />好在这个行为是可以设置的。cin.sync_with_stdio(false); 这样就会让C++的iostream变快了。当然你如果这么做你得保证没有用到C的io library。<br />下面是测试：<br />[xxx@yyy ~]$ cat TestCIO.c &amp;&amp; gcc -O3 TestCIO.c -o TestCIO.out <br />#include &lt;stdio.h&gt;<br /><br />int main(int argc, char** argv)<br />{<br />&nbsp;&nbsp;char s[1024];<br />&nbsp;&nbsp;while(fgets(s,1024,stdin))<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp; &nbsp;printf("%s",s);<br />&nbsp;&nbsp;}<br />}<br /><br />[xxx@yyy ~]$ cat TestCXXIO.cpp &amp;&amp; g++ -O3 TestCXXIO.cpp -o TestCXXIO.out <br />#include &lt;iostream&gt;<br />using namespace std;<br /><br />int main(int argc, char** argv)<br />{<br />&nbsp;&nbsp;cin.sync_with_stdio(false);<br />&nbsp;&nbsp;char s[1024];<br />&nbsp;&nbsp;while(cin.getline(s,1024,'\n'))<br />&nbsp;&nbsp; &nbsp;cout &lt;&lt; s &lt;&lt; endl;<br />}<br /><br />[xxx@yyy ~]$ time for ((i = 0; i &lt; 10; i++)); do ./TestCIO.out &lt; some_text; done<br />...........<br />real &nbsp; &nbsp;0m7.170s<br />user &nbsp; &nbsp;0m0.957s<br />sys &nbsp; &nbsp; 0m1.623s<br /><br />[xxx@yyy ~]$ time for ((i = 0; i &lt; 10; i++)); do ./TestCXXIO.out &lt; some_text; done<br />...........<br />real &nbsp; &nbsp;0m7.123s<br />user &nbsp; &nbsp;0m0.742s<br />sys &nbsp; &nbsp; 0m1.737s<br /><br />两者的速度是一致的。</p>