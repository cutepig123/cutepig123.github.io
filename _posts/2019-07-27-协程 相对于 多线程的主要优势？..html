<ul>
<li>内存使用量少，几k vs 至少1MB</li>
<li>可增长的分段堆栈</li>
<li>启动时间比线程快</li>
<li>在共享数据结构时避免使用互斥锁</li>
</ul>
<p>&nbsp;</p>
<p><a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65">https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65</a></p>
<ul>
<li>&nbsp;<strong class="jf km"><span><span>非常快速的上下文切换</span></span></strong></li>
<li><strong class="jf km"><span><span>没有并发问题</span></span></strong></li>
<li><strong class="jf km"><strong class="jf km"><span><span>选择您的调度程序</span></span></strong></strong></li>
<li><strong class="jf km"><strong class="jf km"><span><span>性能 </span></span></strong></strong></li>
</ul>
<ul>
<li id="860c" class="jd je dr ax jf b jg jh ji jj jk jl jm jn jo jp jq kj kk kl" data-selectable-paragraph="">Yield (thread: 1.5 microseconds, fiber:<strong class="jf km">&nbsp;0.31 microseconds</strong>)</li>
<li id="ab79" class="jd je dr ax jf b jg kn ji ko jk kp jm kq jo kr jq kj kk kl" data-selectable-paragraph="">Creation (thread: 18 microseconds, fiber:&nbsp;<strong class="jf km">0.45 microseconds</strong>)</li>
<li class="jd je dr ax jf b jg kn ji ko jk kp jm kq jo kr jq kj kk kl" data-selectable-paragraph=""></li>
</ul>
<p><a href="https://medium.com/software-design/boost-fiber-in-your-code-9dcdda70ca00">https://medium.com/software-design/boost-fiber-in-your-code-9dcdda70ca00</a></p>
<p class="title"><strong>Table&nbsp;1.1.&nbsp;time per actor/erlang process/goroutine (other languages) (average over 1,000,000)</strong></p>
<div class="table-contents">
<table class="table" summary="time per actor/erlang process/goroutine (other languages) (average over
      1,000,000)"><colgroup><col /><col /><col /></colgroup>
<thead>
<tr><th>
<p>Haskell | stack-1.4.0</p>
</th><th>
<p>Go | go1.8</p>
</th><th>
<p>Erlang | erts-8.3</p>
</th></tr>
</thead>
<tbody>
<tr>
<td>
<p>0.05 &micro;s - 0.06 &micro;s</p>
</td>
<td>
<p>0.45 &micro;s - 0.52 &micro;s</p>
</td>
<td>
<p>0.63 &micro;s - 0.73 &micro;s</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="title"><strong>Table&nbsp;1.2.&nbsp;time per thread (average over *10,000* - unable to spawn 1,000,000 threads)</strong></p>
<div class="table-contents">
<table class="table" summary="time per thread (average over *10,000* - unable to spawn 1,000,000 threads)"><colgroup><col /><col /></colgroup>
<thead>
<tr><th>
<p>pthread</p>
</th><th>
<p><code class="computeroutput"><span class="identifier">std<span class="special">::<span class="identifier">thread</span></span></span></code></p>
</th></tr>
</thead>
<tbody>
<tr>
<td>
<p>54 &micro;s - 73 &micro;s</p>
</td>
<td>
<p>52 &micro;s - 73 &micro;s</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p class="title"><strong>Table&nbsp;1.3.&nbsp;time per fiber (average over 1.000.000)</strong></p>
<div class="table-contents">
<table class="table" summary="time per fiber (average over 1.000.000)"><colgroup><col /><col /></colgroup>
<thead>
<tr><th>
<p>fiber (16C/32T, work stealing, tcmalloc)</p>
</th><th>
<p>fiber (1C/1T, round robin, tcmalloc)</p>
</th></tr>
</thead>
<tbody>
<tr>
<td>
<p>0.05 &micro;s - 0.11 &micro;s</p>
</td>
<td>
<p>1.69 &micro;s - 1.79 &micro;s</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p><a href="https://www.boost.org/doc/libs/1_64_0/libs/fiber/doc/html/fiber/performance.html">https://www.boost.org/doc/libs/1_64_0/libs/fiber/doc/html/fiber/performance.html</a></p>
<p>其他：我猜的</p>
<ul>
<li>cache miss机会少？ stackless有机会少，stackful由于要求换堆栈寄存器，未必</li>
<li>由于不需要进入kernel，减少context switch</li>
</ul>
<p>&nbsp;</p>
<p>线程池的主要优势？</p>
<ul>
<li>内存使用量少</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;tbb flow graph how to schedule tasks</p>
<p>from <a href="https://software.intel.com/en-us/node/506295">https://software.intel.com/en-us/node/506295</a></p>
<p><span><span>调度程序采用称为</span></span><em><span><span>工作窃取</span></span></em><span><span>的技术</span></span></p>
<p>&nbsp;</p>