<p>erl<br />- 命令以.结尾<br />- %为注释<br />- 变量必须大写开头 X = 12.<br />- [1,3.4,true] is a list and {person, 25, "Jason"} is a tuple. <br />- tuple赋值orpattern match<br />{ip, IP} = {ip, "192.168.0.1"}.<br />{Atom, IP} = {ip, "192.168.0.1"}. &nbsp;<br />-variable 和atom ，前者大写开头，后者小写开头<br />- loops are done through recursion<br />如下例<br />-module(factorial).<br />-export([factorial/1]).<br /><br />factorial(0) -&gt; 1.<br />factorial(N) -&gt;<br />&nbsp;&nbsp;&nbsp; N * factorial(N-1).<br />- 加减乘除都为实数支持大整数，求余为rem&nbsp; div&nbsp;&nbsp; &nbsp;<br />- 变量名被赋值后，不允许被再次定义<br />9&gt; Two = 2. &nbsp;<br />2 &nbsp;<br />10&gt; two = 3. &nbsp;<br />** exception error: no match of right hand side value 3 &nbsp;<br />11&gt; Two = 3. &nbsp;<br />** exception error: no match of right hand side value 3 <br /><br />-清除变量<br />&nbsp; f(变量名) -- 清除对该变量的赋值<br />&nbsp; f().&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 清除所有变量的赋值 <br />&nbsp; <br />- .and 和 or 都会计算两边的值 ，若是你期望只做一个短路运算的话 ，那么就需要用到 andalso 好 orelse .这个就是类似于 java的 &amp;&amp; || 运算符！ <br />&nbsp; <br />- 1.=:= 等同于其他语言中的 == 。&nbsp; =/=和/= 等同于其他语言中的 !=&nbsp; 这个地方还有疑问！<br />2.从上面的解析看， =:=比较的类似于java中的内存地址比较 == 比较的是两个地址的值是否相同！<br />3.其他的还有就是 &gt;= =&lt; <br /><br />&nbsp;&nbsp;&nbsp; 56&gt; 5 == 5.0. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 57&gt; 5 =:= 5. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 58&gt; 1=/=0. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 59&gt; 1=:=0. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br />&nbsp;&nbsp;&nbsp; 60&gt; 5=:=5.0. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br />&nbsp;&nbsp;&nbsp; 61&gt; 5==5.0. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 62&gt; 1/=3. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br /><br />&nbsp;&nbsp;&nbsp; 66&gt; 1 &gt;= 1. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 67&gt; 1 =&lt; 1. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br />&nbsp;&nbsp;&nbsp; 68&gt; 1 &gt; 3. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br />&nbsp;&nbsp;&nbsp; 69&gt; 1 &lt; 3. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br /><br />&nbsp;&nbsp;&nbsp; 77&gt; 5 =:= false. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br />&nbsp;&nbsp;&nbsp; 78&gt; 5 ==false. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br /><br />&nbsp;&nbsp;&nbsp; 79&gt; 1 == false. &nbsp;<br />&nbsp;&nbsp;&nbsp; false &nbsp;<br />&nbsp;&nbsp;&nbsp; 80&gt; 1 &lt; false. &nbsp;<br />&nbsp;&nbsp;&nbsp; true &nbsp;<br /><br />在erlang中没有 true和false的布尔类型变量。 这里的 true 和 false 都是 atom.原子单一的变量(可能描述的不准确)。<br />在erlang中不同类型之间的比较关系如下所示：<br />Java代码&nbsp; 收藏代码<br /><br />&nbsp;&nbsp;&nbsp; number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string <br /><br />&mdash;&mdash; _可以匹配任何变量<br />6&gt; {_,_,A}={12,23,222}.<br />{12,23,222}<br />7&gt; A.<br />222<br />8&gt; _.<br />* 1: variable '_' is unbound<br />&nbsp;&nbsp;&nbsp;</p>